/*! For license information please see viewer.js.LICENSE.txt */
!function() {
    var t = {
        1983: function(t, e, n) {
            "use strict";
            n(6266),
            n(990),
            n(911),
            n(4160),
            n(6197),
            n(6728),
            n(4039),
            n(3568),
            n(8051),
            n(8250),
            n(5434),
            n(4952),
            n(6337),
            n(2928)
        },
        2928: function(t) {
            var e = function(t) {
                "use strict";
                var e, n = Object.prototype, i = n.hasOwnProperty, r = Object.defineProperty || function(t, e, n) {
                    t[e] = n.value
                }
                , s = "function" == typeof Symbol ? Symbol : {}, o = s.iterator || "@@iterator", a = s.asyncIterator || "@@asyncIterator", l = s.toStringTag || "@@toStringTag";
                function c(t, e, n) {
                    return Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }),
                    t[e]
                }
                try {
                    c({}, "")
                } catch (t) {
                    c = function(t, e, n) {
                        return t[e] = n
                    }
                }
                function u(t, e, n, i) {
                    var s = e && e.prototype instanceof m ? e : m
                      , o = Object.create(s.prototype)
                      , a = new B(i || []);
                    return r(o, "_invoke", {
                        value: C(t, n, a)
                    }),
                    o
                }
                function h(t, e, n) {
                    try {
                        return {
                            type: "normal",
                            arg: t.call(e, n)
                        }
                    } catch (t) {
                        return {
                            type: "throw",
                            arg: t
                        }
                    }
                }
                t.wrap = u;
                var d = "suspendedStart"
                  , p = "suspendedYield"
                  , f = "executing"
                  , A = "completed"
                  , g = {};
                function m() {}
                function v() {}
                function y() {}
                var _ = {};
                c(_, o, (function() {
                    return this
                }
                ));
                var E = Object.getPrototypeOf
                  , b = E && E(E(R([])));
                b && b !== n && i.call(b, o) && (_ = b);
                var x = y.prototype = m.prototype = Object.create(_);
                function w(t) {
                    ["next", "throw", "return"].forEach((function(e) {
                        c(t, e, (function(t) {
                            return this._invoke(e, t)
                        }
                        ))
                    }
                    ))
                }
                function S(t, e) {
                    function n(r, s, o, a) {
                        var l = h(t[r], t, s);
                        if ("throw" !== l.type) {
                            var c = l.arg
                              , u = c.value;
                            return u && "object" == typeof u && i.call(u, "__await") ? e.resolve(u.__await).then((function(t) {
                                n("next", t, o, a)
                            }
                            ), (function(t) {
                                n("throw", t, o, a)
                            }
                            )) : e.resolve(u).then((function(t) {
                                c.value = t,
                                o(c)
                            }
                            ), (function(t) {
                                return n("throw", t, o, a)
                            }
                            ))
                        }
                        a(l.arg)
                    }
                    var s;
                    r(this, "_invoke", {
                        value: function(t, i) {
                            function r() {
                                return new e((function(e, r) {
                                    n(t, i, e, r)
                                }
                                ))
                            }
                            return s = s ? s.then(r, r) : r()
                        }
                    })
                }
                function C(t, e, n) {
                    var i = d;
                    return function(r, s) {
                        if (i === f)
                            throw new Error("Generator is already running");
                        if (i === A) {
                            if ("throw" === r)
                                throw s;
                            return L()
                        }
                        for (n.method = r,
                        n.arg = s; ; ) {
                            var o = n.delegate;
                            if (o) {
                                var a = M(o, n);
                                if (a) {
                                    if (a === g)
                                        continue;
                                    return a
                                }
                            }
                            if ("next" === n.method)
                                n.sent = n._sent = n.arg;
                            else if ("throw" === n.method) {
                                if (i === d)
                                    throw i = A,
                                    n.arg;
                                n.dispatchException(n.arg)
                            } else
                                "return" === n.method && n.abrupt("return", n.arg);
                            i = f;
                            var l = h(t, e, n);
                            if ("normal" === l.type) {
                                if (i = n.done ? A : p,
                                l.arg === g)
                                    continue;
                                return {
                                    value: l.arg,
                                    done: n.done
                                }
                            }
                            "throw" === l.type && (i = A,
                            n.method = "throw",
                            n.arg = l.arg)
                        }
                    }
                }
                function M(t, n) {
                    var i = n.method
                      , r = t.iterator[i];
                    if (r === e)
                        return n.delegate = null,
                        "throw" === i && t.iterator.return && (n.method = "return",
                        n.arg = e,
                        M(t, n),
                        "throw" === n.method) || "return" !== i && (n.method = "throw",
                        n.arg = new TypeError("The iterator does not provide a '" + i + "' method")),
                        g;
                    var s = h(r, t.iterator, n.arg);
                    if ("throw" === s.type)
                        return n.method = "throw",
                        n.arg = s.arg,
                        n.delegate = null,
                        g;
                    var o = s.arg;
                    return o ? o.done ? (n[t.resultName] = o.value,
                    n.next = t.nextLoc,
                    "return" !== n.method && (n.method = "next",
                    n.arg = e),
                    n.delegate = null,
                    g) : o : (n.method = "throw",
                    n.arg = new TypeError("iterator result is not an object"),
                    n.delegate = null,
                    g)
                }
                function I(t) {
                    var e = {
                        tryLoc: t[0]
                    };
                    1 in t && (e.catchLoc = t[1]),
                    2 in t && (e.finallyLoc = t[2],
                    e.afterLoc = t[3]),
                    this.tryEntries.push(e)
                }
                function T(t) {
                    var e = t.completion || {};
                    e.type = "normal",
                    delete e.arg,
                    t.completion = e
                }
                function B(t) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }],
                    t.forEach(I, this),
                    this.reset(!0)
                }
                function R(t) {
                    if (t) {
                        var n = t[o];
                        if (n)
                            return n.call(t);
                        if ("function" == typeof t.next)
                            return t;
                        if (!isNaN(t.length)) {
                            var r = -1
                              , s = function n() {
                                for (; ++r < t.length; )
                                    if (i.call(t, r))
                                        return n.value = t[r],
                                        n.done = !1,
                                        n;
                                return n.value = e,
                                n.done = !0,
                                n
                            };
                            return s.next = s
                        }
                    }
                    return {
                        next: L
                    }
                }
                function L() {
                    return {
                        value: e,
                        done: !0
                    }
                }
                return v.prototype = y,
                r(x, "constructor", {
                    value: y,
                    configurable: !0
                }),
                r(y, "constructor", {
                    value: v,
                    configurable: !0
                }),
                v.displayName = c(y, l, "GeneratorFunction"),
                t.isGeneratorFunction = function(t) {
                    var e = "function" == typeof t && t.constructor;
                    return !!e && (e === v || "GeneratorFunction" === (e.displayName || e.name))
                }
                ,
                t.mark = function(t) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(t, y) : (t.__proto__ = y,
                    c(t, l, "GeneratorFunction")),
                    t.prototype = Object.create(x),
                    t
                }
                ,
                t.awrap = function(t) {
                    return {
                        __await: t
                    }
                }
                ,
                w(S.prototype),
                c(S.prototype, a, (function() {
                    return this
                }
                )),
                t.AsyncIterator = S,
                t.async = function(e, n, i, r, s) {
                    void 0 === s && (s = Promise);
                    var o = new S(u(e, n, i, r),s);
                    return t.isGeneratorFunction(n) ? o : o.next().then((function(t) {
                        return t.done ? t.value : o.next()
                    }
                    ))
                }
                ,
                w(x),
                c(x, l, "Generator"),
                c(x, o, (function() {
                    return this
                }
                )),
                c(x, "toString", (function() {
                    return "[object Generator]"
                }
                )),
                t.keys = function(t) {
                    var e = Object(t)
                      , n = [];
                    for (var i in e)
                        n.push(i);
                    return n.reverse(),
                    function t() {
                        for (; n.length; ) {
                            var i = n.pop();
                            if (i in e)
                                return t.value = i,
                                t.done = !1,
                                t
                        }
                        return t.done = !0,
                        t
                    }
                }
                ,
                t.values = R,
                B.prototype = {
                    constructor: B,
                    reset: function(t) {
                        if (this.prev = 0,
                        this.next = 0,
                        this.sent = this._sent = e,
                        this.done = !1,
                        this.delegate = null,
                        this.method = "next",
                        this.arg = e,
                        this.tryEntries.forEach(T),
                        !t)
                            for (var n in this)
                                "t" === n.charAt(0) && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
                    },
                    stop: function() {
                        this.done = !0;
                        var t = this.tryEntries[0].completion;
                        if ("throw" === t.type)
                            throw t.arg;
                        return this.rval
                    },
                    dispatchException: function(t) {
                        if (this.done)
                            throw t;
                        var n = this;
                        function r(i, r) {
                            return a.type = "throw",
                            a.arg = t,
                            n.next = i,
                            r && (n.method = "next",
                            n.arg = e),
                            !!r
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var o = this.tryEntries[s]
                              , a = o.completion;
                            if ("root" === o.tryLoc)
                                return r("end");
                            if (o.tryLoc <= this.prev) {
                                var l = i.call(o, "catchLoc")
                                  , c = i.call(o, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < o.catchLoc)
                                        return r(o.catchLoc, !0);
                                    if (this.prev < o.finallyLoc)
                                        return r(o.finallyLoc)
                                } else if (l) {
                                    if (this.prev < o.catchLoc)
                                        return r(o.catchLoc, !0)
                                } else {
                                    if (!c)
                                        throw new Error("try statement without catch or finally");
                                    if (this.prev < o.finallyLoc)
                                        return r(o.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(t, e) {
                        for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                            var r = this.tryEntries[n];
                            if (r.tryLoc <= this.prev && i.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var s = r;
                                break
                            }
                        }
                        s && ("break" === t || "continue" === t) && s.tryLoc <= e && e <= s.finallyLoc && (s = null);
                        var o = s ? s.completion : {};
                        return o.type = t,
                        o.arg = e,
                        s ? (this.method = "next",
                        this.next = s.finallyLoc,
                        g) : this.complete(o)
                    },
                    complete: function(t, e) {
                        if ("throw" === t.type)
                            throw t.arg;
                        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg,
                        this.method = "return",
                        this.next = "end") : "normal" === t.type && e && (this.next = e),
                        g
                    },
                    finish: function(t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var n = this.tryEntries[e];
                            if (n.finallyLoc === t)
                                return this.complete(n.completion, n.afterLoc),
                                T(n),
                                g
                        }
                    },
                    catch: function(t) {
                        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                            var n = this.tryEntries[e];
                            if (n.tryLoc === t) {
                                var i = n.completion;
                                if ("throw" === i.type) {
                                    var r = i.arg;
                                    T(n)
                                }
                                return r
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(t, n, i) {
                        return this.delegate = {
                            iterator: R(t),
                            resultName: n,
                            nextLoc: i
                        },
                        "next" === this.method && (this.arg = e),
                        g
                    }
                },
                t
            }(t.exports);
            try {
                regeneratorRuntime = e
            } catch (t) {
                "object" == typeof globalThis ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e)
            }
        },
        6266: function(t, e, n) {
            n(5767),
            n(8132),
            n(8388),
            n(7470),
            n(4882),
            n(1520),
            n(7476),
            n(9622),
            n(9375),
            n(3533),
            n(4672),
            n(4157),
            n(5095),
            n(9892),
            n(5115),
            n(9176),
            n(8838),
            n(6253),
            n(9730),
            n(6059),
            n(8377),
            n(1084),
            n(4299),
            n(1246),
            n(726),
            n(1901),
            n(5972),
            n(3403),
            n(2516),
            n(9371),
            n(6479),
            n(1736),
            n(1889),
            n(5177),
            n(6943),
            n(6503),
            n(6786),
            n(932),
            n(7526),
            n(1591),
            n(9073),
            n(347),
            n(579),
            n(4669),
            n(7710),
            n(5789),
            n(3514),
            n(9978),
            n(8472),
            n(6946),
            n(5068),
            n(413),
            n(191),
            n(8306),
            n(4564),
            n(9115),
            n(9539),
            n(6620),
            n(2850),
            n(823),
            n(7732),
            n(856),
            n(703),
            n(1539),
            n(5292),
            n(6629),
            n(3694),
            n(7648),
            n(7795),
            n(4531),
            n(3605),
            n(6780),
            n(9937),
            n(511),
            n(1822),
            n(9977),
            n(1031),
            n(6331),
            n(1560),
            n(774),
            n(522),
            n(8295),
            n(7842),
            n(110),
            n(75),
            n(4336),
            n(1802),
            n(8837),
            n(6773),
            n(5745),
            n(3057),
            n(3750),
            n(3369),
            n(9564),
            n(2e3),
            n(8977),
            n(2310),
            n(4899),
            n(1842),
            n(6997),
            n(3946),
            n(8269),
            n(6108),
            n(6774),
            n(1466),
            n(9357),
            n(6142),
            n(1876),
            n(851),
            n(8416),
            n(8184),
            n(147),
            n(9192),
            n(142),
            n(1786),
            n(5368),
            n(6964),
            n(2152),
            n(4821),
            n(9103),
            n(1303),
            n(3318),
            n(162),
            n(3834),
            n(1572),
            n(2139),
            n(685),
            n(5535),
            n(7347),
            n(3049),
            n(6633),
            n(8989),
            n(8270),
            n(4510),
            n(3984),
            n(5769),
            n(55),
            n(6014),
            t.exports = n(5645)
        },
        911: function(t, e, n) {
            n(1268),
            t.exports = n(5645).Array.flatMap
        },
        990: function(t, e, n) {
            n(2773),
            t.exports = n(5645).Array.includes
        },
        5434: function(t, e, n) {
            n(3276),
            t.exports = n(5645).Object.entries
        },
        8051: function(t, e, n) {
            n(8351),
            t.exports = n(5645).Object.getOwnPropertyDescriptors
        },
        8250: function(t, e, n) {
            n(6409),
            t.exports = n(5645).Object.values
        },
        4952: function(t, e, n) {
            "use strict";
            n(851),
            n(9865),
            t.exports = n(5645).Promise.finally
        },
        6197: function(t, e, n) {
            n(2770),
            t.exports = n(5645).String.padEnd
        },
        4160: function(t, e, n) {
            n(1784),
            t.exports = n(5645).String.padStart
        },
        4039: function(t, e, n) {
            n(4325),
            t.exports = n(5645).String.trimRight
        },
        6728: function(t, e, n) {
            n(5869),
            t.exports = n(5645).String.trimLeft
        },
        3568: function(t, e, n) {
            n(9665),
            t.exports = n(8787).f("asyncIterator")
        },
        115: function(t, e, n) {
            n(4579),
            t.exports = n(1327).global
        },
        5663: function(t) {
            t.exports = function(t) {
                if ("function" != typeof t)
                    throw TypeError(t + " is not a function!");
                return t
            }
        },
        2159: function(t, e, n) {
            var i = n(6727);
            t.exports = function(t) {
                if (!i(t))
                    throw TypeError(t + " is not an object!");
                return t
            }
        },
        1327: function(t) {
            var e = t.exports = {
                version: "2.6.12"
            };
            "number" == typeof __e && (__e = e)
        },
        9216: function(t, e, n) {
            var i = n(5663);
            t.exports = function(t, e, n) {
                if (i(t),
                void 0 === e)
                    return t;
                switch (n) {
                case 1:
                    return function(n) {
                        return t.call(e, n)
                    }
                    ;
                case 2:
                    return function(n, i) {
                        return t.call(e, n, i)
                    }
                    ;
                case 3:
                    return function(n, i, r) {
                        return t.call(e, n, i, r)
                    }
                }
                return function() {
                    return t.apply(e, arguments)
                }
            }
        },
        9666: function(t, e, n) {
            t.exports = !n(7929)((function() {
                return 7 != Object.defineProperty({}, "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
            ))
        },
        7467: function(t, e, n) {
            var i = n(6727)
              , r = n(3938).document
              , s = i(r) && i(r.createElement);
            t.exports = function(t) {
                return s ? r.createElement(t) : {}
            }
        },
        3856: function(t, e, n) {
            var i = n(3938)
              , r = n(1327)
              , s = n(9216)
              , o = n(1818)
              , a = n(7069)
              , l = "prototype"
              , c = function(t, e, n) {
                var u, h, d, p = t & c.F, f = t & c.G, A = t & c.S, g = t & c.P, m = t & c.B, v = t & c.W, y = f ? r : r[e] || (r[e] = {}), _ = y[l], E = f ? i : A ? i[e] : (i[e] || {})[l];
                for (u in f && (n = e),
                n)
                    (h = !p && E && void 0 !== E[u]) && a(y, u) || (d = h ? E[u] : n[u],
                    y[u] = f && "function" != typeof E[u] ? n[u] : m && h ? s(d, i) : v && E[u] == d ? function(t) {
                        var e = function(e, n, i) {
                            if (this instanceof t) {
                                switch (arguments.length) {
                                case 0:
                                    return new t;
                                case 1:
                                    return new t(e);
                                case 2:
                                    return new t(e,n)
                                }
                                return new t(e,n,i)
                            }
                            return t.apply(this, arguments)
                        };
                        return e[l] = t[l],
                        e
                    }(d) : g && "function" == typeof d ? s(Function.call, d) : d,
                    g && ((y.virtual || (y.virtual = {}))[u] = d,
                    t & c.R && _ && !_[u] && o(_, u, d)))
            };
            c.F = 1,
            c.G = 2,
            c.S = 4,
            c.P = 8,
            c.B = 16,
            c.W = 32,
            c.U = 64,
            c.R = 128,
            t.exports = c
        },
        7929: function(t) {
            t.exports = function(t) {
                try {
                    return !!t()
                } catch (t) {
                    return !0
                }
            }
        },
        3938: function(t) {
            var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = e)
        },
        7069: function(t) {
            var e = {}.hasOwnProperty;
            t.exports = function(t, n) {
                return e.call(t, n)
            }
        },
        1818: function(t, e, n) {
            var i = n(4743)
              , r = n(3101);
            t.exports = n(9666) ? function(t, e, n) {
                return i.f(t, e, r(1, n))
            }
            : function(t, e, n) {
                return t[e] = n,
                t
            }
        },
        3758: function(t, e, n) {
            t.exports = !n(9666) && !n(7929)((function() {
                return 7 != Object.defineProperty(n(7467)("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
            ))
        },
        6727: function(t) {
            t.exports = function(t) {
                return "object" == typeof t ? null !== t : "function" == typeof t
            }
        },
        4743: function(t, e, n) {
            var i = n(2159)
              , r = n(3758)
              , s = n(3206)
              , o = Object.defineProperty;
            e.f = n(9666) ? Object.defineProperty : function(t, e, n) {
                if (i(t),
                e = s(e, !0),
                i(n),
                r)
                    try {
                        return o(t, e, n)
                    } catch (t) {}
                if ("get"in n || "set"in n)
                    throw TypeError("Accessors not supported!");
                return "value"in n && (t[e] = n.value),
                t
            }
        },
        3101: function(t) {
            t.exports = function(t, e) {
                return {
                    enumerable: !(1 & t),
                    configurable: !(2 & t),
                    writable: !(4 & t),
                    value: e
                }
            }
        },
        3206: function(t, e, n) {
            var i = n(6727);
            t.exports = function(t, e) {
                if (!i(t))
                    return t;
                var n, r;
                if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                    return r;
                if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t)))
                    return r;
                if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                    return r;
                throw TypeError("Can't convert object to primitive value")
            }
        },
        4579: function(t, e, n) {
            var i = n(3856);
            i(i.G, {
                global: n(3938)
            })
        },
        4963: function(t) {
            t.exports = function(t) {
                if ("function" != typeof t)
                    throw TypeError(t + " is not a function!");
                return t
            }
        },
        3365: function(t, e, n) {
            var i = n(2032);
            t.exports = function(t, e) {
                if ("number" != typeof t && "Number" != i(t))
                    throw TypeError(e);
                return +t
            }
        },
        7722: function(t, e, n) {
            var i = n(6314)("unscopables")
              , r = Array.prototype;
            null == r[i] && n(7728)(r, i, {}),
            t.exports = function(t) {
                r[i][t] = !0
            }
        },
        6793: function(t, e, n) {
            "use strict";
            var i = n(4496)(!0);
            t.exports = function(t, e, n) {
                return e + (n ? i(t, e).length : 1)
            }
        },
        3328: function(t) {
            t.exports = function(t, e, n, i) {
                if (!(t instanceof e) || void 0 !== i && i in t)
                    throw TypeError(n + ": incorrect invocation!");
                return t
            }
        },
        7007: function(t, e, n) {
            var i = n(5286);
            t.exports = function(t) {
                if (!i(t))
                    throw TypeError(t + " is not an object!");
                return t
            }
        },
        5216: function(t, e, n) {
            "use strict";
            var i = n(508)
              , r = n(2337)
              , s = n(875);
            t.exports = [].copyWithin || function(t, e) {
                var n = i(this)
                  , o = s(n.length)
                  , a = r(t, o)
                  , l = r(e, o)
                  , c = arguments.length > 2 ? arguments[2] : void 0
                  , u = Math.min((void 0 === c ? o : r(c, o)) - l, o - a)
                  , h = 1;
                for (l < a && a < l + u && (h = -1,
                l += u - 1,
                a += u - 1); u-- > 0; )
                    l in n ? n[a] = n[l] : delete n[a],
                    a += h,
                    l += h;
                return n
            }
        },
        6852: function(t, e, n) {
            "use strict";
            var i = n(508)
              , r = n(2337)
              , s = n(875);
            t.exports = function(t) {
                for (var e = i(this), n = s(e.length), o = arguments.length, a = r(o > 1 ? arguments[1] : void 0, n), l = o > 2 ? arguments[2] : void 0, c = void 0 === l ? n : r(l, n); c > a; )
                    e[a++] = t;
                return e
            }
        },
        9315: function(t, e, n) {
            var i = n(2110)
              , r = n(875)
              , s = n(2337);
            t.exports = function(t) {
                return function(e, n, o) {
                    var a, l = i(e), c = r(l.length), u = s(o, c);
                    if (t && n != n) {
                        for (; c > u; )
                            if ((a = l[u++]) != a)
                                return !0
                    } else
                        for (; c > u; u++)
                            if ((t || u in l) && l[u] === n)
                                return t || u || 0;
                    return !t && -1
                }
            }
        },
        50: function(t, e, n) {
            var i = n(741)
              , r = n(9797)
              , s = n(508)
              , o = n(875)
              , a = n(6886);
            t.exports = function(t, e) {
                var n = 1 == t
                  , l = 2 == t
                  , c = 3 == t
                  , u = 4 == t
                  , h = 6 == t
                  , d = 5 == t || h
                  , p = e || a;
                return function(e, a, f) {
                    for (var A, g, m = s(e), v = r(m), y = i(a, f, 3), _ = o(v.length), E = 0, b = n ? p(e, _) : l ? p(e, 0) : void 0; _ > E; E++)
                        if ((d || E in v) && (g = y(A = v[E], E, m),
                        t))
                            if (n)
                                b[E] = g;
                            else if (g)
                                switch (t) {
                                case 3:
                                    return !0;
                                case 5:
                                    return A;
                                case 6:
                                    return E;
                                case 2:
                                    b.push(A)
                                }
                            else if (u)
                                return !1;
                    return h ? -1 : c || u ? u : b
                }
            }
        },
        7628: function(t, e, n) {
            var i = n(4963)
              , r = n(508)
              , s = n(9797)
              , o = n(875);
            t.exports = function(t, e, n, a, l) {
                i(e);
                var c = r(t)
                  , u = s(c)
                  , h = o(c.length)
                  , d = l ? h - 1 : 0
                  , p = l ? -1 : 1;
                if (n < 2)
                    for (; ; ) {
                        if (d in u) {
                            a = u[d],
                            d += p;
                            break
                        }
                        if (d += p,
                        l ? d < 0 : h <= d)
                            throw TypeError("Reduce of empty array with no initial value")
                    }
                for (; l ? d >= 0 : h > d; d += p)
                    d in u && (a = e(a, u[d], d, c));
                return a
            }
        },
        2736: function(t, e, n) {
            var i = n(5286)
              , r = n(4302)
              , s = n(6314)("species");
            t.exports = function(t) {
                var e;
                return r(t) && ("function" != typeof (e = t.constructor) || e !== Array && !r(e.prototype) || (e = void 0),
                i(e) && null === (e = e[s]) && (e = void 0)),
                void 0 === e ? Array : e
            }
        },
        6886: function(t, e, n) {
            var i = n(2736);
            t.exports = function(t, e) {
                return new (i(t))(e)
            }
        },
        4398: function(t, e, n) {
            "use strict";
            var i = n(4963)
              , r = n(5286)
              , s = n(7242)
              , o = [].slice
              , a = {};
            t.exports = Function.bind || function(t) {
                var e = i(this)
                  , n = o.call(arguments, 1)
                  , l = function() {
                    var i = n.concat(o.call(arguments));
                    return this instanceof l ? function(t, e, n) {
                        if (!(e in a)) {
                            for (var i = [], r = 0; r < e; r++)
                                i[r] = "a[" + r + "]";
                            a[e] = Function("F,a", "return new F(" + i.join(",") + ")")
                        }
                        return a[e](t, n)
                    }(e, i.length, i) : s(e, i, t)
                };
                return r(e.prototype) && (l.prototype = e.prototype),
                l
            }
        },
        1488: function(t, e, n) {
            var i = n(2032)
              , r = n(6314)("toStringTag")
              , s = "Arguments" == i(function() {
                return arguments
            }());
            t.exports = function(t) {
                var e, n, o;
                return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function(t, e) {
                    try {
                        return t[e]
                    } catch (t) {}
                }(e = Object(t), r)) ? n : s ? i(e) : "Object" == (o = i(e)) && "function" == typeof e.callee ? "Arguments" : o
            }
        },
        2032: function(t) {
            var e = {}.toString;
            t.exports = function(t) {
                return e.call(t).slice(8, -1)
            }
        },
        9824: function(t, e, n) {
            "use strict";
            var i = n(9275).f
              , r = n(2503)
              , s = n(4408)
              , o = n(741)
              , a = n(3328)
              , l = n(3531)
              , c = n(2923)
              , u = n(5436)
              , h = n(2974)
              , d = n(7057)
              , p = n(4728).fastKey
              , f = n(1616)
              , A = d ? "_s" : "size"
              , g = function(t, e) {
                var n, i = p(e);
                if ("F" !== i)
                    return t._i[i];
                for (n = t._f; n; n = n.n)
                    if (n.k == e)
                        return n
            };
            t.exports = {
                getConstructor: function(t, e, n, c) {
                    var u = t((function(t, i) {
                        a(t, u, e, "_i"),
                        t._t = e,
                        t._i = r(null),
                        t._f = void 0,
                        t._l = void 0,
                        t[A] = 0,
                        null != i && l(i, n, t[c], t)
                    }
                    ));
                    return s(u.prototype, {
                        clear: function() {
                            for (var t = f(this, e), n = t._i, i = t._f; i; i = i.n)
                                i.r = !0,
                                i.p && (i.p = i.p.n = void 0),
                                delete n[i.i];
                            t._f = t._l = void 0,
                            t[A] = 0
                        },
                        delete: function(t) {
                            var n = f(this, e)
                              , i = g(n, t);
                            if (i) {
                                var r = i.n
                                  , s = i.p;
                                delete n._i[i.i],
                                i.r = !0,
                                s && (s.n = r),
                                r && (r.p = s),
                                n._f == i && (n._f = r),
                                n._l == i && (n._l = s),
                                n[A]--
                            }
                            return !!i
                        },
                        forEach: function(t) {
                            f(this, e);
                            for (var n, i = o(t, arguments.length > 1 ? arguments[1] : void 0, 3); n = n ? n.n : this._f; )
                                for (i(n.v, n.k, this); n && n.r; )
                                    n = n.p
                        },
                        has: function(t) {
                            return !!g(f(this, e), t)
                        }
                    }),
                    d && i(u.prototype, "size", {
                        get: function() {
                            return f(this, e)[A]
                        }
                    }),
                    u
                },
                def: function(t, e, n) {
                    var i, r, s = g(t, e);
                    return s ? s.v = n : (t._l = s = {
                        i: r = p(e, !0),
                        k: e,
                        v: n,
                        p: i = t._l,
                        n: void 0,
                        r: !1
                    },
                    t._f || (t._f = s),
                    i && (i.n = s),
                    t[A]++,
                    "F" !== r && (t._i[r] = s)),
                    t
                },
                getEntry: g,
                setStrong: function(t, e, n) {
                    c(t, e, (function(t, n) {
                        this._t = f(t, e),
                        this._k = n,
                        this._l = void 0
                    }
                    ), (function() {
                        for (var t = this, e = t._k, n = t._l; n && n.r; )
                            n = n.p;
                        return t._t && (t._l = n = n ? n.n : t._t._f) ? u(0, "keys" == e ? n.k : "values" == e ? n.v : [n.k, n.v]) : (t._t = void 0,
                        u(1))
                    }
                    ), n ? "entries" : "values", !n, !0),
                    h(e)
                }
            }
        },
        3657: function(t, e, n) {
            "use strict";
            var i = n(4408)
              , r = n(4728).getWeak
              , s = n(7007)
              , o = n(5286)
              , a = n(3328)
              , l = n(3531)
              , c = n(50)
              , u = n(9181)
              , h = n(1616)
              , d = c(5)
              , p = c(6)
              , f = 0
              , A = function(t) {
                return t._l || (t._l = new g)
            }
              , g = function() {
                this.a = []
            }
              , m = function(t, e) {
                return d(t.a, (function(t) {
                    return t[0] === e
                }
                ))
            };
            g.prototype = {
                get: function(t) {
                    var e = m(this, t);
                    if (e)
                        return e[1]
                },
                has: function(t) {
                    return !!m(this, t)
                },
                set: function(t, e) {
                    var n = m(this, t);
                    n ? n[1] = e : this.a.push([t, e])
                },
                delete: function(t) {
                    var e = p(this.a, (function(e) {
                        return e[0] === t
                    }
                    ));
                    return ~e && this.a.splice(e, 1),
                    !!~e
                }
            },
            t.exports = {
                getConstructor: function(t, e, n, s) {
                    var c = t((function(t, i) {
                        a(t, c, e, "_i"),
                        t._t = e,
                        t._i = f++,
                        t._l = void 0,
                        null != i && l(i, n, t[s], t)
                    }
                    ));
                    return i(c.prototype, {
                        delete: function(t) {
                            if (!o(t))
                                return !1;
                            var n = r(t);
                            return !0 === n ? A(h(this, e)).delete(t) : n && u(n, this._i) && delete n[this._i]
                        },
                        has: function(t) {
                            if (!o(t))
                                return !1;
                            var n = r(t);
                            return !0 === n ? A(h(this, e)).has(t) : n && u(n, this._i)
                        }
                    }),
                    c
                },
                def: function(t, e, n) {
                    var i = r(s(e), !0);
                    return !0 === i ? A(t).set(e, n) : i[t._i] = n,
                    t
                },
                ufstore: A
            }
        },
        5795: function(t, e, n) {
            "use strict";
            var i = n(3816)
              , r = n(2985)
              , s = n(7234)
              , o = n(4408)
              , a = n(4728)
              , l = n(3531)
              , c = n(3328)
              , u = n(5286)
              , h = n(4253)
              , d = n(7462)
              , p = n(2943)
              , f = n(266);
            t.exports = function(t, e, n, A, g, m) {
                var v = i[t]
                  , y = v
                  , _ = g ? "set" : "add"
                  , E = y && y.prototype
                  , b = {}
                  , x = function(t) {
                    var e = E[t];
                    s(E, t, "delete" == t || "has" == t ? function(t) {
                        return !(m && !u(t)) && e.call(this, 0 === t ? 0 : t)
                    }
                    : "get" == t ? function(t) {
                        return m && !u(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
                    }
                    : "add" == t ? function(t) {
                        return e.call(this, 0 === t ? 0 : t),
                        this
                    }
                    : function(t, n) {
                        return e.call(this, 0 === t ? 0 : t, n),
                        this
                    }
                    )
                };
                if ("function" == typeof y && (m || E.forEach && !h((function() {
                    (new y).entries().next()
                }
                )))) {
                    var w = new y
                      , S = w[_](m ? {} : -0, 1) != w
                      , C = h((function() {
                        w.has(1)
                    }
                    ))
                      , M = d((function(t) {
                        new y(t)
                    }
                    ))
                      , I = !m && h((function() {
                        for (var t = new y, e = 5; e--; )
                            t[_](e, e);
                        return !t.has(-0)
                    }
                    ));
                    M || ((y = e((function(e, n) {
                        c(e, y, t);
                        var i = f(new v, e, y);
                        return null != n && l(n, g, i[_], i),
                        i
                    }
                    ))).prototype = E,
                    E.constructor = y),
                    (C || I) && (x("delete"),
                    x("has"),
                    g && x("get")),
                    (I || S) && x(_),
                    m && E.clear && delete E.clear
                } else
                    y = A.getConstructor(e, t, g, _),
                    o(y.prototype, n),
                    a.NEED = !0;
                return p(y, t),
                b[t] = y,
                r(r.G + r.W + r.F * (y != v), b),
                m || A.setStrong(y, t, g),
                y
            }
        },
        5645: function(t) {
            var e = t.exports = {
                version: "2.6.12"
            };
            "number" == typeof __e && (__e = e)
        },
        2811: function(t, e, n) {
            "use strict";
            var i = n(9275)
              , r = n(681);
            t.exports = function(t, e, n) {
                e in t ? i.f(t, e, r(0, n)) : t[e] = n
            }
        },
        741: function(t, e, n) {
            var i = n(4963);
            t.exports = function(t, e, n) {
                if (i(t),
                void 0 === e)
                    return t;
                switch (n) {
                case 1:
                    return function(n) {
                        return t.call(e, n)
                    }
                    ;
                case 2:
                    return function(n, i) {
                        return t.call(e, n, i)
                    }
                    ;
                case 3:
                    return function(n, i, r) {
                        return t.call(e, n, i, r)
                    }
                }
                return function() {
                    return t.apply(e, arguments)
                }
            }
        },
        3537: function(t, e, n) {
            "use strict";
            var i = n(4253)
              , r = Date.prototype.getTime
              , s = Date.prototype.toISOString
              , o = function(t) {
                return t > 9 ? t : "0" + t
            };
            t.exports = i((function() {
                return "0385-07-25T07:06:39.999Z" != s.call(new Date(-50000000000001))
            }
            )) || !i((function() {
                s.call(new Date(NaN))
            }
            )) ? function() {
                if (!isFinite(r.call(this)))
                    throw RangeError("Invalid time value");
                var t = this
                  , e = t.getUTCFullYear()
                  , n = t.getUTCMilliseconds()
                  , i = e < 0 ? "-" : e > 9999 ? "+" : "";
                return i + ("00000" + Math.abs(e)).slice(i ? -6 : -4) + "-" + o(t.getUTCMonth() + 1) + "-" + o(t.getUTCDate()) + "T" + o(t.getUTCHours()) + ":" + o(t.getUTCMinutes()) + ":" + o(t.getUTCSeconds()) + "." + (n > 99 ? n : "0" + o(n)) + "Z"
            }
            : s
        },
        870: function(t, e, n) {
            "use strict";
            var i = n(7007)
              , r = n(1689)
              , s = "number";
            t.exports = function(t) {
                if ("string" !== t && t !== s && "default" !== t)
                    throw TypeError("Incorrect hint");
                return r(i(this), t != s)
            }
        },
        1355: function(t) {
            t.exports = function(t) {
                if (null == t)
                    throw TypeError("Can't call method on  " + t);
                return t
            }
        },
        7057: function(t, e, n) {
            t.exports = !n(4253)((function() {
                return 7 != Object.defineProperty({}, "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
            ))
        },
        2457: function(t, e, n) {
            var i = n(5286)
              , r = n(3816).document
              , s = i(r) && i(r.createElement);
            t.exports = function(t) {
                return s ? r.createElement(t) : {}
            }
        },
        4430: function(t) {
            t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
        },
        5541: function(t, e, n) {
            var i = n(7184)
              , r = n(4548)
              , s = n(4682);
            t.exports = function(t) {
                var e = i(t)
                  , n = r.f;
                if (n)
                    for (var o, a = n(t), l = s.f, c = 0; a.length > c; )
                        l.call(t, o = a[c++]) && e.push(o);
                return e
            }
        },
        2985: function(t, e, n) {
            var i = n(3816)
              , r = n(5645)
              , s = n(7728)
              , o = n(7234)
              , a = n(741)
              , l = "prototype"
              , c = function(t, e, n) {
                var u, h, d, p, f = t & c.F, A = t & c.G, g = t & c.S, m = t & c.P, v = t & c.B, y = A ? i : g ? i[e] || (i[e] = {}) : (i[e] || {})[l], _ = A ? r : r[e] || (r[e] = {}), E = _[l] || (_[l] = {});
                for (u in A && (n = e),
                n)
                    d = ((h = !f && y && void 0 !== y[u]) ? y : n)[u],
                    p = v && h ? a(d, i) : m && "function" == typeof d ? a(Function.call, d) : d,
                    y && o(y, u, d, t & c.U),
                    _[u] != d && s(_, u, p),
                    m && E[u] != d && (E[u] = d)
            };
            i.core = r,
            c.F = 1,
            c.G = 2,
            c.S = 4,
            c.P = 8,
            c.B = 16,
            c.W = 32,
            c.U = 64,
            c.R = 128,
            t.exports = c
        },
        8852: function(t, e, n) {
            var i = n(6314)("match");
            t.exports = function(t) {
                var e = /./;
                try {
                    "/./"[t](e)
                } catch (n) {
                    try {
                        return e[i] = !1,
                        !"/./"[t](e)
                    } catch (t) {}
                }
                return !0
            }
        },
        4253: function(t) {
            t.exports = function(t) {
                try {
                    return !!t()
                } catch (t) {
                    return !0
                }
            }
        },
        8082: function(t, e, n) {
            "use strict";
            n(8269);
            var i = n(7234)
              , r = n(7728)
              , s = n(4253)
              , o = n(1355)
              , a = n(6314)
              , l = n(1165)
              , c = a("species")
              , u = !s((function() {
                var t = /./;
                return t.exec = function() {
                    var t = [];
                    return t.groups = {
                        a: "7"
                    },
                    t
                }
                ,
                "7" !== "".replace(t, "$<a>")
            }
            ))
              , h = function() {
                var t = /(?:)/
                  , e = t.exec;
                t.exec = function() {
                    return e.apply(this, arguments)
                }
                ;
                var n = "ab".split(t);
                return 2 === n.length && "a" === n[0] && "b" === n[1]
            }();
            t.exports = function(t, e, n) {
                var d = a(t)
                  , p = !s((function() {
                    var e = {};
                    return e[d] = function() {
                        return 7
                    }
                    ,
                    7 != ""[t](e)
                }
                ))
                  , f = p ? !s((function() {
                    var e = !1
                      , n = /a/;
                    return n.exec = function() {
                        return e = !0,
                        null
                    }
                    ,
                    "split" === t && (n.constructor = {},
                    n.constructor[c] = function() {
                        return n
                    }
                    ),
                    n[d](""),
                    !e
                }
                )) : void 0;
                if (!p || !f || "replace" === t && !u || "split" === t && !h) {
                    var A = /./[d]
                      , g = n(o, d, ""[t], (function(t, e, n, i, r) {
                        return e.exec === l ? p && !r ? {
                            done: !0,
                            value: A.call(e, n, i)
                        } : {
                            done: !0,
                            value: t.call(n, e, i)
                        } : {
                            done: !1
                        }
                    }
                    ))
                      , m = g[0]
                      , v = g[1];
                    i(String.prototype, t, m),
                    r(RegExp.prototype, d, 2 == e ? function(t, e) {
                        return v.call(t, this, e)
                    }
                    : function(t) {
                        return v.call(t, this)
                    }
                    )
                }
            }
        },
        3218: function(t, e, n) {
            "use strict";
            var i = n(7007);
            t.exports = function() {
                var t = i(this)
                  , e = "";
                return t.global && (e += "g"),
                t.ignoreCase && (e += "i"),
                t.multiline && (e += "m"),
                t.unicode && (e += "u"),
                t.sticky && (e += "y"),
                e
            }
        },
        3325: function(t, e, n) {
            "use strict";
            var i = n(4302)
              , r = n(5286)
              , s = n(875)
              , o = n(741)
              , a = n(6314)("isConcatSpreadable");
            t.exports = function t(e, n, l, c, u, h, d, p) {
                for (var f, A, g = u, m = 0, v = !!d && o(d, p, 3); m < c; ) {
                    if (m in l) {
                        if (f = v ? v(l[m], m, n) : l[m],
                        A = !1,
                        r(f) && (A = void 0 !== (A = f[a]) ? !!A : i(f)),
                        A && h > 0)
                            g = t(e, n, f, s(f.length), g, h - 1) - 1;
                        else {
                            if (g >= 9007199254740991)
                                throw TypeError();
                            e[g] = f
                        }
                        g++
                    }
                    m++
                }
                return g
            }
        },
        3531: function(t, e, n) {
            var i = n(741)
              , r = n(8851)
              , s = n(6555)
              , o = n(7007)
              , a = n(875)
              , l = n(9002)
              , c = {}
              , u = {}
              , h = t.exports = function(t, e, n, h, d) {
                var p, f, A, g, m = d ? function() {
                    return t
                }
                : l(t), v = i(n, h, e ? 2 : 1), y = 0;
                if ("function" != typeof m)
                    throw TypeError(t + " is not iterable!");
                if (s(m)) {
                    for (p = a(t.length); p > y; y++)
                        if ((g = e ? v(o(f = t[y])[0], f[1]) : v(t[y])) === c || g === u)
                            return g
                } else
                    for (A = m.call(t); !(f = A.next()).done; )
                        if ((g = r(A, v, f.value, e)) === c || g === u)
                            return g
            }
            ;
            h.BREAK = c,
            h.RETURN = u
        },
        18: function(t, e, n) {
            t.exports = n(3825)("native-function-to-string", Function.toString)
        },
        3816: function(t) {
            var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
            "number" == typeof __g && (__g = e)
        },
        9181: function(t) {
            var e = {}.hasOwnProperty;
            t.exports = function(t, n) {
                return e.call(t, n)
            }
        },
        7728: function(t, e, n) {
            var i = n(9275)
              , r = n(681);
            t.exports = n(7057) ? function(t, e, n) {
                return i.f(t, e, r(1, n))
            }
            : function(t, e, n) {
                return t[e] = n,
                t
            }
        },
        639: function(t, e, n) {
            var i = n(3816).document;
            t.exports = i && i.documentElement
        },
        1734: function(t, e, n) {
            t.exports = !n(7057) && !n(4253)((function() {
                return 7 != Object.defineProperty(n(2457)("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a
            }
            ))
        },
        266: function(t, e, n) {
            var i = n(5286)
              , r = n(7375).set;
            t.exports = function(t, e, n) {
                var s, o = e.constructor;
                return o !== n && "function" == typeof o && (s = o.prototype) !== n.prototype && i(s) && r && r(t, s),
                t
            }
        },
        7242: function(t) {
            t.exports = function(t, e, n) {
                var i = void 0 === n;
                switch (e.length) {
                case 0:
                    return i ? t() : t.call(n);
                case 1:
                    return i ? t(e[0]) : t.call(n, e[0]);
                case 2:
                    return i ? t(e[0], e[1]) : t.call(n, e[0], e[1]);
                case 3:
                    return i ? t(e[0], e[1], e[2]) : t.call(n, e[0], e[1], e[2]);
                case 4:
                    return i ? t(e[0], e[1], e[2], e[3]) : t.call(n, e[0], e[1], e[2], e[3])
                }
                return t.apply(n, e)
            }
        },
        9797: function(t, e, n) {
            var i = n(2032);
            t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
                return "String" == i(t) ? t.split("") : Object(t)
            }
        },
        6555: function(t, e, n) {
            var i = n(2803)
              , r = n(6314)("iterator")
              , s = Array.prototype;
            t.exports = function(t) {
                return void 0 !== t && (i.Array === t || s[r] === t)
            }
        },
        4302: function(t, e, n) {
            var i = n(2032);
            t.exports = Array.isArray || function(t) {
                return "Array" == i(t)
            }
        },
        8367: function(t, e, n) {
            var i = n(5286)
              , r = Math.floor;
            t.exports = function(t) {
                return !i(t) && isFinite(t) && r(t) === t
            }
        },
        5286: function(t) {
            t.exports = function(t) {
                return "object" == typeof t ? null !== t : "function" == typeof t
            }
        },
        5364: function(t, e, n) {
            var i = n(5286)
              , r = n(2032)
              , s = n(6314)("match");
            t.exports = function(t) {
                var e;
                return i(t) && (void 0 !== (e = t[s]) ? !!e : "RegExp" == r(t))
            }
        },
        8851: function(t, e, n) {
            var i = n(7007);
            t.exports = function(t, e, n, r) {
                try {
                    return r ? e(i(n)[0], n[1]) : e(n)
                } catch (e) {
                    var s = t.return;
                    throw void 0 !== s && i(s.call(t)),
                    e
                }
            }
        },
        9988: function(t, e, n) {
            "use strict";
            var i = n(2503)
              , r = n(681)
              , s = n(2943)
              , o = {};
            n(7728)(o, n(6314)("iterator"), (function() {
                return this
            }
            )),
            t.exports = function(t, e, n) {
                t.prototype = i(o, {
                    next: r(1, n)
                }),
                s(t, e + " Iterator")
            }
        },
        2923: function(t, e, n) {
            "use strict";
            var i = n(4461)
              , r = n(2985)
              , s = n(7234)
              , o = n(7728)
              , a = n(2803)
              , l = n(9988)
              , c = n(2943)
              , u = n(468)
              , h = n(6314)("iterator")
              , d = !([].keys && "next"in [].keys())
              , p = "keys"
              , f = "values"
              , A = function() {
                return this
            };
            t.exports = function(t, e, n, g, m, v, y) {
                l(n, e, g);
                var _, E, b, x = function(t) {
                    if (!d && t in M)
                        return M[t];
                    switch (t) {
                    case p:
                    case f:
                        return function() {
                            return new n(this,t)
                        }
                    }
                    return function() {
                        return new n(this,t)
                    }
                }, w = e + " Iterator", S = m == f, C = !1, M = t.prototype, I = M[h] || M["@@iterator"] || m && M[m], T = I || x(m), B = m ? S ? x("entries") : T : void 0, R = "Array" == e && M.entries || I;
                if (R && (b = u(R.call(new t))) !== Object.prototype && b.next && (c(b, w, !0),
                i || "function" == typeof b[h] || o(b, h, A)),
                S && I && I.name !== f && (C = !0,
                T = function() {
                    return I.call(this)
                }
                ),
                i && !y || !d && !C && M[h] || o(M, h, T),
                a[e] = T,
                a[w] = A,
                m)
                    if (_ = {
                        values: S ? T : x(f),
                        keys: v ? T : x(p),
                        entries: B
                    },
                    y)
                        for (E in _)
                            E in M || s(M, E, _[E]);
                    else
                        r(r.P + r.F * (d || C), e, _);
                return _
            }
        },
        7462: function(t, e, n) {
            var i = n(6314)("iterator")
              , r = !1;
            try {
                var s = [7][i]();
                s.return = function() {
                    r = !0
                }
                ,
                Array.from(s, (function() {
                    throw 2
                }
                ))
            } catch (t) {}
            t.exports = function(t, e) {
                if (!e && !r)
                    return !1;
                var n = !1;
                try {
                    var s = [7]
                      , o = s[i]();
                    o.next = function() {
                        return {
                            done: n = !0
                        }
                    }
                    ,
                    s[i] = function() {
                        return o
                    }
                    ,
                    t(s)
                } catch (t) {}
                return n
            }
        },
        5436: function(t) {
            t.exports = function(t, e) {
                return {
                    value: e,
                    done: !!t
                }
            }
        },
        2803: function(t) {
            t.exports = {}
        },
        4461: function(t) {
            t.exports = !1
        },
        3086: function(t) {
            var e = Math.expm1;
            t.exports = !e || e(10) > 22025.465794806718 || e(10) < 22025.465794806718 || -2e-17 != e(-2e-17) ? function(t) {
                return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1
            }
            : e
        },
        4934: function(t, e, n) {
            var i = n(1801)
              , r = Math.pow
              , s = r(2, -52)
              , o = r(2, -23)
              , a = r(2, 127) * (2 - o)
              , l = r(2, -126);
            t.exports = Math.fround || function(t) {
                var e, n, r = Math.abs(t), c = i(t);
                return r < l ? c * (r / l / o + 1 / s - 1 / s) * l * o : (n = (e = (1 + o / s) * r) - (e - r)) > a || n != n ? c * (1 / 0) : c * n
            }
        },
        6206: function(t) {
            t.exports = Math.log1p || function(t) {
                return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t)
            }
        },
        1801: function(t) {
            t.exports = Math.sign || function(t) {
                return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
            }
        },
        4728: function(t, e, n) {
            var i = n(3953)("meta")
              , r = n(5286)
              , s = n(9181)
              , o = n(9275).f
              , a = 0
              , l = Object.isExtensible || function() {
                return !0
            }
              , c = !n(4253)((function() {
                return l(Object.preventExtensions({}))
            }
            ))
              , u = function(t) {
                o(t, i, {
                    value: {
                        i: "O" + ++a,
                        w: {}
                    }
                })
            }
              , h = t.exports = {
                KEY: i,
                NEED: !1,
                fastKey: function(t, e) {
                    if (!r(t))
                        return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!s(t, i)) {
                        if (!l(t))
                            return "F";
                        if (!e)
                            return "E";
                        u(t)
                    }
                    return t[i].i
                },
                getWeak: function(t, e) {
                    if (!s(t, i)) {
                        if (!l(t))
                            return !0;
                        if (!e)
                            return !1;
                        u(t)
                    }
                    return t[i].w
                },
                onFreeze: function(t) {
                    return c && h.NEED && l(t) && !s(t, i) && u(t),
                    t
                }
            }
        },
        4351: function(t, e, n) {
            var i = n(3816)
              , r = n(4193).set
              , s = i.MutationObserver || i.WebKitMutationObserver
              , o = i.process
              , a = i.Promise
              , l = "process" == n(2032)(o);
            t.exports = function() {
                var t, e, n, c = function() {
                    var i, r;
                    for (l && (i = o.domain) && i.exit(); t; ) {
                        r = t.fn,
                        t = t.next;
                        try {
                            r()
                        } catch (i) {
                            throw t ? n() : e = void 0,
                            i
                        }
                    }
                    e = void 0,
                    i && i.enter()
                };
                if (l)
                    n = function() {
                        o.nextTick(c)
                    }
                    ;
                else if (!s || i.navigator && i.navigator.standalone)
                    if (a && a.resolve) {
                        var u = a.resolve(void 0);
                        n = function() {
                            u.then(c)
                        }
                    } else
                        n = function() {
                            r.call(i, c)
                        }
                        ;
                else {
                    var h = !0
                      , d = document.createTextNode("");
                    new s(c).observe(d, {
                        characterData: !0
                    }),
                    n = function() {
                        d.data = h = !h
                    }
                }
                return function(i) {
                    var r = {
                        fn: i,
                        next: void 0
                    };
                    e && (e.next = r),
                    t || (t = r,
                    n()),
                    e = r
                }
            }
        },
        3499: function(t, e, n) {
            "use strict";
            var i = n(4963);
            function r(t) {
                var e, n;
                this.promise = new t((function(t, i) {
                    if (void 0 !== e || void 0 !== n)
                        throw TypeError("Bad Promise constructor");
                    e = t,
                    n = i
                }
                )),
                this.resolve = i(e),
                this.reject = i(n)
            }
            t.exports.f = function(t) {
                return new r(t)
            }
        },
        5345: function(t, e, n) {
            "use strict";
            var i = n(7057)
              , r = n(7184)
              , s = n(4548)
              , o = n(4682)
              , a = n(508)
              , l = n(9797)
              , c = Object.assign;
            t.exports = !c || n(4253)((function() {
                var t = {}
                  , e = {}
                  , n = Symbol()
                  , i = "abcdefghijklmnopqrst";
                return t[n] = 7,
                i.split("").forEach((function(t) {
                    e[t] = t
                }
                )),
                7 != c({}, t)[n] || Object.keys(c({}, e)).join("") != i
            }
            )) ? function(t, e) {
                for (var n = a(t), c = arguments.length, u = 1, h = s.f, d = o.f; c > u; )
                    for (var p, f = l(arguments[u++]), A = h ? r(f).concat(h(f)) : r(f), g = A.length, m = 0; g > m; )
                        p = A[m++],
                        i && !d.call(f, p) || (n[p] = f[p]);
                return n
            }
            : c
        },
        2503: function(t, e, n) {
            var i = n(7007)
              , r = n(5588)
              , s = n(4430)
              , o = n(9335)("IE_PROTO")
              , a = function() {}
              , l = "prototype"
              , c = function() {
                var t, e = n(2457)("iframe"), i = s.length;
                for (e.style.display = "none",
                n(639).appendChild(e),
                e.src = "javascript:",
                (t = e.contentWindow.document).open(),
                t.write("<script>document.F=Object<\/script>"),
                t.close(),
                c = t.F; i--; )
                    delete c[l][s[i]];
                return c()
            };
            t.exports = Object.create || function(t, e) {
                var n;
                return null !== t ? (a[l] = i(t),
                n = new a,
                a[l] = null,
                n[o] = t) : n = c(),
                void 0 === e ? n : r(n, e)
            }
        },
        9275: function(t, e, n) {
            var i = n(7007)
              , r = n(1734)
              , s = n(1689)
              , o = Object.defineProperty;
            e.f = n(7057) ? Object.defineProperty : function(t, e, n) {
                if (i(t),
                e = s(e, !0),
                i(n),
                r)
                    try {
                        return o(t, e, n)
                    } catch (t) {}
                if ("get"in n || "set"in n)
                    throw TypeError("Accessors not supported!");
                return "value"in n && (t[e] = n.value),
                t
            }
        },
        5588: function(t, e, n) {
            var i = n(9275)
              , r = n(7007)
              , s = n(7184);
            t.exports = n(7057) ? Object.defineProperties : function(t, e) {
                r(t);
                for (var n, o = s(e), a = o.length, l = 0; a > l; )
                    i.f(t, n = o[l++], e[n]);
                return t
            }
        },
        8693: function(t, e, n) {
            var i = n(4682)
              , r = n(681)
              , s = n(2110)
              , o = n(1689)
              , a = n(9181)
              , l = n(1734)
              , c = Object.getOwnPropertyDescriptor;
            e.f = n(7057) ? c : function(t, e) {
                if (t = s(t),
                e = o(e, !0),
                l)
                    try {
                        return c(t, e)
                    } catch (t) {}
                if (a(t, e))
                    return r(!i.f.call(t, e), t[e])
            }
        },
        9327: function(t, e, n) {
            var i = n(2110)
              , r = n(616).f
              , s = {}.toString
              , o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            t.exports.f = function(t) {
                return o && "[object Window]" == s.call(t) ? function(t) {
                    try {
                        return r(t)
                    } catch (t) {
                        return o.slice()
                    }
                }(t) : r(i(t))
            }
        },
        616: function(t, e, n) {
            var i = n(189)
              , r = n(4430).concat("length", "prototype");
            e.f = Object.getOwnPropertyNames || function(t) {
                return i(t, r)
            }
        },
        4548: function(t, e) {
            e.f = Object.getOwnPropertySymbols
        },
        468: function(t, e, n) {
            var i = n(9181)
              , r = n(508)
              , s = n(9335)("IE_PROTO")
              , o = Object.prototype;
            t.exports = Object.getPrototypeOf || function(t) {
                return t = r(t),
                i(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? o : null
            }
        },
        189: function(t, e, n) {
            var i = n(9181)
              , r = n(2110)
              , s = n(9315)(!1)
              , o = n(9335)("IE_PROTO");
            t.exports = function(t, e) {
                var n, a = r(t), l = 0, c = [];
                for (n in a)
                    n != o && i(a, n) && c.push(n);
                for (; e.length > l; )
                    i(a, n = e[l++]) && (~s(c, n) || c.push(n));
                return c
            }
        },
        7184: function(t, e, n) {
            var i = n(189)
              , r = n(4430);
            t.exports = Object.keys || function(t) {
                return i(t, r)
            }
        },
        4682: function(t, e) {
            e.f = {}.propertyIsEnumerable
        },
        3160: function(t, e, n) {
            var i = n(2985)
              , r = n(5645)
              , s = n(4253);
            t.exports = function(t, e) {
                var n = (r.Object || {})[t] || Object[t]
                  , o = {};
                o[t] = e(n),
                i(i.S + i.F * s((function() {
                    n(1)
                }
                )), "Object", o)
            }
        },
        1131: function(t, e, n) {
            var i = n(7057)
              , r = n(7184)
              , s = n(2110)
              , o = n(4682).f;
            t.exports = function(t) {
                return function(e) {
                    for (var n, a = s(e), l = r(a), c = l.length, u = 0, h = []; c > u; )
                        n = l[u++],
                        i && !o.call(a, n) || h.push(t ? [n, a[n]] : a[n]);
                    return h
                }
            }
        },
        7643: function(t, e, n) {
            var i = n(616)
              , r = n(4548)
              , s = n(7007)
              , o = n(3816).Reflect;
            t.exports = o && o.ownKeys || function(t) {
                var e = i.f(s(t))
                  , n = r.f;
                return n ? e.concat(n(t)) : e
            }
        },
        7743: function(t, e, n) {
            var i = n(3816).parseFloat
              , r = n(9599).trim;
            t.exports = 1 / i(n(4644) + "-0") != -1 / 0 ? function(t) {
                var e = r(String(t), 3)
                  , n = i(e);
                return 0 === n && "-" == e.charAt(0) ? -0 : n
            }
            : i
        },
        5960: function(t, e, n) {
            var i = n(3816).parseInt
              , r = n(9599).trim
              , s = n(4644)
              , o = /^[-+]?0[xX]/;
            t.exports = 8 !== i(s + "08") || 22 !== i(s + "0x16") ? function(t, e) {
                var n = r(String(t), 3);
                return i(n, e >>> 0 || (o.test(n) ? 16 : 10))
            }
            : i
        },
        188: function(t) {
            t.exports = function(t) {
                try {
                    return {
                        e: !1,
                        v: t()
                    }
                } catch (t) {
                    return {
                        e: !0,
                        v: t
                    }
                }
            }
        },
        94: function(t, e, n) {
            var i = n(7007)
              , r = n(5286)
              , s = n(3499);
            t.exports = function(t, e) {
                if (i(t),
                r(e) && e.constructor === t)
                    return e;
                var n = s.f(t);
                return (0,
                n.resolve)(e),
                n.promise
            }
        },
        681: function(t) {
            t.exports = function(t, e) {
                return {
                    enumerable: !(1 & t),
                    configurable: !(2 & t),
                    writable: !(4 & t),
                    value: e
                }
            }
        },
        4408: function(t, e, n) {
            var i = n(7234);
            t.exports = function(t, e, n) {
                for (var r in e)
                    i(t, r, e[r], n);
                return t
            }
        },
        7234: function(t, e, n) {
            var i = n(3816)
              , r = n(7728)
              , s = n(9181)
              , o = n(3953)("src")
              , a = n(18)
              , l = "toString"
              , c = ("" + a).split(l);
            n(5645).inspectSource = function(t) {
                return a.call(t)
            }
            ,
            (t.exports = function(t, e, n, a) {
                var l = "function" == typeof n;
                l && (s(n, "name") || r(n, "name", e)),
                t[e] !== n && (l && (s(n, o) || r(n, o, t[e] ? "" + t[e] : c.join(String(e)))),
                t === i ? t[e] = n : a ? t[e] ? t[e] = n : r(t, e, n) : (delete t[e],
                r(t, e, n)))
            }
            )(Function.prototype, l, (function() {
                return "function" == typeof this && this[o] || a.call(this)
            }
            ))
        },
        7787: function(t, e, n) {
            "use strict";
            var i = n(1488)
              , r = RegExp.prototype.exec;
            t.exports = function(t, e) {
                var n = t.exec;
                if ("function" == typeof n) {
                    var s = n.call(t, e);
                    if ("object" != typeof s)
                        throw new TypeError("RegExp exec method returned something other than an Object or null");
                    return s
                }
                if ("RegExp" !== i(t))
                    throw new TypeError("RegExp#exec called on incompatible receiver");
                return r.call(t, e)
            }
        },
        1165: function(t, e, n) {
            "use strict";
            var i, r, s = n(3218), o = RegExp.prototype.exec, a = String.prototype.replace, l = o, c = "lastIndex", u = (i = /a/,
            r = /b*/g,
            o.call(i, "a"),
            o.call(r, "a"),
            0 !== i[c] || 0 !== r[c]), h = void 0 !== /()??/.exec("")[1];
            (u || h) && (l = function(t) {
                var e, n, i, r, l = this;
                return h && (n = new RegExp("^" + l.source + "$(?!\\s)",s.call(l))),
                u && (e = l[c]),
                i = o.call(l, t),
                u && i && (l[c] = l.global ? i.index + i[0].length : e),
                h && i && i.length > 1 && a.call(i[0], n, (function() {
                    for (r = 1; r < arguments.length - 2; r++)
                        void 0 === arguments[r] && (i[r] = void 0)
                }
                )),
                i
            }
            ),
            t.exports = l
        },
        7195: function(t) {
            t.exports = Object.is || function(t, e) {
                return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
            }
        },
        7375: function(t, e, n) {
            var i = n(5286)
              , r = n(7007)
              , s = function(t, e) {
                if (r(t),
                !i(e) && null !== e)
                    throw TypeError(e + ": can't set as prototype!")
            };
            t.exports = {
                set: Object.setPrototypeOf || ("__proto__"in {} ? function(t, e, i) {
                    try {
                        (i = n(741)(Function.call, n(8693).f(Object.prototype, "__proto__").set, 2))(t, []),
                        e = !(t instanceof Array)
                    } catch (t) {
                        e = !0
                    }
                    return function(t, n) {
                        return s(t, n),
                        e ? t.__proto__ = n : i(t, n),
                        t
                    }
                }({}, !1) : void 0),
                check: s
            }
        },
        2974: function(t, e, n) {
            "use strict";
            var i = n(3816)
              , r = n(9275)
              , s = n(7057)
              , o = n(6314)("species");
            t.exports = function(t) {
                var e = i[t];
                s && e && !e[o] && r.f(e, o, {
                    configurable: !0,
                    get: function() {
                        return this
                    }
                })
            }
        },
        2943: function(t, e, n) {
            var i = n(9275).f
              , r = n(9181)
              , s = n(6314)("toStringTag");
            t.exports = function(t, e, n) {
                t && !r(t = n ? t : t.prototype, s) && i(t, s, {
                    configurable: !0,
                    value: e
                })
            }
        },
        9335: function(t, e, n) {
            var i = n(3825)("keys")
              , r = n(3953);
            t.exports = function(t) {
                return i[t] || (i[t] = r(t))
            }
        },
        3825: function(t, e, n) {
            var i = n(5645)
              , r = n(3816)
              , s = "__core-js_shared__"
              , o = r[s] || (r[s] = {});
            (t.exports = function(t, e) {
                return o[t] || (o[t] = void 0 !== e ? e : {})
            }
            )("versions", []).push({
                version: i.version,
                mode: n(4461) ? "pure" : "global",
                copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
            })
        },
        8364: function(t, e, n) {
            var i = n(7007)
              , r = n(4963)
              , s = n(6314)("species");
            t.exports = function(t, e) {
                var n, o = i(t).constructor;
                return void 0 === o || null == (n = i(o)[s]) ? e : r(n)
            }
        },
        7717: function(t, e, n) {
            "use strict";
            var i = n(4253);
            t.exports = function(t, e) {
                return !!t && i((function() {
                    e ? t.call(null, (function() {}
                    ), 1) : t.call(null)
                }
                ))
            }
        },
        4496: function(t, e, n) {
            var i = n(1467)
              , r = n(1355);
            t.exports = function(t) {
                return function(e, n) {
                    var s, o, a = String(r(e)), l = i(n), c = a.length;
                    return l < 0 || l >= c ? t ? "" : void 0 : (s = a.charCodeAt(l)) < 55296 || s > 56319 || l + 1 === c || (o = a.charCodeAt(l + 1)) < 56320 || o > 57343 ? t ? a.charAt(l) : s : t ? a.slice(l, l + 2) : o - 56320 + (s - 55296 << 10) + 65536
                }
            }
        },
        2094: function(t, e, n) {
            var i = n(5364)
              , r = n(1355);
            t.exports = function(t, e, n) {
                if (i(e))
                    throw TypeError("String#" + n + " doesn't accept regex!");
                return String(r(t))
            }
        },
        9395: function(t, e, n) {
            var i = n(2985)
              , r = n(4253)
              , s = n(1355)
              , o = /"/g
              , a = function(t, e, n, i) {
                var r = String(s(t))
                  , a = "<" + e;
                return "" !== n && (a += " " + n + '="' + String(i).replace(o, "&quot;") + '"'),
                a + ">" + r + "</" + e + ">"
            };
            t.exports = function(t, e) {
                var n = {};
                n[t] = e(a),
                i(i.P + i.F * r((function() {
                    var e = ""[t]('"');
                    return e !== e.toLowerCase() || e.split('"').length > 3
                }
                )), "String", n)
            }
        },
        5442: function(t, e, n) {
            var i = n(875)
              , r = n(8595)
              , s = n(1355);
            t.exports = function(t, e, n, o) {
                var a = String(s(t))
                  , l = a.length
                  , c = void 0 === n ? " " : String(n)
                  , u = i(e);
                if (u <= l || "" == c)
                    return a;
                var h = u - l
                  , d = r.call(c, Math.ceil(h / c.length));
                return d.length > h && (d = d.slice(0, h)),
                o ? d + a : a + d
            }
        },
        8595: function(t, e, n) {
            "use strict";
            var i = n(1467)
              , r = n(1355);
            t.exports = function(t) {
                var e = String(r(this))
                  , n = ""
                  , s = i(t);
                if (s < 0 || s == 1 / 0)
                    throw RangeError("Count can't be negative");
                for (; s > 0; (s >>>= 1) && (e += e))
                    1 & s && (n += e);
                return n
            }
        },
        9599: function(t, e, n) {
            var i = n(2985)
              , r = n(1355)
              , s = n(4253)
              , o = n(4644)
              , a = "[" + o + "]"
              , l = RegExp("^" + a + a + "*")
              , c = RegExp(a + a + "*$")
              , u = function(t, e, n) {
                var r = {}
                  , a = s((function() {
                    return !!o[t]() || "​" != "​"[t]()
                }
                ))
                  , l = r[t] = a ? e(h) : o[t];
                n && (r[n] = l),
                i(i.P + i.F * a, "String", r)
            }
              , h = u.trim = function(t, e) {
                return t = String(r(t)),
                1 & e && (t = t.replace(l, "")),
                2 & e && (t = t.replace(c, "")),
                t
            }
            ;
            t.exports = u
        },
        4644: function(t) {
            t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
        },
        4193: function(t, e, n) {
            var i, r, s, o = n(741), a = n(7242), l = n(639), c = n(2457), u = n(3816), h = u.process, d = u.setImmediate, p = u.clearImmediate, f = u.MessageChannel, A = u.Dispatch, g = 0, m = {}, v = "onreadystatechange", y = function() {
                var t = +this;
                if (m.hasOwnProperty(t)) {
                    var e = m[t];
                    delete m[t],
                    e()
                }
            }, _ = function(t) {
                y.call(t.data)
            };
            d && p || (d = function(t) {
                for (var e = [], n = 1; arguments.length > n; )
                    e.push(arguments[n++]);
                return m[++g] = function() {
                    a("function" == typeof t ? t : Function(t), e)
                }
                ,
                i(g),
                g
            }
            ,
            p = function(t) {
                delete m[t]
            }
            ,
            "process" == n(2032)(h) ? i = function(t) {
                h.nextTick(o(y, t, 1))
            }
            : A && A.now ? i = function(t) {
                A.now(o(y, t, 1))
            }
            : f ? (s = (r = new f).port2,
            r.port1.onmessage = _,
            i = o(s.postMessage, s, 1)) : u.addEventListener && "function" == typeof postMessage && !u.importScripts ? (i = function(t) {
                u.postMessage(t + "", "*")
            }
            ,
            u.addEventListener("message", _, !1)) : i = v in c("script") ? function(t) {
                l.appendChild(c("script"))[v] = function() {
                    l.removeChild(this),
                    y.call(t)
                }
            }
            : function(t) {
                setTimeout(o(y, t, 1), 0)
            }
            ),
            t.exports = {
                set: d,
                clear: p
            }
        },
        2337: function(t, e, n) {
            var i = n(1467)
              , r = Math.max
              , s = Math.min;
            t.exports = function(t, e) {
                return (t = i(t)) < 0 ? r(t + e, 0) : s(t, e)
            }
        },
        4843: function(t, e, n) {
            var i = n(1467)
              , r = n(875);
            t.exports = function(t) {
                if (void 0 === t)
                    return 0;
                var e = i(t)
                  , n = r(e);
                if (e !== n)
                    throw RangeError("Wrong length!");
                return n
            }
        },
        1467: function(t) {
            var e = Math.ceil
              , n = Math.floor;
            t.exports = function(t) {
                return isNaN(t = +t) ? 0 : (t > 0 ? n : e)(t)
            }
        },
        2110: function(t, e, n) {
            var i = n(9797)
              , r = n(1355);
            t.exports = function(t) {
                return i(r(t))
            }
        },
        875: function(t, e, n) {
            var i = n(1467)
              , r = Math.min;
            t.exports = function(t) {
                return t > 0 ? r(i(t), 9007199254740991) : 0
            }
        },
        508: function(t, e, n) {
            var i = n(1355);
            t.exports = function(t) {
                return Object(i(t))
            }
        },
        1689: function(t, e, n) {
            var i = n(5286);
            t.exports = function(t, e) {
                if (!i(t))
                    return t;
                var n, r;
                if (e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                    return r;
                if ("function" == typeof (n = t.valueOf) && !i(r = n.call(t)))
                    return r;
                if (!e && "function" == typeof (n = t.toString) && !i(r = n.call(t)))
                    return r;
                throw TypeError("Can't convert object to primitive value")
            }
        },
        8440: function(t, e, n) {
            "use strict";
            if (n(7057)) {
                var i = n(4461)
                  , r = n(3816)
                  , s = n(4253)
                  , o = n(2985)
                  , a = n(9383)
                  , l = n(1125)
                  , c = n(741)
                  , u = n(3328)
                  , h = n(681)
                  , d = n(7728)
                  , p = n(4408)
                  , f = n(1467)
                  , A = n(875)
                  , g = n(4843)
                  , m = n(2337)
                  , v = n(1689)
                  , y = n(9181)
                  , _ = n(1488)
                  , E = n(5286)
                  , b = n(508)
                  , x = n(6555)
                  , w = n(2503)
                  , S = n(468)
                  , C = n(616).f
                  , M = n(9002)
                  , I = n(3953)
                  , T = n(6314)
                  , B = n(50)
                  , R = n(9315)
                  , L = n(8364)
                  , D = n(6997)
                  , P = n(2803)
                  , U = n(7462)
                  , O = n(2974)
                  , N = n(6852)
                  , F = n(5216)
                  , Q = n(9275)
                  , k = n(8693)
                  , G = Q.f
                  , H = k.f
                  , z = r.RangeError
                  , V = r.TypeError
                  , W = r.Uint8Array
                  , q = "ArrayBuffer"
                  , j = "Shared" + q
                  , X = "BYTES_PER_ELEMENT"
                  , Y = "prototype"
                  , K = Array[Y]
                  , J = l.ArrayBuffer
                  , $ = l.DataView
                  , Z = B(0)
                  , tt = B(2)
                  , et = B(3)
                  , nt = B(4)
                  , it = B(5)
                  , rt = B(6)
                  , st = R(!0)
                  , ot = R(!1)
                  , at = D.values
                  , lt = D.keys
                  , ct = D.entries
                  , ut = K.lastIndexOf
                  , ht = K.reduce
                  , dt = K.reduceRight
                  , pt = K.join
                  , ft = K.sort
                  , At = K.slice
                  , gt = K.toString
                  , mt = K.toLocaleString
                  , vt = T("iterator")
                  , yt = T("toStringTag")
                  , _t = I("typed_constructor")
                  , Et = I("def_constructor")
                  , bt = a.CONSTR
                  , xt = a.TYPED
                  , wt = a.VIEW
                  , St = "Wrong length!"
                  , Ct = B(1, (function(t, e) {
                    return Rt(L(t, t[Et]), e)
                }
                ))
                  , Mt = s((function() {
                    return 1 === new W(new Uint16Array([1]).buffer)[0]
                }
                ))
                  , It = !!W && !!W[Y].set && s((function() {
                    new W(1).set({})
                }
                ))
                  , Tt = function(t, e) {
                    var n = f(t);
                    if (n < 0 || n % e)
                        throw z("Wrong offset!");
                    return n
                }
                  , Bt = function(t) {
                    if (E(t) && xt in t)
                        return t;
                    throw V(t + " is not a typed array!")
                }
                  , Rt = function(t, e) {
                    if (!E(t) || !(_t in t))
                        throw V("It is not a typed array constructor!");
                    return new t(e)
                }
                  , Lt = function(t, e) {
                    return Dt(L(t, t[Et]), e)
                }
                  , Dt = function(t, e) {
                    for (var n = 0, i = e.length, r = Rt(t, i); i > n; )
                        r[n] = e[n++];
                    return r
                }
                  , Pt = function(t, e, n) {
                    G(t, e, {
                        get: function() {
                            return this._d[n]
                        }
                    })
                }
                  , Ut = function(t) {
                    var e, n, i, r, s, o, a = b(t), l = arguments.length, u = l > 1 ? arguments[1] : void 0, h = void 0 !== u, d = M(a);
                    if (null != d && !x(d)) {
                        for (o = d.call(a),
                        i = [],
                        e = 0; !(s = o.next()).done; e++)
                            i.push(s.value);
                        a = i
                    }
                    for (h && l > 2 && (u = c(u, arguments[2], 2)),
                    e = 0,
                    n = A(a.length),
                    r = Rt(this, n); n > e; e++)
                        r[e] = h ? u(a[e], e) : a[e];
                    return r
                }
                  , Ot = function() {
                    for (var t = 0, e = arguments.length, n = Rt(this, e); e > t; )
                        n[t] = arguments[t++];
                    return n
                }
                  , Nt = !!W && s((function() {
                    mt.call(new W(1))
                }
                ))
                  , Ft = function() {
                    return mt.apply(Nt ? At.call(Bt(this)) : Bt(this), arguments)
                }
                  , Qt = {
                    copyWithin: function(t, e) {
                        return F.call(Bt(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    every: function(t) {
                        return nt(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    fill: function(t) {
                        return N.apply(Bt(this), arguments)
                    },
                    filter: function(t) {
                        return Lt(this, tt(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0))
                    },
                    find: function(t) {
                        return it(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    findIndex: function(t) {
                        return rt(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    forEach: function(t) {
                        Z(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    indexOf: function(t) {
                        return ot(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    includes: function(t) {
                        return st(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    join: function(t) {
                        return pt.apply(Bt(this), arguments)
                    },
                    lastIndexOf: function(t) {
                        return ut.apply(Bt(this), arguments)
                    },
                    map: function(t) {
                        return Ct(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    reduce: function(t) {
                        return ht.apply(Bt(this), arguments)
                    },
                    reduceRight: function(t) {
                        return dt.apply(Bt(this), arguments)
                    },
                    reverse: function() {
                        for (var t, e = this, n = Bt(e).length, i = Math.floor(n / 2), r = 0; r < i; )
                            t = e[r],
                            e[r++] = e[--n],
                            e[n] = t;
                        return e
                    },
                    some: function(t) {
                        return et(Bt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    sort: function(t) {
                        return ft.call(Bt(this), t)
                    },
                    subarray: function(t, e) {
                        var n = Bt(this)
                          , i = n.length
                          , r = m(t, i);
                        return new (L(n, n[Et]))(n.buffer,n.byteOffset + r * n.BYTES_PER_ELEMENT,A((void 0 === e ? i : m(e, i)) - r))
                    }
                }
                  , kt = function(t, e) {
                    return Lt(this, At.call(Bt(this), t, e))
                }
                  , Gt = function(t) {
                    Bt(this);
                    var e = Tt(arguments[1], 1)
                      , n = this.length
                      , i = b(t)
                      , r = A(i.length)
                      , s = 0;
                    if (r + e > n)
                        throw z(St);
                    for (; s < r; )
                        this[e + s] = i[s++]
                }
                  , Ht = {
                    entries: function() {
                        return ct.call(Bt(this))
                    },
                    keys: function() {
                        return lt.call(Bt(this))
                    },
                    values: function() {
                        return at.call(Bt(this))
                    }
                }
                  , zt = function(t, e) {
                    return E(t) && t[xt] && "symbol" != typeof e && e in t && String(+e) == String(e)
                }
                  , Vt = function(t, e) {
                    return zt(t, e = v(e, !0)) ? h(2, t[e]) : H(t, e)
                }
                  , Wt = function(t, e, n) {
                    return !(zt(t, e = v(e, !0)) && E(n) && y(n, "value")) || y(n, "get") || y(n, "set") || n.configurable || y(n, "writable") && !n.writable || y(n, "enumerable") && !n.enumerable ? G(t, e, n) : (t[e] = n.value,
                    t)
                };
                bt || (k.f = Vt,
                Q.f = Wt),
                o(o.S + o.F * !bt, "Object", {
                    getOwnPropertyDescriptor: Vt,
                    defineProperty: Wt
                }),
                s((function() {
                    gt.call({})
                }
                )) && (gt = mt = function() {
                    return pt.call(this)
                }
                );
                var qt = p({}, Qt);
                p(qt, Ht),
                d(qt, vt, Ht.values),
                p(qt, {
                    slice: kt,
                    set: Gt,
                    constructor: function() {},
                    toString: gt,
                    toLocaleString: Ft
                }),
                Pt(qt, "buffer", "b"),
                Pt(qt, "byteOffset", "o"),
                Pt(qt, "byteLength", "l"),
                Pt(qt, "length", "e"),
                G(qt, yt, {
                    get: function() {
                        return this[xt]
                    }
                }),
                t.exports = function(t, e, n, l) {
                    var c = t + ((l = !!l) ? "Clamped" : "") + "Array"
                      , h = "get" + t
                      , p = "set" + t
                      , f = r[c]
                      , m = f || {}
                      , v = f && S(f)
                      , y = !f || !a.ABV
                      , b = {}
                      , x = f && f[Y]
                      , M = function(t, n) {
                        G(t, n, {
                            get: function() {
                                return function(t, n) {
                                    var i = t._d;
                                    return i.v[h](n * e + i.o, Mt)
                                }(this, n)
                            },
                            set: function(t) {
                                return function(t, n, i) {
                                    var r = t._d;
                                    l && (i = (i = Math.round(i)) < 0 ? 0 : i > 255 ? 255 : 255 & i),
                                    r.v[p](n * e + r.o, i, Mt)
                                }(this, n, t)
                            },
                            enumerable: !0
                        })
                    };
                    y ? (f = n((function(t, n, i, r) {
                        u(t, f, c, "_d");
                        var s, o, a, l, h = 0, p = 0;
                        if (E(n)) {
                            if (!(n instanceof J || (l = _(n)) == q || l == j))
                                return xt in n ? Dt(f, n) : Ut.call(f, n);
                            s = n,
                            p = Tt(i, e);
                            var m = n.byteLength;
                            if (void 0 === r) {
                                if (m % e)
                                    throw z(St);
                                if ((o = m - p) < 0)
                                    throw z(St)
                            } else if ((o = A(r) * e) + p > m)
                                throw z(St);
                            a = o / e
                        } else
                            a = g(n),
                            s = new J(o = a * e);
                        for (d(t, "_d", {
                            b: s,
                            o: p,
                            l: o,
                            e: a,
                            v: new $(s)
                        }); h < a; )
                            M(t, h++)
                    }
                    )),
                    x = f[Y] = w(qt),
                    d(x, "constructor", f)) : s((function() {
                        f(1)
                    }
                    )) && s((function() {
                        new f(-1)
                    }
                    )) && U((function(t) {
                        new f,
                        new f(null),
                        new f(1.5),
                        new f(t)
                    }
                    ), !0) || (f = n((function(t, n, i, r) {
                        var s;
                        return u(t, f, c),
                        E(n) ? n instanceof J || (s = _(n)) == q || s == j ? void 0 !== r ? new m(n,Tt(i, e),r) : void 0 !== i ? new m(n,Tt(i, e)) : new m(n) : xt in n ? Dt(f, n) : Ut.call(f, n) : new m(g(n))
                    }
                    )),
                    Z(v !== Function.prototype ? C(m).concat(C(v)) : C(m), (function(t) {
                        t in f || d(f, t, m[t])
                    }
                    )),
                    f[Y] = x,
                    i || (x.constructor = f));
                    var I = x[vt]
                      , T = !!I && ("values" == I.name || null == I.name)
                      , B = Ht.values;
                    d(f, _t, !0),
                    d(x, xt, c),
                    d(x, wt, !0),
                    d(x, Et, f),
                    (l ? new f(1)[yt] == c : yt in x) || G(x, yt, {
                        get: function() {
                            return c
                        }
                    }),
                    b[c] = f,
                    o(o.G + o.W + o.F * (f != m), b),
                    o(o.S, c, {
                        BYTES_PER_ELEMENT: e
                    }),
                    o(o.S + o.F * s((function() {
                        m.of.call(f, 1)
                    }
                    )), c, {
                        from: Ut,
                        of: Ot
                    }),
                    X in x || d(x, X, e),
                    o(o.P, c, Qt),
                    O(c),
                    o(o.P + o.F * It, c, {
                        set: Gt
                    }),
                    o(o.P + o.F * !T, c, Ht),
                    i || x.toString == gt || (x.toString = gt),
                    o(o.P + o.F * s((function() {
                        new f(1).slice()
                    }
                    )), c, {
                        slice: kt
                    }),
                    o(o.P + o.F * (s((function() {
                        return [1, 2].toLocaleString() != new f([1, 2]).toLocaleString()
                    }
                    )) || !s((function() {
                        x.toLocaleString.call([1, 2])
                    }
                    ))), c, {
                        toLocaleString: Ft
                    }),
                    P[c] = T ? I : B,
                    i || T || d(x, vt, B)
                }
            } else
                t.exports = function() {}
        },
        1125: function(t, e, n) {
            "use strict";
            var i = n(3816)
              , r = n(7057)
              , s = n(4461)
              , o = n(9383)
              , a = n(7728)
              , l = n(4408)
              , c = n(4253)
              , u = n(3328)
              , h = n(1467)
              , d = n(875)
              , p = n(4843)
              , f = n(616).f
              , A = n(9275).f
              , g = n(6852)
              , m = n(2943)
              , v = "ArrayBuffer"
              , y = "DataView"
              , _ = "prototype"
              , E = "Wrong index!"
              , b = i[v]
              , x = i[y]
              , w = i.Math
              , S = i.RangeError
              , C = i.Infinity
              , M = b
              , I = w.abs
              , T = w.pow
              , B = w.floor
              , R = w.log
              , L = w.LN2
              , D = "buffer"
              , P = "byteLength"
              , U = "byteOffset"
              , O = r ? "_b" : D
              , N = r ? "_l" : P
              , F = r ? "_o" : U;
            function Q(t, e, n) {
                var i, r, s, o = new Array(n), a = 8 * n - e - 1, l = (1 << a) - 1, c = l >> 1, u = 23 === e ? T(2, -24) - T(2, -77) : 0, h = 0, d = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for ((t = I(t)) != t || t === C ? (r = t != t ? 1 : 0,
                i = l) : (i = B(R(t) / L),
                t * (s = T(2, -i)) < 1 && (i--,
                s *= 2),
                (t += i + c >= 1 ? u / s : u * T(2, 1 - c)) * s >= 2 && (i++,
                s /= 2),
                i + c >= l ? (r = 0,
                i = l) : i + c >= 1 ? (r = (t * s - 1) * T(2, e),
                i += c) : (r = t * T(2, c - 1) * T(2, e),
                i = 0)); e >= 8; o[h++] = 255 & r,
                r /= 256,
                e -= 8)
                    ;
                for (i = i << e | r,
                a += e; a > 0; o[h++] = 255 & i,
                i /= 256,
                a -= 8)
                    ;
                return o[--h] |= 128 * d,
                o
            }
            function k(t, e, n) {
                var i, r = 8 * n - e - 1, s = (1 << r) - 1, o = s >> 1, a = r - 7, l = n - 1, c = t[l--], u = 127 & c;
                for (c >>= 7; a > 0; u = 256 * u + t[l],
                l--,
                a -= 8)
                    ;
                for (i = u & (1 << -a) - 1,
                u >>= -a,
                a += e; a > 0; i = 256 * i + t[l],
                l--,
                a -= 8)
                    ;
                if (0 === u)
                    u = 1 - o;
                else {
                    if (u === s)
                        return i ? NaN : c ? -C : C;
                    i += T(2, e),
                    u -= o
                }
                return (c ? -1 : 1) * i * T(2, u - e)
            }
            function G(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
            }
            function H(t) {
                return [255 & t]
            }
            function z(t) {
                return [255 & t, t >> 8 & 255]
            }
            function V(t) {
                return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
            }
            function W(t) {
                return Q(t, 52, 8)
            }
            function q(t) {
                return Q(t, 23, 4)
            }
            function j(t, e, n) {
                A(t[_], e, {
                    get: function() {
                        return this[n]
                    }
                })
            }
            function X(t, e, n, i) {
                var r = p(+n);
                if (r + e > t[N])
                    throw S(E);
                var s = t[O]._b
                  , o = r + t[F]
                  , a = s.slice(o, o + e);
                return i ? a : a.reverse()
            }
            function Y(t, e, n, i, r, s) {
                var o = p(+n);
                if (o + e > t[N])
                    throw S(E);
                for (var a = t[O]._b, l = o + t[F], c = i(+r), u = 0; u < e; u++)
                    a[l + u] = c[s ? u : e - u - 1]
            }
            if (o.ABV) {
                if (!c((function() {
                    b(1)
                }
                )) || !c((function() {
                    new b(-1)
                }
                )) || c((function() {
                    return new b,
                    new b(1.5),
                    new b(NaN),
                    b.name != v
                }
                ))) {
                    for (var K, J = (b = function(t) {
                        return u(this, b),
                        new M(p(t))
                    }
                    )[_] = M[_], $ = f(M), Z = 0; $.length > Z; )
                        (K = $[Z++])in b || a(b, K, M[K]);
                    s || (J.constructor = b)
                }
                var tt = new x(new b(2))
                  , et = x[_].setInt8;
                tt.setInt8(0, 2147483648),
                tt.setInt8(1, 2147483649),
                !tt.getInt8(0) && tt.getInt8(1) || l(x[_], {
                    setInt8: function(t, e) {
                        et.call(this, t, e << 24 >> 24)
                    },
                    setUint8: function(t, e) {
                        et.call(this, t, e << 24 >> 24)
                    }
                }, !0)
            } else
                b = function(t) {
                    u(this, b, v);
                    var e = p(t);
                    this._b = g.call(new Array(e), 0),
                    this[N] = e
                }
                ,
                x = function(t, e, n) {
                    u(this, x, y),
                    u(t, b, y);
                    var i = t[N]
                      , r = h(e);
                    if (r < 0 || r > i)
                        throw S("Wrong offset!");
                    if (r + (n = void 0 === n ? i - r : d(n)) > i)
                        throw S("Wrong length!");
                    this[O] = t,
                    this[F] = r,
                    this[N] = n
                }
                ,
                r && (j(b, P, "_l"),
                j(x, D, "_b"),
                j(x, P, "_l"),
                j(x, U, "_o")),
                l(x[_], {
                    getInt8: function(t) {
                        return X(this, 1, t)[0] << 24 >> 24
                    },
                    getUint8: function(t) {
                        return X(this, 1, t)[0]
                    },
                    getInt16: function(t) {
                        var e = X(this, 2, t, arguments[1]);
                        return (e[1] << 8 | e[0]) << 16 >> 16
                    },
                    getUint16: function(t) {
                        var e = X(this, 2, t, arguments[1]);
                        return e[1] << 8 | e[0]
                    },
                    getInt32: function(t) {
                        return G(X(this, 4, t, arguments[1]))
                    },
                    getUint32: function(t) {
                        return G(X(this, 4, t, arguments[1])) >>> 0
                    },
                    getFloat32: function(t) {
                        return k(X(this, 4, t, arguments[1]), 23, 4)
                    },
                    getFloat64: function(t) {
                        return k(X(this, 8, t, arguments[1]), 52, 8)
                    },
                    setInt8: function(t, e) {
                        Y(this, 1, t, H, e)
                    },
                    setUint8: function(t, e) {
                        Y(this, 1, t, H, e)
                    },
                    setInt16: function(t, e) {
                        Y(this, 2, t, z, e, arguments[2])
                    },
                    setUint16: function(t, e) {
                        Y(this, 2, t, z, e, arguments[2])
                    },
                    setInt32: function(t, e) {
                        Y(this, 4, t, V, e, arguments[2])
                    },
                    setUint32: function(t, e) {
                        Y(this, 4, t, V, e, arguments[2])
                    },
                    setFloat32: function(t, e) {
                        Y(this, 4, t, q, e, arguments[2])
                    },
                    setFloat64: function(t, e) {
                        Y(this, 8, t, W, e, arguments[2])
                    }
                });
            m(b, v),
            m(x, y),
            a(x[_], o.VIEW, !0),
            e[v] = b,
            e[y] = x
        },
        9383: function(t, e, n) {
            for (var i, r = n(3816), s = n(7728), o = n(3953), a = o("typed_array"), l = o("view"), c = !(!r.ArrayBuffer || !r.DataView), u = c, h = 0, d = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); h < 9; )
                (i = r[d[h++]]) ? (s(i.prototype, a, !0),
                s(i.prototype, l, !0)) : u = !1;
            t.exports = {
                ABV: c,
                CONSTR: u,
                TYPED: a,
                VIEW: l
            }
        },
        3953: function(t) {
            var e = 0
              , n = Math.random();
            t.exports = function(t) {
                return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + n).toString(36))
            }
        },
        575: function(t, e, n) {
            var i = n(3816).navigator;
            t.exports = i && i.userAgent || ""
        },
        1616: function(t, e, n) {
            var i = n(5286);
            t.exports = function(t, e) {
                if (!i(t) || t._t !== e)
                    throw TypeError("Incompatible receiver, " + e + " required!");
                return t
            }
        },
        6074: function(t, e, n) {
            var i = n(3816)
              , r = n(5645)
              , s = n(4461)
              , o = n(8787)
              , a = n(9275).f;
            t.exports = function(t) {
                var e = r.Symbol || (r.Symbol = s ? {} : i.Symbol || {});
                "_" == t.charAt(0) || t in e || a(e, t, {
                    value: o.f(t)
                })
            }
        },
        8787: function(t, e, n) {
            e.f = n(6314)
        },
        6314: function(t, e, n) {
            var i = n(3825)("wks")
              , r = n(3953)
              , s = n(3816).Symbol
              , o = "function" == typeof s;
            (t.exports = function(t) {
                return i[t] || (i[t] = o && s[t] || (o ? s : r)("Symbol." + t))
            }
            ).store = i
        },
        9002: function(t, e, n) {
            var i = n(1488)
              , r = n(6314)("iterator")
              , s = n(2803);
            t.exports = n(5645).getIteratorMethod = function(t) {
                if (null != t)
                    return t[r] || t["@@iterator"] || s[i(t)]
            }
        },
        2e3: function(t, e, n) {
            var i = n(2985);
            i(i.P, "Array", {
                copyWithin: n(5216)
            }),
            n(7722)("copyWithin")
        },
        5745: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(4);
            i(i.P + i.F * !n(7717)([].every, !0), "Array", {
                every: function(t) {
                    return r(this, t, arguments[1])
                }
            })
        },
        8977: function(t, e, n) {
            var i = n(2985);
            i(i.P, "Array", {
                fill: n(6852)
            }),
            n(7722)("fill")
        },
        8837: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(2);
            i(i.P + i.F * !n(7717)([].filter, !0), "Array", {
                filter: function(t) {
                    return r(this, t, arguments[1])
                }
            })
        },
        4899: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(6)
              , s = "findIndex"
              , o = !0;
            s in [] && Array(1)[s]((function() {
                o = !1
            }
            )),
            i(i.P + i.F * o, "Array", {
                findIndex: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }),
            n(7722)(s)
        },
        2310: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(5)
              , s = "find"
              , o = !0;
            s in [] && Array(1)[s]((function() {
                o = !1
            }
            )),
            i(i.P + i.F * o, "Array", {
                find: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }),
            n(7722)(s)
        },
        4336: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(0)
              , s = n(7717)([].forEach, !0);
            i(i.P + i.F * !s, "Array", {
                forEach: function(t) {
                    return r(this, t, arguments[1])
                }
            })
        },
        522: function(t, e, n) {
            "use strict";
            var i = n(741)
              , r = n(2985)
              , s = n(508)
              , o = n(8851)
              , a = n(6555)
              , l = n(875)
              , c = n(2811)
              , u = n(9002);
            r(r.S + r.F * !n(7462)((function(t) {
                Array.from(t)
            }
            )), "Array", {
                from: function(t) {
                    var e, n, r, h, d = s(t), p = "function" == typeof this ? this : Array, f = arguments.length, A = f > 1 ? arguments[1] : void 0, g = void 0 !== A, m = 0, v = u(d);
                    if (g && (A = i(A, f > 2 ? arguments[2] : void 0, 2)),
                    null == v || p == Array && a(v))
                        for (n = new p(e = l(d.length)); e > m; m++)
                            c(n, m, g ? A(d[m], m) : d[m]);
                    else
                        for (h = v.call(d),
                        n = new p; !(r = h.next()).done; m++)
                            c(n, m, g ? o(h, A, [r.value, m], !0) : r.value);
                    return n.length = m,
                    n
                }
            })
        },
        3369: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(9315)(!1)
              , s = [].indexOf
              , o = !!s && 1 / [1].indexOf(1, -0) < 0;
            i(i.P + i.F * (o || !n(7717)(s)), "Array", {
                indexOf: function(t) {
                    return o ? s.apply(this, arguments) || 0 : r(this, t, arguments[1])
                }
            })
        },
        774: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Array", {
                isArray: n(4302)
            })
        },
        6997: function(t, e, n) {
            "use strict";
            var i = n(7722)
              , r = n(5436)
              , s = n(2803)
              , o = n(2110);
            t.exports = n(2923)(Array, "Array", (function(t, e) {
                this._t = o(t),
                this._i = 0,
                this._k = e
            }
            ), (function() {
                var t = this._t
                  , e = this._k
                  , n = this._i++;
                return !t || n >= t.length ? (this._t = void 0,
                r(1)) : r(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]])
            }
            ), "values"),
            s.Arguments = s.Array,
            i("keys"),
            i("values"),
            i("entries")
        },
        7842: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(2110)
              , s = [].join;
            i(i.P + i.F * (n(9797) != Object || !n(7717)(s)), "Array", {
                join: function(t) {
                    return s.call(r(this), void 0 === t ? "," : t)
                }
            })
        },
        9564: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(2110)
              , s = n(1467)
              , o = n(875)
              , a = [].lastIndexOf
              , l = !!a && 1 / [1].lastIndexOf(1, -0) < 0;
            i(i.P + i.F * (l || !n(7717)(a)), "Array", {
                lastIndexOf: function(t) {
                    if (l)
                        return a.apply(this, arguments) || 0;
                    var e = r(this)
                      , n = o(e.length)
                      , i = n - 1;
                    for (arguments.length > 1 && (i = Math.min(i, s(arguments[1]))),
                    i < 0 && (i = n + i); i >= 0; i--)
                        if (i in e && e[i] === t)
                            return i || 0;
                    return -1
                }
            })
        },
        1802: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(1);
            i(i.P + i.F * !n(7717)([].map, !0), "Array", {
                map: function(t) {
                    return r(this, t, arguments[1])
                }
            })
        },
        8295: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(2811);
            i(i.S + i.F * n(4253)((function() {
                function t() {}
                return !(Array.of.call(t)instanceof t)
            }
            )), "Array", {
                of: function() {
                    for (var t = 0, e = arguments.length, n = new ("function" == typeof this ? this : Array)(e); e > t; )
                        r(n, t, arguments[t++]);
                    return n.length = e,
                    n
                }
            })
        },
        3750: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(7628);
            i(i.P + i.F * !n(7717)([].reduceRight, !0), "Array", {
                reduceRight: function(t) {
                    return r(this, t, arguments.length, arguments[1], !0)
                }
            })
        },
        3057: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(7628);
            i(i.P + i.F * !n(7717)([].reduce, !0), "Array", {
                reduce: function(t) {
                    return r(this, t, arguments.length, arguments[1], !1)
                }
            })
        },
        110: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(639)
              , s = n(2032)
              , o = n(2337)
              , a = n(875)
              , l = [].slice;
            i(i.P + i.F * n(4253)((function() {
                r && l.call(r)
            }
            )), "Array", {
                slice: function(t, e) {
                    var n = a(this.length)
                      , i = s(this);
                    if (e = void 0 === e ? n : e,
                    "Array" == i)
                        return l.call(this, t, e);
                    for (var r = o(t, n), c = o(e, n), u = a(c - r), h = new Array(u), d = 0; d < u; d++)
                        h[d] = "String" == i ? this.charAt(r + d) : this[r + d];
                    return h
                }
            })
        },
        6773: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(50)(3);
            i(i.P + i.F * !n(7717)([].some, !0), "Array", {
                some: function(t) {
                    return r(this, t, arguments[1])
                }
            })
        },
        75: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(4963)
              , s = n(508)
              , o = n(4253)
              , a = [].sort
              , l = [1, 2, 3];
            i(i.P + i.F * (o((function() {
                l.sort(void 0)
            }
            )) || !o((function() {
                l.sort(null)
            }
            )) || !n(7717)(a)), "Array", {
                sort: function(t) {
                    return void 0 === t ? a.call(s(this)) : a.call(s(this), r(t))
                }
            })
        },
        1842: function(t, e, n) {
            n(2974)("Array")
        },
        1822: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Date", {
                now: function() {
                    return (new Date).getTime()
                }
            })
        },
        1031: function(t, e, n) {
            var i = n(2985)
              , r = n(3537);
            i(i.P + i.F * (Date.prototype.toISOString !== r), "Date", {
                toISOString: r
            })
        },
        9977: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(508)
              , s = n(1689);
            i(i.P + i.F * n(4253)((function() {
                return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                    toISOString: function() {
                        return 1
                    }
                })
            }
            )), "Date", {
                toJSON: function(t) {
                    var e = r(this)
                      , n = s(e);
                    return "number" != typeof n || isFinite(n) ? e.toISOString() : null
                }
            })
        },
        1560: function(t, e, n) {
            var i = n(6314)("toPrimitive")
              , r = Date.prototype;
            i in r || n(7728)(r, i, n(870))
        },
        6331: function(t, e, n) {
            var i = Date.prototype
              , r = "Invalid Date"
              , s = "toString"
              , o = i[s]
              , a = i.getTime;
            new Date(NaN) + "" != r && n(7234)(i, s, (function() {
                var t = a.call(this);
                return t == t ? o.call(this) : r
            }
            ))
        },
        9730: function(t, e, n) {
            var i = n(2985);
            i(i.P, "Function", {
                bind: n(4398)
            })
        },
        8377: function(t, e, n) {
            "use strict";
            var i = n(5286)
              , r = n(468)
              , s = n(6314)("hasInstance")
              , o = Function.prototype;
            s in o || n(9275).f(o, s, {
                value: function(t) {
                    if ("function" != typeof this || !i(t))
                        return !1;
                    if (!i(this.prototype))
                        return t instanceof this;
                    for (; t = r(t); )
                        if (this.prototype === t)
                            return !0;
                    return !1
                }
            })
        },
        6059: function(t, e, n) {
            var i = n(9275).f
              , r = Function.prototype
              , s = /^\s*function ([^ (]*)/
              , o = "name";
            o in r || n(7057) && i(r, o, {
                configurable: !0,
                get: function() {
                    try {
                        return ("" + this).match(s)[1]
                    } catch (t) {
                        return ""
                    }
                }
            })
        },
        8416: function(t, e, n) {
            "use strict";
            var i = n(9824)
              , r = n(1616)
              , s = "Map";
            t.exports = n(5795)(s, (function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            }
            ), {
                get: function(t) {
                    var e = i.getEntry(r(this, s), t);
                    return e && e.v
                },
                set: function(t, e) {
                    return i.def(r(this, s), 0 === t ? 0 : t, e)
                }
            }, i, !0)
        },
        6503: function(t, e, n) {
            var i = n(2985)
              , r = n(6206)
              , s = Math.sqrt
              , o = Math.acosh;
            i(i.S + i.F * !(o && 710 == Math.floor(o(Number.MAX_VALUE)) && o(1 / 0) == 1 / 0), "Math", {
                acosh: function(t) {
                    return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : r(t - 1 + s(t - 1) * s(t + 1))
                }
            })
        },
        6786: function(t, e, n) {
            var i = n(2985)
              , r = Math.asinh;
            i(i.S + i.F * !(r && 1 / r(0) > 0), "Math", {
                asinh: function t(e) {
                    return isFinite(e = +e) && 0 != e ? e < 0 ? -t(-e) : Math.log(e + Math.sqrt(e * e + 1)) : e
                }
            })
        },
        932: function(t, e, n) {
            var i = n(2985)
              , r = Math.atanh;
            i(i.S + i.F * !(r && 1 / r(-0) < 0), "Math", {
                atanh: function(t) {
                    return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
                }
            })
        },
        7526: function(t, e, n) {
            var i = n(2985)
              , r = n(1801);
            i(i.S, "Math", {
                cbrt: function(t) {
                    return r(t = +t) * Math.pow(Math.abs(t), 1 / 3)
                }
            })
        },
        1591: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                clz32: function(t) {
                    return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32
                }
            })
        },
        9073: function(t, e, n) {
            var i = n(2985)
              , r = Math.exp;
            i(i.S, "Math", {
                cosh: function(t) {
                    return (r(t = +t) + r(-t)) / 2
                }
            })
        },
        347: function(t, e, n) {
            var i = n(2985)
              , r = n(3086);
            i(i.S + i.F * (r != Math.expm1), "Math", {
                expm1: r
            })
        },
        579: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                fround: n(4934)
            })
        },
        4669: function(t, e, n) {
            var i = n(2985)
              , r = Math.abs;
            i(i.S, "Math", {
                hypot: function(t, e) {
                    for (var n, i, s = 0, o = 0, a = arguments.length, l = 0; o < a; )
                        l < (n = r(arguments[o++])) ? (s = s * (i = l / n) * i + 1,
                        l = n) : s += n > 0 ? (i = n / l) * i : n;
                    return l === 1 / 0 ? 1 / 0 : l * Math.sqrt(s)
                }
            })
        },
        7710: function(t, e, n) {
            var i = n(2985)
              , r = Math.imul;
            i(i.S + i.F * n(4253)((function() {
                return -5 != r(4294967295, 5) || 2 != r.length
            }
            )), "Math", {
                imul: function(t, e) {
                    var n = 65535
                      , i = +t
                      , r = +e
                      , s = n & i
                      , o = n & r;
                    return 0 | s * o + ((n & i >>> 16) * o + s * (n & r >>> 16) << 16 >>> 0)
                }
            })
        },
        5789: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                log10: function(t) {
                    return Math.log(t) * Math.LOG10E
                }
            })
        },
        3514: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                log1p: n(6206)
            })
        },
        9978: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                log2: function(t) {
                    return Math.log(t) / Math.LN2
                }
            })
        },
        8472: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                sign: n(1801)
            })
        },
        6946: function(t, e, n) {
            var i = n(2985)
              , r = n(3086)
              , s = Math.exp;
            i(i.S + i.F * n(4253)((function() {
                return -2e-17 != !Math.sinh(-2e-17)
            }
            )), "Math", {
                sinh: function(t) {
                    return Math.abs(t = +t) < 1 ? (r(t) - r(-t)) / 2 : (s(t - 1) - s(-t - 1)) * (Math.E / 2)
                }
            })
        },
        5068: function(t, e, n) {
            var i = n(2985)
              , r = n(3086)
              , s = Math.exp;
            i(i.S, "Math", {
                tanh: function(t) {
                    var e = r(t = +t)
                      , n = r(-t);
                    return e == 1 / 0 ? 1 : n == 1 / 0 ? -1 : (e - n) / (s(t) + s(-t))
                }
            })
        },
        413: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Math", {
                trunc: function(t) {
                    return (t > 0 ? Math.floor : Math.ceil)(t)
                }
            })
        },
        1246: function(t, e, n) {
            "use strict";
            var i = n(3816)
              , r = n(9181)
              , s = n(2032)
              , o = n(266)
              , a = n(1689)
              , l = n(4253)
              , c = n(616).f
              , u = n(8693).f
              , h = n(9275).f
              , d = n(9599).trim
              , p = "Number"
              , f = i[p]
              , A = f
              , g = f.prototype
              , m = s(n(2503)(g)) == p
              , v = "trim"in String.prototype
              , y = function(t) {
                var e = a(t, !1);
                if ("string" == typeof e && e.length > 2) {
                    var n, i, r, s = (e = v ? e.trim() : d(e, 3)).charCodeAt(0);
                    if (43 === s || 45 === s) {
                        if (88 === (n = e.charCodeAt(2)) || 120 === n)
                            return NaN
                    } else if (48 === s) {
                        switch (e.charCodeAt(1)) {
                        case 66:
                        case 98:
                            i = 2,
                            r = 49;
                            break;
                        case 79:
                        case 111:
                            i = 8,
                            r = 55;
                            break;
                        default:
                            return +e
                        }
                        for (var o, l = e.slice(2), c = 0, u = l.length; c < u; c++)
                            if ((o = l.charCodeAt(c)) < 48 || o > r)
                                return NaN;
                        return parseInt(l, i)
                    }
                }
                return +e
            };
            if (!f(" 0o1") || !f("0b1") || f("+0x1")) {
                f = function(t) {
                    var e = arguments.length < 1 ? 0 : t
                      , n = this;
                    return n instanceof f && (m ? l((function() {
                        g.valueOf.call(n)
                    }
                    )) : s(n) != p) ? o(new A(y(e)), n, f) : y(e)
                }
                ;
                for (var _, E = n(7057) ? c(A) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), b = 0; E.length > b; b++)
                    r(A, _ = E[b]) && !r(f, _) && h(f, _, u(A, _));
                f.prototype = g,
                g.constructor = f,
                n(7234)(i, p, f)
            }
        },
        5972: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Number", {
                EPSILON: Math.pow(2, -52)
            })
        },
        3403: function(t, e, n) {
            var i = n(2985)
              , r = n(3816).isFinite;
            i(i.S, "Number", {
                isFinite: function(t) {
                    return "number" == typeof t && r(t)
                }
            })
        },
        2516: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Number", {
                isInteger: n(8367)
            })
        },
        9371: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Number", {
                isNaN: function(t) {
                    return t != t
                }
            })
        },
        6479: function(t, e, n) {
            var i = n(2985)
              , r = n(8367)
              , s = Math.abs;
            i(i.S, "Number", {
                isSafeInteger: function(t) {
                    return r(t) && s(t) <= 9007199254740991
                }
            })
        },
        1736: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Number", {
                MAX_SAFE_INTEGER: 9007199254740991
            })
        },
        1889: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Number", {
                MIN_SAFE_INTEGER: -9007199254740991
            })
        },
        5177: function(t, e, n) {
            var i = n(2985)
              , r = n(7743);
            i(i.S + i.F * (Number.parseFloat != r), "Number", {
                parseFloat: r
            })
        },
        6943: function(t, e, n) {
            var i = n(2985)
              , r = n(5960);
            i(i.S + i.F * (Number.parseInt != r), "Number", {
                parseInt: r
            })
        },
        726: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(1467)
              , s = n(3365)
              , o = n(8595)
              , a = 1..toFixed
              , l = Math.floor
              , c = [0, 0, 0, 0, 0, 0]
              , u = "Number.toFixed: incorrect invocation!"
              , h = "0"
              , d = function(t, e) {
                for (var n = -1, i = e; ++n < 6; )
                    i += t * c[n],
                    c[n] = i % 1e7,
                    i = l(i / 1e7)
            }
              , p = function(t) {
                for (var e = 6, n = 0; --e >= 0; )
                    n += c[e],
                    c[e] = l(n / t),
                    n = n % t * 1e7
            }
              , f = function() {
                for (var t = 6, e = ""; --t >= 0; )
                    if ("" !== e || 0 === t || 0 !== c[t]) {
                        var n = String(c[t]);
                        e = "" === e ? n : e + o.call(h, 7 - n.length) + n
                    }
                return e
            }
              , A = function(t, e, n) {
                return 0 === e ? n : e % 2 == 1 ? A(t, e - 1, n * t) : A(t * t, e / 2, n)
            };
            i(i.P + i.F * (!!a && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !n(4253)((function() {
                a.call({})
            }
            ))), "Number", {
                toFixed: function(t) {
                    var e, n, i, a, l = s(this, u), c = r(t), g = "", m = h;
                    if (c < 0 || c > 20)
                        throw RangeError(u);
                    if (l != l)
                        return "NaN";
                    if (l <= -1e21 || l >= 1e21)
                        return String(l);
                    if (l < 0 && (g = "-",
                    l = -l),
                    l > 1e-21)
                        if (e = function(t) {
                            for (var e = 0, n = t; n >= 4096; )
                                e += 12,
                                n /= 4096;
                            for (; n >= 2; )
                                e += 1,
                                n /= 2;
                            return e
                        }(l * A(2, 69, 1)) - 69,
                        n = e < 0 ? l * A(2, -e, 1) : l / A(2, e, 1),
                        n *= 4503599627370496,
                        (e = 52 - e) > 0) {
                            for (d(0, n),
                            i = c; i >= 7; )
                                d(1e7, 0),
                                i -= 7;
                            for (d(A(10, i, 1), 0),
                            i = e - 1; i >= 23; )
                                p(1 << 23),
                                i -= 23;
                            p(1 << i),
                            d(1, 1),
                            p(2),
                            m = f()
                        } else
                            d(0, n),
                            d(1 << -e, 0),
                            m = f() + o.call(h, c);
                    return m = c > 0 ? g + ((a = m.length) <= c ? "0." + o.call(h, c - a) + m : m.slice(0, a - c) + "." + m.slice(a - c)) : g + m
                }
            })
        },
        1901: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(4253)
              , s = n(3365)
              , o = 1..toPrecision;
            i(i.P + i.F * (r((function() {
                return "1" !== o.call(1, void 0)
            }
            )) || !r((function() {
                o.call({})
            }
            ))), "Number", {
                toPrecision: function(t) {
                    var e = s(this, "Number#toPrecision: incorrect invocation!");
                    return void 0 === t ? o.call(e) : o.call(e, t)
                }
            })
        },
        5115: function(t, e, n) {
            var i = n(2985);
            i(i.S + i.F, "Object", {
                assign: n(5345)
            })
        },
        8132: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Object", {
                create: n(2503)
            })
        },
        7470: function(t, e, n) {
            var i = n(2985);
            i(i.S + i.F * !n(7057), "Object", {
                defineProperties: n(5588)
            })
        },
        8388: function(t, e, n) {
            var i = n(2985);
            i(i.S + i.F * !n(7057), "Object", {
                defineProperty: n(9275).f
            })
        },
        9375: function(t, e, n) {
            var i = n(5286)
              , r = n(4728).onFreeze;
            n(3160)("freeze", (function(t) {
                return function(e) {
                    return t && i(e) ? t(r(e)) : e
                }
            }
            ))
        },
        4882: function(t, e, n) {
            var i = n(2110)
              , r = n(8693).f;
            n(3160)("getOwnPropertyDescriptor", (function() {
                return function(t, e) {
                    return r(i(t), e)
                }
            }
            ))
        },
        9622: function(t, e, n) {
            n(3160)("getOwnPropertyNames", (function() {
                return n(9327).f
            }
            ))
        },
        1520: function(t, e, n) {
            var i = n(508)
              , r = n(468);
            n(3160)("getPrototypeOf", (function() {
                return function(t) {
                    return r(i(t))
                }
            }
            ))
        },
        9892: function(t, e, n) {
            var i = n(5286);
            n(3160)("isExtensible", (function(t) {
                return function(e) {
                    return !!i(e) && (!t || t(e))
                }
            }
            ))
        },
        4157: function(t, e, n) {
            var i = n(5286);
            n(3160)("isFrozen", (function(t) {
                return function(e) {
                    return !i(e) || !!t && t(e)
                }
            }
            ))
        },
        5095: function(t, e, n) {
            var i = n(5286);
            n(3160)("isSealed", (function(t) {
                return function(e) {
                    return !i(e) || !!t && t(e)
                }
            }
            ))
        },
        9176: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Object", {
                is: n(7195)
            })
        },
        7476: function(t, e, n) {
            var i = n(508)
              , r = n(7184);
            n(3160)("keys", (function() {
                return function(t) {
                    return r(i(t))
                }
            }
            ))
        },
        4672: function(t, e, n) {
            var i = n(5286)
              , r = n(4728).onFreeze;
            n(3160)("preventExtensions", (function(t) {
                return function(e) {
                    return t && i(e) ? t(r(e)) : e
                }
            }
            ))
        },
        3533: function(t, e, n) {
            var i = n(5286)
              , r = n(4728).onFreeze;
            n(3160)("seal", (function(t) {
                return function(e) {
                    return t && i(e) ? t(r(e)) : e
                }
            }
            ))
        },
        8838: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Object", {
                setPrototypeOf: n(7375).set
            })
        },
        6253: function(t, e, n) {
            "use strict";
            var i = n(1488)
              , r = {};
            r[n(6314)("toStringTag")] = "z",
            r + "" != "[object z]" && n(7234)(Object.prototype, "toString", (function() {
                return "[object " + i(this) + "]"
            }
            ), !0)
        },
        4299: function(t, e, n) {
            var i = n(2985)
              , r = n(7743);
            i(i.G + i.F * (parseFloat != r), {
                parseFloat: r
            })
        },
        1084: function(t, e, n) {
            var i = n(2985)
              , r = n(5960);
            i(i.G + i.F * (parseInt != r), {
                parseInt: r
            })
        },
        851: function(t, e, n) {
            "use strict";
            var i, r, s, o, a = n(4461), l = n(3816), c = n(741), u = n(1488), h = n(2985), d = n(5286), p = n(4963), f = n(3328), A = n(3531), g = n(8364), m = n(4193).set, v = n(4351)(), y = n(3499), _ = n(188), E = n(575), b = n(94), x = "Promise", w = l.TypeError, S = l.process, C = S && S.versions, M = C && C.v8 || "", I = l[x], T = "process" == u(S), B = function() {}, R = r = y.f, L = !!function() {
                try {
                    var t = I.resolve(1)
                      , e = (t.constructor = {})[n(6314)("species")] = function(t) {
                        t(B, B)
                    }
                    ;
                    return (T || "function" == typeof PromiseRejectionEvent) && t.then(B)instanceof e && 0 !== M.indexOf("6.6") && -1 === E.indexOf("Chrome/66")
                } catch (t) {}
            }(), D = function(t) {
                var e;
                return !(!d(t) || "function" != typeof (e = t.then)) && e
            }, P = function(t, e) {
                if (!t._n) {
                    t._n = !0;
                    var n = t._c;
                    v((function() {
                        for (var i = t._v, r = 1 == t._s, s = 0, o = function(e) {
                            var n, s, o, a = r ? e.ok : e.fail, l = e.resolve, c = e.reject, u = e.domain;
                            try {
                                a ? (r || (2 == t._h && N(t),
                                t._h = 1),
                                !0 === a ? n = i : (u && u.enter(),
                                n = a(i),
                                u && (u.exit(),
                                o = !0)),
                                n === e.promise ? c(w("Promise-chain cycle")) : (s = D(n)) ? s.call(n, l, c) : l(n)) : c(i)
                            } catch (t) {
                                u && !o && u.exit(),
                                c(t)
                            }
                        }; n.length > s; )
                            o(n[s++]);
                        t._c = [],
                        t._n = !1,
                        e && !t._h && U(t)
                    }
                    ))
                }
            }, U = function(t) {
                m.call(l, (function() {
                    var e, n, i, r = t._v, s = O(t);
                    if (s && (e = _((function() {
                        T ? S.emit("unhandledRejection", r, t) : (n = l.onunhandledrejection) ? n({
                            promise: t,
                            reason: r
                        }) : (i = l.console) && i.error && i.error("Unhandled promise rejection", r)
                    }
                    )),
                    t._h = T || O(t) ? 2 : 1),
                    t._a = void 0,
                    s && e.e)
                        throw e.v
                }
                ))
            }, O = function(t) {
                return 1 !== t._h && 0 === (t._a || t._c).length
            }, N = function(t) {
                m.call(l, (function() {
                    var e;
                    T ? S.emit("rejectionHandled", t) : (e = l.onrejectionhandled) && e({
                        promise: t,
                        reason: t._v
                    })
                }
                ))
            }, F = function(t) {
                var e = this;
                e._d || (e._d = !0,
                (e = e._w || e)._v = t,
                e._s = 2,
                e._a || (e._a = e._c.slice()),
                P(e, !0))
            }, Q = function(t) {
                var e, n = this;
                if (!n._d) {
                    n._d = !0,
                    n = n._w || n;
                    try {
                        if (n === t)
                            throw w("Promise can't be resolved itself");
                        (e = D(t)) ? v((function() {
                            var i = {
                                _w: n,
                                _d: !1
                            };
                            try {
                                e.call(t, c(Q, i, 1), c(F, i, 1))
                            } catch (t) {
                                F.call(i, t)
                            }
                        }
                        )) : (n._v = t,
                        n._s = 1,
                        P(n, !1))
                    } catch (t) {
                        F.call({
                            _w: n,
                            _d: !1
                        }, t)
                    }
                }
            };
            L || (I = function(t) {
                f(this, I, x, "_h"),
                p(t),
                i.call(this);
                try {
                    t(c(Q, this, 1), c(F, this, 1))
                } catch (t) {
                    F.call(this, t)
                }
            }
            ,
            (i = function(t) {
                this._c = [],
                this._a = void 0,
                this._s = 0,
                this._d = !1,
                this._v = void 0,
                this._h = 0,
                this._n = !1
            }
            ).prototype = n(4408)(I.prototype, {
                then: function(t, e) {
                    var n = R(g(this, I));
                    return n.ok = "function" != typeof t || t,
                    n.fail = "function" == typeof e && e,
                    n.domain = T ? S.domain : void 0,
                    this._c.push(n),
                    this._a && this._a.push(n),
                    this._s && P(this, !1),
                    n.promise
                },
                catch: function(t) {
                    return this.then(void 0, t)
                }
            }),
            s = function() {
                var t = new i;
                this.promise = t,
                this.resolve = c(Q, t, 1),
                this.reject = c(F, t, 1)
            }
            ,
            y.f = R = function(t) {
                return t === I || t === o ? new s(t) : r(t)
            }
            ),
            h(h.G + h.W + h.F * !L, {
                Promise: I
            }),
            n(2943)(I, x),
            n(2974)(x),
            o = n(5645)[x],
            h(h.S + h.F * !L, x, {
                reject: function(t) {
                    var e = R(this);
                    return (0,
                    e.reject)(t),
                    e.promise
                }
            }),
            h(h.S + h.F * (a || !L), x, {
                resolve: function(t) {
                    return b(a && this === o ? I : this, t)
                }
            }),
            h(h.S + h.F * !(L && n(7462)((function(t) {
                I.all(t).catch(B)
            }
            ))), x, {
                all: function(t) {
                    var e = this
                      , n = R(e)
                      , i = n.resolve
                      , r = n.reject
                      , s = _((function() {
                        var n = []
                          , s = 0
                          , o = 1;
                        A(t, !1, (function(t) {
                            var a = s++
                              , l = !1;
                            n.push(void 0),
                            o++,
                            e.resolve(t).then((function(t) {
                                l || (l = !0,
                                n[a] = t,
                                --o || i(n))
                            }
                            ), r)
                        }
                        )),
                        --o || i(n)
                    }
                    ));
                    return s.e && r(s.v),
                    n.promise
                },
                race: function(t) {
                    var e = this
                      , n = R(e)
                      , i = n.reject
                      , r = _((function() {
                        A(t, !1, (function(t) {
                            e.resolve(t).then(n.resolve, i)
                        }
                        ))
                    }
                    ));
                    return r.e && i(r.v),
                    n.promise
                }
            })
        },
        1572: function(t, e, n) {
            var i = n(2985)
              , r = n(4963)
              , s = n(7007)
              , o = (n(3816).Reflect || {}).apply
              , a = Function.apply;
            i(i.S + i.F * !n(4253)((function() {
                o((function() {}
                ))
            }
            )), "Reflect", {
                apply: function(t, e, n) {
                    var i = r(t)
                      , l = s(n);
                    return o ? o(i, e, l) : a.call(i, e, l)
                }
            })
        },
        2139: function(t, e, n) {
            var i = n(2985)
              , r = n(2503)
              , s = n(4963)
              , o = n(7007)
              , a = n(5286)
              , l = n(4253)
              , c = n(4398)
              , u = (n(3816).Reflect || {}).construct
              , h = l((function() {
                function t() {}
                return !(u((function() {}
                ), [], t)instanceof t)
            }
            ))
              , d = !l((function() {
                u((function() {}
                ))
            }
            ));
            i(i.S + i.F * (h || d), "Reflect", {
                construct: function(t, e) {
                    s(t),
                    o(e);
                    var n = arguments.length < 3 ? t : s(arguments[2]);
                    if (d && !h)
                        return u(t, e, n);
                    if (t == n) {
                        switch (e.length) {
                        case 0:
                            return new t;
                        case 1:
                            return new t(e[0]);
                        case 2:
                            return new t(e[0],e[1]);
                        case 3:
                            return new t(e[0],e[1],e[2]);
                        case 4:
                            return new t(e[0],e[1],e[2],e[3])
                        }
                        var i = [null];
                        return i.push.apply(i, e),
                        new (c.apply(t, i))
                    }
                    var l = n.prototype
                      , p = r(a(l) ? l : Object.prototype)
                      , f = Function.apply.call(t, p, e);
                    return a(f) ? f : p
                }
            })
        },
        685: function(t, e, n) {
            var i = n(9275)
              , r = n(2985)
              , s = n(7007)
              , o = n(1689);
            r(r.S + r.F * n(4253)((function() {
                Reflect.defineProperty(i.f({}, 1, {
                    value: 1
                }), 1, {
                    value: 2
                })
            }
            )), "Reflect", {
                defineProperty: function(t, e, n) {
                    s(t),
                    e = o(e, !0),
                    s(n);
                    try {
                        return i.f(t, e, n),
                        !0
                    } catch (t) {
                        return !1
                    }
                }
            })
        },
        5535: function(t, e, n) {
            var i = n(2985)
              , r = n(8693).f
              , s = n(7007);
            i(i.S, "Reflect", {
                deleteProperty: function(t, e) {
                    var n = r(s(t), e);
                    return !(n && !n.configurable) && delete t[e]
                }
            })
        },
        7347: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(7007)
              , s = function(t) {
                this._t = r(t),
                this._i = 0;
                var e, n = this._k = [];
                for (e in t)
                    n.push(e)
            };
            n(9988)(s, "Object", (function() {
                var t, e = this, n = e._k;
                do {
                    if (e._i >= n.length)
                        return {
                            value: void 0,
                            done: !0
                        }
                } while (!((t = n[e._i++])in e._t));
                return {
                    value: t,
                    done: !1
                }
            }
            )),
            i(i.S, "Reflect", {
                enumerate: function(t) {
                    return new s(t)
                }
            })
        },
        6633: function(t, e, n) {
            var i = n(8693)
              , r = n(2985)
              , s = n(7007);
            r(r.S, "Reflect", {
                getOwnPropertyDescriptor: function(t, e) {
                    return i.f(s(t), e)
                }
            })
        },
        8989: function(t, e, n) {
            var i = n(2985)
              , r = n(468)
              , s = n(7007);
            i(i.S, "Reflect", {
                getPrototypeOf: function(t) {
                    return r(s(t))
                }
            })
        },
        3049: function(t, e, n) {
            var i = n(8693)
              , r = n(468)
              , s = n(9181)
              , o = n(2985)
              , a = n(5286)
              , l = n(7007);
            o(o.S, "Reflect", {
                get: function t(e, n) {
                    var o, c, u = arguments.length < 3 ? e : arguments[2];
                    return l(e) === u ? e[n] : (o = i.f(e, n)) ? s(o, "value") ? o.value : void 0 !== o.get ? o.get.call(u) : void 0 : a(c = r(e)) ? t(c, n, u) : void 0
                }
            })
        },
        8270: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Reflect", {
                has: function(t, e) {
                    return e in t
                }
            })
        },
        4510: function(t, e, n) {
            var i = n(2985)
              , r = n(7007)
              , s = Object.isExtensible;
            i(i.S, "Reflect", {
                isExtensible: function(t) {
                    return r(t),
                    !s || s(t)
                }
            })
        },
        3984: function(t, e, n) {
            var i = n(2985);
            i(i.S, "Reflect", {
                ownKeys: n(7643)
            })
        },
        5769: function(t, e, n) {
            var i = n(2985)
              , r = n(7007)
              , s = Object.preventExtensions;
            i(i.S, "Reflect", {
                preventExtensions: function(t) {
                    r(t);
                    try {
                        return s && s(t),
                        !0
                    } catch (t) {
                        return !1
                    }
                }
            })
        },
        6014: function(t, e, n) {
            var i = n(2985)
              , r = n(7375);
            r && i(i.S, "Reflect", {
                setPrototypeOf: function(t, e) {
                    r.check(t, e);
                    try {
                        return r.set(t, e),
                        !0
                    } catch (t) {
                        return !1
                    }
                }
            })
        },
        55: function(t, e, n) {
            var i = n(9275)
              , r = n(8693)
              , s = n(468)
              , o = n(9181)
              , a = n(2985)
              , l = n(681)
              , c = n(7007)
              , u = n(5286);
            a(a.S, "Reflect", {
                set: function t(e, n, a) {
                    var h, d, p = arguments.length < 4 ? e : arguments[3], f = r.f(c(e), n);
                    if (!f) {
                        if (u(d = s(e)))
                            return t(d, n, a, p);
                        f = l(0)
                    }
                    if (o(f, "value")) {
                        if (!1 === f.writable || !u(p))
                            return !1;
                        if (h = r.f(p, n)) {
                            if (h.get || h.set || !1 === h.writable)
                                return !1;
                            h.value = a,
                            i.f(p, n, h)
                        } else
                            i.f(p, n, l(0, a));
                        return !0
                    }
                    return void 0 !== f.set && (f.set.call(p, a),
                    !0)
                }
            })
        },
        3946: function(t, e, n) {
            var i = n(3816)
              , r = n(266)
              , s = n(9275).f
              , o = n(616).f
              , a = n(5364)
              , l = n(3218)
              , c = i.RegExp
              , u = c
              , h = c.prototype
              , d = /a/g
              , p = /a/g
              , f = new c(d) !== d;
            if (n(7057) && (!f || n(4253)((function() {
                return p[n(6314)("match")] = !1,
                c(d) != d || c(p) == p || "/a/i" != c(d, "i")
            }
            )))) {
                c = function(t, e) {
                    var n = this instanceof c
                      , i = a(t)
                      , s = void 0 === e;
                    return !n && i && t.constructor === c && s ? t : r(f ? new u(i && !s ? t.source : t,e) : u((i = t instanceof c) ? t.source : t, i && s ? l.call(t) : e), n ? this : h, c)
                }
                ;
                for (var A = function(t) {
                    t in c || s(c, t, {
                        configurable: !0,
                        get: function() {
                            return u[t]
                        },
                        set: function(e) {
                            u[t] = e
                        }
                    })
                }, g = o(u), m = 0; g.length > m; )
                    A(g[m++]);
                h.constructor = c,
                c.prototype = h,
                n(7234)(i, "RegExp", c)
            }
            n(2974)("RegExp")
        },
        8269: function(t, e, n) {
            "use strict";
            var i = n(1165);
            n(2985)({
                target: "RegExp",
                proto: !0,
                forced: i !== /./.exec
            }, {
                exec: i
            })
        },
        6774: function(t, e, n) {
            n(7057) && "g" != /./g.flags && n(9275).f(RegExp.prototype, "flags", {
                configurable: !0,
                get: n(3218)
            })
        },
        1466: function(t, e, n) {
            "use strict";
            var i = n(7007)
              , r = n(875)
              , s = n(6793)
              , o = n(7787);
            n(8082)("match", 1, (function(t, e, n, a) {
                return [function(n) {
                    var i = t(this)
                      , r = null == n ? void 0 : n[e];
                    return void 0 !== r ? r.call(n, i) : new RegExp(n)[e](String(i))
                }
                , function(t) {
                    var e = a(n, t, this);
                    if (e.done)
                        return e.value;
                    var l = i(t)
                      , c = String(this);
                    if (!l.global)
                        return o(l, c);
                    var u = l.unicode;
                    l.lastIndex = 0;
                    for (var h, d = [], p = 0; null !== (h = o(l, c)); ) {
                        var f = String(h[0]);
                        d[p] = f,
                        "" === f && (l.lastIndex = s(c, r(l.lastIndex), u)),
                        p++
                    }
                    return 0 === p ? null : d
                }
                ]
            }
            ))
        },
        9357: function(t, e, n) {
            "use strict";
            var i = n(7007)
              , r = n(508)
              , s = n(875)
              , o = n(1467)
              , a = n(6793)
              , l = n(7787)
              , c = Math.max
              , u = Math.min
              , h = Math.floor
              , d = /\$([$&`']|\d\d?|<[^>]*>)/g
              , p = /\$([$&`']|\d\d?)/g;
            n(8082)("replace", 2, (function(t, e, n, f) {
                return [function(i, r) {
                    var s = t(this)
                      , o = null == i ? void 0 : i[e];
                    return void 0 !== o ? o.call(i, s, r) : n.call(String(s), i, r)
                }
                , function(t, e) {
                    var r = f(n, t, this, e);
                    if (r.done)
                        return r.value;
                    var h = i(t)
                      , d = String(this)
                      , p = "function" == typeof e;
                    p || (e = String(e));
                    var g = h.global;
                    if (g) {
                        var m = h.unicode;
                        h.lastIndex = 0
                    }
                    for (var v = []; ; ) {
                        var y = l(h, d);
                        if (null === y)
                            break;
                        if (v.push(y),
                        !g)
                            break;
                        "" === String(y[0]) && (h.lastIndex = a(d, s(h.lastIndex), m))
                    }
                    for (var _, E = "", b = 0, x = 0; x < v.length; x++) {
                        y = v[x];
                        for (var w = String(y[0]), S = c(u(o(y.index), d.length), 0), C = [], M = 1; M < y.length; M++)
                            C.push(void 0 === (_ = y[M]) ? _ : String(_));
                        var I = y.groups;
                        if (p) {
                            var T = [w].concat(C, S, d);
                            void 0 !== I && T.push(I);
                            var B = String(e.apply(void 0, T))
                        } else
                            B = A(w, d, S, C, I, e);
                        S >= b && (E += d.slice(b, S) + B,
                        b = S + w.length)
                    }
                    return E + d.slice(b)
                }
                ];
                function A(t, e, i, s, o, a) {
                    var l = i + t.length
                      , c = s.length
                      , u = p;
                    return void 0 !== o && (o = r(o),
                    u = d),
                    n.call(a, u, (function(n, r) {
                        var a;
                        switch (r.charAt(0)) {
                        case "$":
                            return "$";
                        case "&":
                            return t;
                        case "`":
                            return e.slice(0, i);
                        case "'":
                            return e.slice(l);
                        case "<":
                            a = o[r.slice(1, -1)];
                            break;
                        default:
                            var u = +r;
                            if (0 === u)
                                return n;
                            if (u > c) {
                                var d = h(u / 10);
                                return 0 === d ? n : d <= c ? void 0 === s[d - 1] ? r.charAt(1) : s[d - 1] + r.charAt(1) : n
                            }
                            a = s[u - 1]
                        }
                        return void 0 === a ? "" : a
                    }
                    ))
                }
            }
            ))
        },
        6142: function(t, e, n) {
            "use strict";
            var i = n(7007)
              , r = n(7195)
              , s = n(7787);
            n(8082)("search", 1, (function(t, e, n, o) {
                return [function(n) {
                    var i = t(this)
                      , r = null == n ? void 0 : n[e];
                    return void 0 !== r ? r.call(n, i) : new RegExp(n)[e](String(i))
                }
                , function(t) {
                    var e = o(n, t, this);
                    if (e.done)
                        return e.value;
                    var a = i(t)
                      , l = String(this)
                      , c = a.lastIndex;
                    r(c, 0) || (a.lastIndex = 0);
                    var u = s(a, l);
                    return r(a.lastIndex, c) || (a.lastIndex = c),
                    null === u ? -1 : u.index
                }
                ]
            }
            ))
        },
        1876: function(t, e, n) {
            "use strict";
            var i = n(5364)
              , r = n(7007)
              , s = n(8364)
              , o = n(6793)
              , a = n(875)
              , l = n(7787)
              , c = n(1165)
              , u = n(4253)
              , h = Math.min
              , d = [].push
              , p = "split"
              , f = "length"
              , A = "lastIndex"
              , g = 4294967295
              , m = !u((function() {
                RegExp(g, "y")
            }
            ));
            n(8082)("split", 2, (function(t, e, n, u) {
                var v;
                return v = "c" == "abbc"[p](/(b)*/)[1] || 4 != "test"[p](/(?:)/, -1)[f] || 2 != "ab"[p](/(?:ab)*/)[f] || 4 != "."[p](/(.?)(.?)/)[f] || "."[p](/()()/)[f] > 1 || ""[p](/.?/)[f] ? function(t, e) {
                    var r = String(this);
                    if (void 0 === t && 0 === e)
                        return [];
                    if (!i(t))
                        return n.call(r, t, e);
                    for (var s, o, a, l = [], u = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), h = 0, p = void 0 === e ? g : e >>> 0, m = new RegExp(t.source,u + "g"); (s = c.call(m, r)) && !((o = m[A]) > h && (l.push(r.slice(h, s.index)),
                    s[f] > 1 && s.index < r[f] && d.apply(l, s.slice(1)),
                    a = s[0][f],
                    h = o,
                    l[f] >= p)); )
                        m[A] === s.index && m[A]++;
                    return h === r[f] ? !a && m.test("") || l.push("") : l.push(r.slice(h)),
                    l[f] > p ? l.slice(0, p) : l
                }
                : "0"[p](void 0, 0)[f] ? function(t, e) {
                    return void 0 === t && 0 === e ? [] : n.call(this, t, e)
                }
                : n,
                [function(n, i) {
                    var r = t(this)
                      , s = null == n ? void 0 : n[e];
                    return void 0 !== s ? s.call(n, r, i) : v.call(String(r), n, i)
                }
                , function(t, e) {
                    var i = u(v, t, this, e, v !== n);
                    if (i.done)
                        return i.value;
                    var c = r(t)
                      , d = String(this)
                      , p = s(c, RegExp)
                      , f = c.unicode
                      , A = (c.ignoreCase ? "i" : "") + (c.multiline ? "m" : "") + (c.unicode ? "u" : "") + (m ? "y" : "g")
                      , y = new p(m ? c : "^(?:" + c.source + ")",A)
                      , _ = void 0 === e ? g : e >>> 0;
                    if (0 === _)
                        return [];
                    if (0 === d.length)
                        return null === l(y, d) ? [d] : [];
                    for (var E = 0, b = 0, x = []; b < d.length; ) {
                        y.lastIndex = m ? b : 0;
                        var w, S = l(y, m ? d : d.slice(b));
                        if (null === S || (w = h(a(y.lastIndex + (m ? 0 : b)), d.length)) === E)
                            b = o(d, b, f);
                        else {
                            if (x.push(d.slice(E, b)),
                            x.length === _)
                                return x;
                            for (var C = 1; C <= S.length - 1; C++)
                                if (x.push(S[C]),
                                x.length === _)
                                    return x;
                            b = E = w
                        }
                    }
                    return x.push(d.slice(E)),
                    x
                }
                ]
            }
            ))
        },
        6108: function(t, e, n) {
            "use strict";
            n(6774);
            var i = n(7007)
              , r = n(3218)
              , s = n(7057)
              , o = "toString"
              , a = /./[o]
              , l = function(t) {
                n(7234)(RegExp.prototype, o, t, !0)
            };
            n(4253)((function() {
                return "/a/b" != a.call({
                    source: "a",
                    flags: "b"
                })
            }
            )) ? l((function() {
                var t = i(this);
                return "/".concat(t.source, "/", "flags"in t ? t.flags : !s && t instanceof RegExp ? r.call(t) : void 0)
            }
            )) : a.name != o && l((function() {
                return a.call(this)
            }
            ))
        },
        8184: function(t, e, n) {
            "use strict";
            var i = n(9824)
              , r = n(1616);
            t.exports = n(5795)("Set", (function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            }
            ), {
                add: function(t) {
                    return i.def(r(this, "Set"), t = 0 === t ? 0 : t, t)
                }
            }, i)
        },
        856: function(t, e, n) {
            "use strict";
            n(9395)("anchor", (function(t) {
                return function(e) {
                    return t(this, "a", "name", e)
                }
            }
            ))
        },
        703: function(t, e, n) {
            "use strict";
            n(9395)("big", (function(t) {
                return function() {
                    return t(this, "big", "", "")
                }
            }
            ))
        },
        1539: function(t, e, n) {
            "use strict";
            n(9395)("blink", (function(t) {
                return function() {
                    return t(this, "blink", "", "")
                }
            }
            ))
        },
        5292: function(t, e, n) {
            "use strict";
            n(9395)("bold", (function(t) {
                return function() {
                    return t(this, "b", "", "")
                }
            }
            ))
        },
        9539: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(4496)(!1);
            i(i.P, "String", {
                codePointAt: function(t) {
                    return r(this, t)
                }
            })
        },
        6620: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(875)
              , s = n(2094)
              , o = "endsWith"
              , a = ""[o];
            i(i.P + i.F * n(8852)(o), "String", {
                endsWith: function(t) {
                    var e = s(this, t, o)
                      , n = arguments.length > 1 ? arguments[1] : void 0
                      , i = r(e.length)
                      , l = void 0 === n ? i : Math.min(r(n), i)
                      , c = String(t);
                    return a ? a.call(e, c, l) : e.slice(l - c.length, l) === c
                }
            })
        },
        6629: function(t, e, n) {
            "use strict";
            n(9395)("fixed", (function(t) {
                return function() {
                    return t(this, "tt", "", "")
                }
            }
            ))
        },
        3694: function(t, e, n) {
            "use strict";
            n(9395)("fontcolor", (function(t) {
                return function(e) {
                    return t(this, "font", "color", e)
                }
            }
            ))
        },
        7648: function(t, e, n) {
            "use strict";
            n(9395)("fontsize", (function(t) {
                return function(e) {
                    return t(this, "font", "size", e)
                }
            }
            ))
        },
        191: function(t, e, n) {
            var i = n(2985)
              , r = n(2337)
              , s = String.fromCharCode
              , o = String.fromCodePoint;
            i(i.S + i.F * (!!o && 1 != o.length), "String", {
                fromCodePoint: function(t) {
                    for (var e, n = [], i = arguments.length, o = 0; i > o; ) {
                        if (e = +arguments[o++],
                        r(e, 1114111) !== e)
                            throw RangeError(e + " is not a valid code point");
                        n.push(e < 65536 ? s(e) : s(55296 + ((e -= 65536) >> 10), e % 1024 + 56320))
                    }
                    return n.join("")
                }
            })
        },
        2850: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(2094)
              , s = "includes";
            i(i.P + i.F * n(8852)(s), "String", {
                includes: function(t) {
                    return !!~r(this, t, s).indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        7795: function(t, e, n) {
            "use strict";
            n(9395)("italics", (function(t) {
                return function() {
                    return t(this, "i", "", "")
                }
            }
            ))
        },
        9115: function(t, e, n) {
            "use strict";
            var i = n(4496)(!0);
            n(2923)(String, "String", (function(t) {
                this._t = String(t),
                this._i = 0
            }
            ), (function() {
                var t, e = this._t, n = this._i;
                return n >= e.length ? {
                    value: void 0,
                    done: !0
                } : (t = i(e, n),
                this._i += t.length,
                {
                    value: t,
                    done: !1
                })
            }
            ))
        },
        4531: function(t, e, n) {
            "use strict";
            n(9395)("link", (function(t) {
                return function(e) {
                    return t(this, "a", "href", e)
                }
            }
            ))
        },
        8306: function(t, e, n) {
            var i = n(2985)
              , r = n(2110)
              , s = n(875);
            i(i.S, "String", {
                raw: function(t) {
                    for (var e = r(t.raw), n = s(e.length), i = arguments.length, o = [], a = 0; n > a; )
                        o.push(String(e[a++])),
                        a < i && o.push(String(arguments[a]));
                    return o.join("")
                }
            })
        },
        823: function(t, e, n) {
            var i = n(2985);
            i(i.P, "String", {
                repeat: n(8595)
            })
        },
        3605: function(t, e, n) {
            "use strict";
            n(9395)("small", (function(t) {
                return function() {
                    return t(this, "small", "", "")
                }
            }
            ))
        },
        7732: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(875)
              , s = n(2094)
              , o = "startsWith"
              , a = ""[o];
            i(i.P + i.F * n(8852)(o), "String", {
                startsWith: function(t) {
                    var e = s(this, t, o)
                      , n = r(Math.min(arguments.length > 1 ? arguments[1] : void 0, e.length))
                      , i = String(t);
                    return a ? a.call(e, i, n) : e.slice(n, n + i.length) === i
                }
            })
        },
        6780: function(t, e, n) {
            "use strict";
            n(9395)("strike", (function(t) {
                return function() {
                    return t(this, "strike", "", "")
                }
            }
            ))
        },
        9937: function(t, e, n) {
            "use strict";
            n(9395)("sub", (function(t) {
                return function() {
                    return t(this, "sub", "", "")
                }
            }
            ))
        },
        511: function(t, e, n) {
            "use strict";
            n(9395)("sup", (function(t) {
                return function() {
                    return t(this, "sup", "", "")
                }
            }
            ))
        },
        4564: function(t, e, n) {
            "use strict";
            n(9599)("trim", (function(t) {
                return function() {
                    return t(this, 3)
                }
            }
            ))
        },
        5767: function(t, e, n) {
            "use strict";
            var i = n(3816)
              , r = n(9181)
              , s = n(7057)
              , o = n(2985)
              , a = n(7234)
              , l = n(4728).KEY
              , c = n(4253)
              , u = n(3825)
              , h = n(2943)
              , d = n(3953)
              , p = n(6314)
              , f = n(8787)
              , A = n(6074)
              , g = n(5541)
              , m = n(4302)
              , v = n(7007)
              , y = n(5286)
              , _ = n(508)
              , E = n(2110)
              , b = n(1689)
              , x = n(681)
              , w = n(2503)
              , S = n(9327)
              , C = n(8693)
              , M = n(4548)
              , I = n(9275)
              , T = n(7184)
              , B = C.f
              , R = I.f
              , L = S.f
              , D = i.Symbol
              , P = i.JSON
              , U = P && P.stringify
              , O = "prototype"
              , N = p("_hidden")
              , F = p("toPrimitive")
              , Q = {}.propertyIsEnumerable
              , k = u("symbol-registry")
              , G = u("symbols")
              , H = u("op-symbols")
              , z = Object[O]
              , V = "function" == typeof D && !!M.f
              , W = i.QObject
              , q = !W || !W[O] || !W[O].findChild
              , j = s && c((function() {
                return 7 != w(R({}, "a", {
                    get: function() {
                        return R(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
            }
            )) ? function(t, e, n) {
                var i = B(z, e);
                i && delete z[e],
                R(t, e, n),
                i && t !== z && R(z, e, i)
            }
            : R
              , X = function(t) {
                var e = G[t] = w(D[O]);
                return e._k = t,
                e
            }
              , Y = V && "symbol" == typeof D.iterator ? function(t) {
                return "symbol" == typeof t
            }
            : function(t) {
                return t instanceof D
            }
              , K = function(t, e, n) {
                return t === z && K(H, e, n),
                v(t),
                e = b(e, !0),
                v(n),
                r(G, e) ? (n.enumerable ? (r(t, N) && t[N][e] && (t[N][e] = !1),
                n = w(n, {
                    enumerable: x(0, !1)
                })) : (r(t, N) || R(t, N, x(1, {})),
                t[N][e] = !0),
                j(t, e, n)) : R(t, e, n)
            }
              , J = function(t, e) {
                v(t);
                for (var n, i = g(e = E(e)), r = 0, s = i.length; s > r; )
                    K(t, n = i[r++], e[n]);
                return t
            }
              , $ = function(t) {
                var e = Q.call(this, t = b(t, !0));
                return !(this === z && r(G, t) && !r(H, t)) && (!(e || !r(this, t) || !r(G, t) || r(this, N) && this[N][t]) || e)
            }
              , Z = function(t, e) {
                if (t = E(t),
                e = b(e, !0),
                t !== z || !r(G, e) || r(H, e)) {
                    var n = B(t, e);
                    return !n || !r(G, e) || r(t, N) && t[N][e] || (n.enumerable = !0),
                    n
                }
            }
              , tt = function(t) {
                for (var e, n = L(E(t)), i = [], s = 0; n.length > s; )
                    r(G, e = n[s++]) || e == N || e == l || i.push(e);
                return i
            }
              , et = function(t) {
                for (var e, n = t === z, i = L(n ? H : E(t)), s = [], o = 0; i.length > o; )
                    !r(G, e = i[o++]) || n && !r(z, e) || s.push(G[e]);
                return s
            };
            V || (D = function() {
                if (this instanceof D)
                    throw TypeError("Symbol is not a constructor!");
                var t = d(arguments.length > 0 ? arguments[0] : void 0)
                  , e = function(n) {
                    this === z && e.call(H, n),
                    r(this, N) && r(this[N], t) && (this[N][t] = !1),
                    j(this, t, x(1, n))
                };
                return s && q && j(z, t, {
                    configurable: !0,
                    set: e
                }),
                X(t)
            }
            ,
            a(D[O], "toString", (function() {
                return this._k
            }
            )),
            C.f = Z,
            I.f = K,
            n(616).f = S.f = tt,
            n(4682).f = $,
            M.f = et,
            s && !n(4461) && a(z, "propertyIsEnumerable", $, !0),
            f.f = function(t) {
                return X(p(t))
            }
            ),
            o(o.G + o.W + o.F * !V, {
                Symbol: D
            });
            for (var nt = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), it = 0; nt.length > it; )
                p(nt[it++]);
            for (var rt = T(p.store), st = 0; rt.length > st; )
                A(rt[st++]);
            o(o.S + o.F * !V, "Symbol", {
                for: function(t) {
                    return r(k, t += "") ? k[t] : k[t] = D(t)
                },
                keyFor: function(t) {
                    if (!Y(t))
                        throw TypeError(t + " is not a symbol!");
                    for (var e in k)
                        if (k[e] === t)
                            return e
                },
                useSetter: function() {
                    q = !0
                },
                useSimple: function() {
                    q = !1
                }
            }),
            o(o.S + o.F * !V, "Object", {
                create: function(t, e) {
                    return void 0 === e ? w(t) : J(w(t), e)
                },
                defineProperty: K,
                defineProperties: J,
                getOwnPropertyDescriptor: Z,
                getOwnPropertyNames: tt,
                getOwnPropertySymbols: et
            });
            var ot = c((function() {
                M.f(1)
            }
            ));
            o(o.S + o.F * ot, "Object", {
                getOwnPropertySymbols: function(t) {
                    return M.f(_(t))
                }
            }),
            P && o(o.S + o.F * (!V || c((function() {
                var t = D();
                return "[null]" != U([t]) || "{}" != U({
                    a: t
                }) || "{}" != U(Object(t))
            }
            ))), "JSON", {
                stringify: function(t) {
                    for (var e, n, i = [t], r = 1; arguments.length > r; )
                        i.push(arguments[r++]);
                    if (n = e = i[1],
                    (y(e) || void 0 !== t) && !Y(t))
                        return m(e) || (e = function(t, e) {
                            if ("function" == typeof n && (e = n.call(this, t, e)),
                            !Y(e))
                                return e
                        }
                        ),
                        i[1] = e,
                        U.apply(P, i)
                }
            }),
            D[O][F] || n(7728)(D[O], F, D[O].valueOf),
            h(D, "Symbol"),
            h(Math, "Math", !0),
            h(i.JSON, "JSON", !0)
        },
        142: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(9383)
              , s = n(1125)
              , o = n(7007)
              , a = n(2337)
              , l = n(875)
              , c = n(5286)
              , u = n(3816).ArrayBuffer
              , h = n(8364)
              , d = s.ArrayBuffer
              , p = s.DataView
              , f = r.ABV && u.isView
              , A = d.prototype.slice
              , g = r.VIEW
              , m = "ArrayBuffer";
            i(i.G + i.W + i.F * (u !== d), {
                ArrayBuffer: d
            }),
            i(i.S + i.F * !r.CONSTR, m, {
                isView: function(t) {
                    return f && f(t) || c(t) && g in t
                }
            }),
            i(i.P + i.U + i.F * n(4253)((function() {
                return !new d(2).slice(1, void 0).byteLength
            }
            )), m, {
                slice: function(t, e) {
                    if (void 0 !== A && void 0 === e)
                        return A.call(o(this), t);
                    for (var n = o(this).byteLength, i = a(t, n), r = a(void 0 === e ? n : e, n), s = new (h(this, d))(l(r - i)), c = new p(this), u = new p(s), f = 0; i < r; )
                        u.setUint8(f++, c.getUint8(i++));
                    return s
                }
            }),
            n(2974)(m)
        },
        1786: function(t, e, n) {
            var i = n(2985);
            i(i.G + i.W + i.F * !n(9383).ABV, {
                DataView: n(1125).DataView
            })
        },
        162: function(t, e, n) {
            n(8440)("Float32", 4, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        3834: function(t, e, n) {
            n(8440)("Float64", 8, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        4821: function(t, e, n) {
            n(8440)("Int16", 2, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        1303: function(t, e, n) {
            n(8440)("Int32", 4, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        5368: function(t, e, n) {
            n(8440)("Int8", 1, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        9103: function(t, e, n) {
            n(8440)("Uint16", 2, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        3318: function(t, e, n) {
            n(8440)("Uint32", 4, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        6964: function(t, e, n) {
            n(8440)("Uint8", 1, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ))
        },
        2152: function(t, e, n) {
            n(8440)("Uint8", 1, (function(t) {
                return function(e, n, i) {
                    return t(this, e, n, i)
                }
            }
            ), !0)
        },
        147: function(t, e, n) {
            "use strict";
            var i, r = n(3816), s = n(50)(0), o = n(7234), a = n(4728), l = n(5345), c = n(3657), u = n(5286), h = n(1616), d = n(1616), p = !r.ActiveXObject && "ActiveXObject"in r, f = "WeakMap", A = a.getWeak, g = Object.isExtensible, m = c.ufstore, v = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            }, y = {
                get: function(t) {
                    if (u(t)) {
                        var e = A(t);
                        return !0 === e ? m(h(this, f)).get(t) : e ? e[this._i] : void 0
                    }
                },
                set: function(t, e) {
                    return c.def(h(this, f), t, e)
                }
            }, _ = t.exports = n(5795)(f, v, y, c, !0, !0);
            d && p && (l((i = c.getConstructor(v, f)).prototype, y),
            a.NEED = !0,
            s(["delete", "has", "get", "set"], (function(t) {
                var e = _.prototype
                  , n = e[t];
                o(e, t, (function(e, r) {
                    if (u(e) && !g(e)) {
                        this._f || (this._f = new i);
                        var s = this._f[t](e, r);
                        return "set" == t ? this : s
                    }
                    return n.call(this, e, r)
                }
                ))
            }
            )))
        },
        9192: function(t, e, n) {
            "use strict";
            var i = n(3657)
              , r = n(1616)
              , s = "WeakSet";
            n(5795)(s, (function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            }
            ), {
                add: function(t) {
                    return i.def(r(this, s), t, !0)
                }
            }, i, !1, !0)
        },
        1268: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(3325)
              , s = n(508)
              , o = n(875)
              , a = n(4963)
              , l = n(6886);
            i(i.P, "Array", {
                flatMap: function(t) {
                    var e, n, i = s(this);
                    return a(t),
                    e = o(i.length),
                    n = l(i, 0),
                    r(n, i, i, e, 0, 1, t, arguments[1]),
                    n
                }
            }),
            n(7722)("flatMap")
        },
        2773: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(9315)(!0);
            i(i.P, "Array", {
                includes: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
                }
            }),
            n(7722)("includes")
        },
        3276: function(t, e, n) {
            var i = n(2985)
              , r = n(1131)(!0);
            i(i.S, "Object", {
                entries: function(t) {
                    return r(t)
                }
            })
        },
        8351: function(t, e, n) {
            var i = n(2985)
              , r = n(7643)
              , s = n(2110)
              , o = n(8693)
              , a = n(2811);
            i(i.S, "Object", {
                getOwnPropertyDescriptors: function(t) {
                    for (var e, n, i = s(t), l = o.f, c = r(i), u = {}, h = 0; c.length > h; )
                        void 0 !== (n = l(i, e = c[h++])) && a(u, e, n);
                    return u
                }
            })
        },
        6409: function(t, e, n) {
            var i = n(2985)
              , r = n(1131)(!1);
            i(i.S, "Object", {
                values: function(t) {
                    return r(t)
                }
            })
        },
        9865: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(5645)
              , s = n(3816)
              , o = n(8364)
              , a = n(94);
            i(i.P + i.R, "Promise", {
                finally: function(t) {
                    var e = o(this, r.Promise || s.Promise)
                      , n = "function" == typeof t;
                    return this.then(n ? function(n) {
                        return a(e, t()).then((function() {
                            return n
                        }
                        ))
                    }
                    : t, n ? function(n) {
                        return a(e, t()).then((function() {
                            throw n
                        }
                        ))
                    }
                    : t)
                }
            })
        },
        2770: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(5442)
              , s = n(575)
              , o = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(s);
            i(i.P + i.F * o, "String", {
                padEnd: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0, !1)
                }
            })
        },
        1784: function(t, e, n) {
            "use strict";
            var i = n(2985)
              , r = n(5442)
              , s = n(575)
              , o = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(s);
            i(i.P + i.F * o, "String", {
                padStart: function(t) {
                    return r(this, t, arguments.length > 1 ? arguments[1] : void 0, !0)
                }
            })
        },
        5869: function(t, e, n) {
            "use strict";
            n(9599)("trimLeft", (function(t) {
                return function() {
                    return t(this, 1)
                }
            }
            ), "trimStart")
        },
        4325: function(t, e, n) {
            "use strict";
            n(9599)("trimRight", (function(t) {
                return function() {
                    return t(this, 2)
                }
            }
            ), "trimEnd")
        },
        9665: function(t, e, n) {
            n(6074)("asyncIterator")
        },
        1181: function(t, e, n) {
            for (var i = n(6997), r = n(7184), s = n(7234), o = n(3816), a = n(7728), l = n(2803), c = n(6314), u = c("iterator"), h = c("toStringTag"), d = l.Array, p = {
                CSSRuleList: !0,
                CSSStyleDeclaration: !1,
                CSSValueList: !1,
                ClientRectList: !1,
                DOMRectList: !1,
                DOMStringList: !1,
                DOMTokenList: !0,
                DataTransferItemList: !1,
                FileList: !1,
                HTMLAllCollection: !1,
                HTMLCollection: !1,
                HTMLFormElement: !1,
                HTMLSelectElement: !1,
                MediaList: !0,
                MimeTypeArray: !1,
                NamedNodeMap: !1,
                NodeList: !0,
                PaintRequestList: !1,
                Plugin: !1,
                PluginArray: !1,
                SVGLengthList: !1,
                SVGNumberList: !1,
                SVGPathSegList: !1,
                SVGPointList: !1,
                SVGStringList: !1,
                SVGTransformList: !1,
                SourceBufferList: !1,
                StyleSheetList: !0,
                TextTrackCueList: !1,
                TextTrackList: !1,
                TouchList: !1
            }, f = r(p), A = 0; A < f.length; A++) {
                var g, m = f[A], v = p[m], y = o[m], _ = y && y.prototype;
                if (_ && (_[u] || a(_, u, d),
                _[h] || a(_, h, m),
                l[m] = d,
                v))
                    for (g in i)
                        _[g] || s(_, g, i[g], !0)
            }
        },
        4633: function(t, e, n) {
            var i = n(2985)
              , r = n(4193);
            i(i.G + i.B, {
                setImmediate: r.set,
                clearImmediate: r.clear
            })
        },
        2564: function(t, e, n) {
            var i = n(3816)
              , r = n(2985)
              , s = n(575)
              , o = [].slice
              , a = /MSIE .\./.test(s)
              , l = function(t) {
                return function(e, n) {
                    var i = arguments.length > 2
                      , r = !!i && o.call(arguments, 2);
                    return t(i ? function() {
                        ("function" == typeof e ? e : Function(e)).apply(this, r)
                    }
                    : e, n)
                }
            };
            r(r.G + r.B + r.F * a, {
                setTimeout: l(i.setTimeout),
                setInterval: l(i.setInterval)
            })
        },
        6337: function(t, e, n) {
            n(2564),
            n(4633),
            n(1181),
            t.exports = n(5645)
        },
        1915: function(t) {
            self,
            t.exports = (()=>{
                var t = {
                    192: (t,e)=>{
                        var n, i, r = function() {
                            var t = function(t, e) {
                                var n = t
                                  , i = o[e]
                                  , r = null
                                  , s = 0
                                  , l = null
                                  , g = []
                                  , m = {}
                                  , y = function(t, e) {
                                    r = function(t) {
                                        for (var e = new Array(t), n = 0; n < t; n += 1) {
                                            e[n] = new Array(t);
                                            for (var i = 0; i < t; i += 1)
                                                e[n][i] = null
                                        }
                                        return e
                                    }(s = 4 * n + 17),
                                    _(0, 0),
                                    _(s - 7, 0),
                                    _(0, s - 7),
                                    b(),
                                    E(),
                                    w(t, e),
                                    n >= 7 && x(t),
                                    null == l && (l = C(n, i, g)),
                                    S(l, e)
                                }
                                  , _ = function(t, e) {
                                    for (var n = -1; n <= 7; n += 1)
                                        if (!(t + n <= -1 || s <= t + n))
                                            for (var i = -1; i <= 7; i += 1)
                                                e + i <= -1 || s <= e + i || (r[t + n][e + i] = 0 <= n && n <= 6 && (0 == i || 6 == i) || 0 <= i && i <= 6 && (0 == n || 6 == n) || 2 <= n && n <= 4 && 2 <= i && i <= 4)
                                }
                                  , E = function() {
                                    for (var t = 8; t < s - 8; t += 1)
                                        null == r[t][6] && (r[t][6] = t % 2 == 0);
                                    for (var e = 8; e < s - 8; e += 1)
                                        null == r[6][e] && (r[6][e] = e % 2 == 0)
                                }
                                  , b = function() {
                                    for (var t = a.getPatternPosition(n), e = 0; e < t.length; e += 1)
                                        for (var i = 0; i < t.length; i += 1) {
                                            var s = t[e]
                                              , o = t[i];
                                            if (null == r[s][o])
                                                for (var l = -2; l <= 2; l += 1)
                                                    for (var c = -2; c <= 2; c += 1)
                                                        r[s + l][o + c] = -2 == l || 2 == l || -2 == c || 2 == c || 0 == l && 0 == c
                                        }
                                }
                                  , x = function(t) {
                                    for (var e = a.getBCHTypeNumber(n), i = 0; i < 18; i += 1) {
                                        var o = !t && 1 == (e >> i & 1);
                                        r[Math.floor(i / 3)][i % 3 + s - 8 - 3] = o
                                    }
                                    for (i = 0; i < 18; i += 1)
                                        o = !t && 1 == (e >> i & 1),
                                        r[i % 3 + s - 8 - 3][Math.floor(i / 3)] = o
                                }
                                  , w = function(t, e) {
                                    for (var n = i << 3 | e, o = a.getBCHTypeInfo(n), l = 0; l < 15; l += 1) {
                                        var c = !t && 1 == (o >> l & 1);
                                        l < 6 ? r[l][8] = c : l < 8 ? r[l + 1][8] = c : r[s - 15 + l][8] = c
                                    }
                                    for (l = 0; l < 15; l += 1)
                                        c = !t && 1 == (o >> l & 1),
                                        l < 8 ? r[8][s - l - 1] = c : l < 9 ? r[8][15 - l - 1 + 1] = c : r[8][15 - l - 1] = c;
                                    r[s - 8][8] = !t
                                }
                                  , S = function(t, e) {
                                    for (var n = -1, i = s - 1, o = 7, l = 0, c = a.getMaskFunction(e), u = s - 1; u > 0; u -= 2)
                                        for (6 == u && (u -= 1); ; ) {
                                            for (var h = 0; h < 2; h += 1)
                                                if (null == r[i][u - h]) {
                                                    var d = !1;
                                                    l < t.length && (d = 1 == (t[l] >>> o & 1)),
                                                    c(i, u - h) && (d = !d),
                                                    r[i][u - h] = d,
                                                    -1 == (o -= 1) && (l += 1,
                                                    o = 7)
                                                }
                                            if ((i += n) < 0 || s <= i) {
                                                i -= n,
                                                n = -n;
                                                break
                                            }
                                        }
                                }
                                  , C = function(t, e, n) {
                                    for (var i = u.getRSBlocks(t, e), r = h(), s = 0; s < n.length; s += 1) {
                                        var o = n[s];
                                        r.put(o.getMode(), 4),
                                        r.put(o.getLength(), a.getLengthInBits(o.getMode(), t)),
                                        o.write(r)
                                    }
                                    var l = 0;
                                    for (s = 0; s < i.length; s += 1)
                                        l += i[s].dataCount;
                                    if (r.getLengthInBits() > 8 * l)
                                        throw "code length overflow. (" + r.getLengthInBits() + ">" + 8 * l + ")";
                                    for (r.getLengthInBits() + 4 <= 8 * l && r.put(0, 4); r.getLengthInBits() % 8 != 0; )
                                        r.putBit(!1);
                                    for (; !(r.getLengthInBits() >= 8 * l || (r.put(236, 8),
                                    r.getLengthInBits() >= 8 * l)); )
                                        r.put(17, 8);
                                    return function(t, e) {
                                        for (var n = 0, i = 0, r = 0, s = new Array(e.length), o = new Array(e.length), l = 0; l < e.length; l += 1) {
                                            var u = e[l].dataCount
                                              , h = e[l].totalCount - u;
                                            i = Math.max(i, u),
                                            r = Math.max(r, h),
                                            s[l] = new Array(u);
                                            for (var d = 0; d < s[l].length; d += 1)
                                                s[l][d] = 255 & t.getBuffer()[d + n];
                                            n += u;
                                            var p = a.getErrorCorrectPolynomial(h)
                                              , f = c(s[l], p.getLength() - 1).mod(p);
                                            for (o[l] = new Array(p.getLength() - 1),
                                            d = 0; d < o[l].length; d += 1) {
                                                var A = d + f.getLength() - o[l].length;
                                                o[l][d] = A >= 0 ? f.getAt(A) : 0
                                            }
                                        }
                                        var g = 0;
                                        for (d = 0; d < e.length; d += 1)
                                            g += e[d].totalCount;
                                        var m = new Array(g)
                                          , v = 0;
                                        for (d = 0; d < i; d += 1)
                                            for (l = 0; l < e.length; l += 1)
                                                d < s[l].length && (m[v] = s[l][d],
                                                v += 1);
                                        for (d = 0; d < r; d += 1)
                                            for (l = 0; l < e.length; l += 1)
                                                d < o[l].length && (m[v] = o[l][d],
                                                v += 1);
                                        return m
                                    }(r, i)
                                };
                                m.addData = function(t, e) {
                                    var n = null;
                                    switch (e = e || "Byte") {
                                    case "Numeric":
                                        n = d(t);
                                        break;
                                    case "Alphanumeric":
                                        n = p(t);
                                        break;
                                    case "Byte":
                                        n = f(t);
                                        break;
                                    case "Kanji":
                                        n = A(t);
                                        break;
                                    default:
                                        throw "mode:" + e
                                    }
                                    g.push(n),
                                    l = null
                                }
                                ,
                                m.isDark = function(t, e) {
                                    if (t < 0 || s <= t || e < 0 || s <= e)
                                        throw t + "," + e;
                                    return r[t][e]
                                }
                                ,
                                m.getModuleCount = function() {
                                    return s
                                }
                                ,
                                m.make = function() {
                                    if (n < 1) {
                                        for (var t = 1; t < 40; t++) {
                                            for (var e = u.getRSBlocks(t, i), r = h(), s = 0; s < g.length; s++) {
                                                var o = g[s];
                                                r.put(o.getMode(), 4),
                                                r.put(o.getLength(), a.getLengthInBits(o.getMode(), t)),
                                                o.write(r)
                                            }
                                            var l = 0;
                                            for (s = 0; s < e.length; s++)
                                                l += e[s].dataCount;
                                            if (r.getLengthInBits() <= 8 * l)
                                                break
                                        }
                                        n = t
                                    }
                                    y(!1, function() {
                                        for (var t = 0, e = 0, n = 0; n < 8; n += 1) {
                                            y(!0, n);
                                            var i = a.getLostPoint(m);
                                            (0 == n || t > i) && (t = i,
                                            e = n)
                                        }
                                        return e
                                    }())
                                }
                                ,
                                m.createTableTag = function(t, e) {
                                    t = t || 2;
                                    var n = "";
                                    n += '<table style="',
                                    n += " border-width: 0px; border-style: none;",
                                    n += " border-collapse: collapse;",
                                    n += " padding: 0px; margin: " + (e = void 0 === e ? 4 * t : e) + "px;",
                                    n += '">',
                                    n += "<tbody>";
                                    for (var i = 0; i < m.getModuleCount(); i += 1) {
                                        n += "<tr>";
                                        for (var r = 0; r < m.getModuleCount(); r += 1)
                                            n += '<td style="',
                                            n += " border-width: 0px; border-style: none;",
                                            n += " border-collapse: collapse;",
                                            n += " padding: 0px; margin: 0px;",
                                            n += " width: " + t + "px;",
                                            n += " height: " + t + "px;",
                                            n += " background-color: ",
                                            n += m.isDark(i, r) ? "#000000" : "#ffffff",
                                            n += ";",
                                            n += '"/>';
                                        n += "</tr>"
                                    }
                                    return (n += "</tbody>") + "</table>"
                                }
                                ,
                                m.createSvgTag = function(t, e, n, i) {
                                    var r = {};
                                    "object" == typeof arguments[0] && (t = (r = arguments[0]).cellSize,
                                    e = r.margin,
                                    n = r.alt,
                                    i = r.title),
                                    t = t || 2,
                                    e = void 0 === e ? 4 * t : e,
                                    (n = "string" == typeof n ? {
                                        text: n
                                    } : n || {}).text = n.text || null,
                                    n.id = n.text ? n.id || "qrcode-description" : null,
                                    (i = "string" == typeof i ? {
                                        text: i
                                    } : i || {}).text = i.text || null,
                                    i.id = i.text ? i.id || "qrcode-title" : null;
                                    var s, o, a, l, c = m.getModuleCount() * t + 2 * e, u = "";
                                    for (l = "l" + t + ",0 0," + t + " -" + t + ",0 0,-" + t + "z ",
                                    u += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                                    u += r.scalable ? "" : ' width="' + c + 'px" height="' + c + 'px"',
                                    u += ' viewBox="0 0 ' + c + " " + c + '" ',
                                    u += ' preserveAspectRatio="xMinYMin meet"',
                                    u += i.text || n.text ? ' role="img" aria-labelledby="' + M([i.id, n.id].join(" ").trim()) + '"' : "",
                                    u += ">",
                                    u += i.text ? '<title id="' + M(i.id) + '">' + M(i.text) + "</title>" : "",
                                    u += n.text ? '<description id="' + M(n.id) + '">' + M(n.text) + "</description>" : "",
                                    u += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                                    u += '<path d="',
                                    o = 0; o < m.getModuleCount(); o += 1)
                                        for (a = o * t + e,
                                        s = 0; s < m.getModuleCount(); s += 1)
                                            m.isDark(o, s) && (u += "M" + (s * t + e) + "," + a + l);
                                    return (u += '" stroke="transparent" fill="black"/>') + "</svg>"
                                }
                                ,
                                m.createDataURL = function(t, e) {
                                    t = t || 2,
                                    e = void 0 === e ? 4 * t : e;
                                    var n = m.getModuleCount() * t + 2 * e
                                      , i = e
                                      , r = n - e;
                                    return v(n, n, (function(e, n) {
                                        if (i <= e && e < r && i <= n && n < r) {
                                            var s = Math.floor((e - i) / t)
                                              , o = Math.floor((n - i) / t);
                                            return m.isDark(o, s) ? 0 : 1
                                        }
                                        return 1
                                    }
                                    ))
                                }
                                ,
                                m.createImgTag = function(t, e, n) {
                                    t = t || 2,
                                    e = void 0 === e ? 4 * t : e;
                                    var i = m.getModuleCount() * t + 2 * e
                                      , r = "";
                                    return r += "<img",
                                    r += ' src="',
                                    r += m.createDataURL(t, e),
                                    r += '"',
                                    r += ' width="',
                                    r += i,
                                    r += '"',
                                    r += ' height="',
                                    r += i,
                                    r += '"',
                                    n && (r += ' alt="',
                                    r += M(n),
                                    r += '"'),
                                    r + "/>"
                                }
                                ;
                                var M = function(t) {
                                    for (var e = "", n = 0; n < t.length; n += 1) {
                                        var i = t.charAt(n);
                                        switch (i) {
                                        case "<":
                                            e += "&lt;";
                                            break;
                                        case ">":
                                            e += "&gt;";
                                            break;
                                        case "&":
                                            e += "&amp;";
                                            break;
                                        case '"':
                                            e += "&quot;";
                                            break;
                                        default:
                                            e += i
                                        }
                                    }
                                    return e
                                };
                                return m.createASCII = function(t, e) {
                                    if ((t = t || 1) < 2)
                                        return function(t) {
                                            t = void 0 === t ? 2 : t;
                                            var e, n, i, r, s, o = 1 * m.getModuleCount() + 2 * t, a = t, l = o - t, c = {
                                                "██": "█",
                                                "█ ": "▀",
                                                " █": "▄",
                                                "  ": " "
                                            }, u = {
                                                "██": "▀",
                                                "█ ": "▀",
                                                " █": " ",
                                                "  ": " "
                                            }, h = "";
                                            for (e = 0; e < o; e += 2) {
                                                for (i = Math.floor((e - a) / 1),
                                                r = Math.floor((e + 1 - a) / 1),
                                                n = 0; n < o; n += 1)
                                                    s = "█",
                                                    a <= n && n < l && a <= e && e < l && m.isDark(i, Math.floor((n - a) / 1)) && (s = " "),
                                                    a <= n && n < l && a <= e + 1 && e + 1 < l && m.isDark(r, Math.floor((n - a) / 1)) ? s += " " : s += "█",
                                                    h += t < 1 && e + 1 >= l ? u[s] : c[s];
                                                h += "\n"
                                            }
                                            return o % 2 && t > 0 ? h.substring(0, h.length - o - 1) + Array(o + 1).join("▀") : h.substring(0, h.length - 1)
                                        }(e);
                                    t -= 1,
                                    e = void 0 === e ? 2 * t : e;
                                    var n, i, r, s, o = m.getModuleCount() * t + 2 * e, a = e, l = o - e, c = Array(t + 1).join("██"), u = Array(t + 1).join("  "), h = "", d = "";
                                    for (n = 0; n < o; n += 1) {
                                        for (r = Math.floor((n - a) / t),
                                        d = "",
                                        i = 0; i < o; i += 1)
                                            s = 1,
                                            a <= i && i < l && a <= n && n < l && m.isDark(r, Math.floor((i - a) / t)) && (s = 0),
                                            d += s ? c : u;
                                        for (r = 0; r < t; r += 1)
                                            h += d + "\n"
                                    }
                                    return h.substring(0, h.length - 1)
                                }
                                ,
                                m.renderTo2dContext = function(t, e) {
                                    e = e || 2;
                                    for (var n = m.getModuleCount(), i = 0; i < n; i++)
                                        for (var r = 0; r < n; r++)
                                            t.fillStyle = m.isDark(i, r) ? "black" : "white",
                                            t.fillRect(i * e, r * e, e, e)
                                }
                                ,
                                m
                            };
                            t.stringToBytes = (t.stringToBytesFuncs = {
                                default: function(t) {
                                    for (var e = [], n = 0; n < t.length; n += 1) {
                                        var i = t.charCodeAt(n);
                                        e.push(255 & i)
                                    }
                                    return e
                                }
                            }).default,
                            t.createStringToBytes = function(t, e) {
                                var n = function() {
                                    for (var n = m(t), i = function() {
                                        var t = n.read();
                                        if (-1 == t)
                                            throw "eof";
                                        return t
                                    }, r = 0, s = {}; ; ) {
                                        var o = n.read();
                                        if (-1 == o)
                                            break;
                                        var a = i()
                                          , l = i() << 8 | i();
                                        s[String.fromCharCode(o << 8 | a)] = l,
                                        r += 1
                                    }
                                    if (r != e)
                                        throw r + " != " + e;
                                    return s
                                }()
                                  , i = "?".charCodeAt(0);
                                return function(t) {
                                    for (var e = [], r = 0; r < t.length; r += 1) {
                                        var s = t.charCodeAt(r);
                                        if (s < 128)
                                            e.push(s);
                                        else {
                                            var o = n[t.charAt(r)];
                                            "number" == typeof o ? (255 & o) == o ? e.push(o) : (e.push(o >>> 8),
                                            e.push(255 & o)) : e.push(i)
                                        }
                                    }
                                    return e
                                }
                            }
                            ;
                            var e, n, i, r, s, o = {
                                L: 1,
                                M: 0,
                                Q: 3,
                                H: 2
                            }, a = (e = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
                            n = 1335,
                            i = 7973,
                            s = function(t) {
                                for (var e = 0; 0 != t; )
                                    e += 1,
                                    t >>>= 1;
                                return e
                            }
                            ,
                            (r = {}).getBCHTypeInfo = function(t) {
                                for (var e = t << 10; s(e) - s(n) >= 0; )
                                    e ^= n << s(e) - s(n);
                                return 21522 ^ (t << 10 | e)
                            }
                            ,
                            r.getBCHTypeNumber = function(t) {
                                for (var e = t << 12; s(e) - s(i) >= 0; )
                                    e ^= i << s(e) - s(i);
                                return t << 12 | e
                            }
                            ,
                            r.getPatternPosition = function(t) {
                                return e[t - 1]
                            }
                            ,
                            r.getMaskFunction = function(t) {
                                switch (t) {
                                case 0:
                                    return function(t, e) {
                                        return (t + e) % 2 == 0
                                    }
                                    ;
                                case 1:
                                    return function(t, e) {
                                        return t % 2 == 0
                                    }
                                    ;
                                case 2:
                                    return function(t, e) {
                                        return e % 3 == 0
                                    }
                                    ;
                                case 3:
                                    return function(t, e) {
                                        return (t + e) % 3 == 0
                                    }
                                    ;
                                case 4:
                                    return function(t, e) {
                                        return (Math.floor(t / 2) + Math.floor(e / 3)) % 2 == 0
                                    }
                                    ;
                                case 5:
                                    return function(t, e) {
                                        return t * e % 2 + t * e % 3 == 0
                                    }
                                    ;
                                case 6:
                                    return function(t, e) {
                                        return (t * e % 2 + t * e % 3) % 2 == 0
                                    }
                                    ;
                                case 7:
                                    return function(t, e) {
                                        return (t * e % 3 + (t + e) % 2) % 2 == 0
                                    }
                                    ;
                                default:
                                    throw "bad maskPattern:" + t
                                }
                            }
                            ,
                            r.getErrorCorrectPolynomial = function(t) {
                                for (var e = c([1], 0), n = 0; n < t; n += 1)
                                    e = e.multiply(c([1, l.gexp(n)], 0));
                                return e
                            }
                            ,
                            r.getLengthInBits = function(t, e) {
                                if (1 <= e && e < 10)
                                    switch (t) {
                                    case 1:
                                        return 10;
                                    case 2:
                                        return 9;
                                    case 4:
                                    case 8:
                                        return 8;
                                    default:
                                        throw "mode:" + t
                                    }
                                else if (e < 27)
                                    switch (t) {
                                    case 1:
                                        return 12;
                                    case 2:
                                        return 11;
                                    case 4:
                                        return 16;
                                    case 8:
                                        return 10;
                                    default:
                                        throw "mode:" + t
                                    }
                                else {
                                    if (!(e < 41))
                                        throw "type:" + e;
                                    switch (t) {
                                    case 1:
                                        return 14;
                                    case 2:
                                        return 13;
                                    case 4:
                                        return 16;
                                    case 8:
                                        return 12;
                                    default:
                                        throw "mode:" + t
                                    }
                                }
                            }
                            ,
                            r.getLostPoint = function(t) {
                                for (var e = t.getModuleCount(), n = 0, i = 0; i < e; i += 1)
                                    for (var r = 0; r < e; r += 1) {
                                        for (var s = 0, o = t.isDark(i, r), a = -1; a <= 1; a += 1)
                                            if (!(i + a < 0 || e <= i + a))
                                                for (var l = -1; l <= 1; l += 1)
                                                    r + l < 0 || e <= r + l || 0 == a && 0 == l || o == t.isDark(i + a, r + l) && (s += 1);
                                        s > 5 && (n += 3 + s - 5)
                                    }
                                for (i = 0; i < e - 1; i += 1)
                                    for (r = 0; r < e - 1; r += 1) {
                                        var c = 0;
                                        t.isDark(i, r) && (c += 1),
                                        t.isDark(i + 1, r) && (c += 1),
                                        t.isDark(i, r + 1) && (c += 1),
                                        t.isDark(i + 1, r + 1) && (c += 1),
                                        0 != c && 4 != c || (n += 3)
                                    }
                                for (i = 0; i < e; i += 1)
                                    for (r = 0; r < e - 6; r += 1)
                                        t.isDark(i, r) && !t.isDark(i, r + 1) && t.isDark(i, r + 2) && t.isDark(i, r + 3) && t.isDark(i, r + 4) && !t.isDark(i, r + 5) && t.isDark(i, r + 6) && (n += 40);
                                for (r = 0; r < e; r += 1)
                                    for (i = 0; i < e - 6; i += 1)
                                        t.isDark(i, r) && !t.isDark(i + 1, r) && t.isDark(i + 2, r) && t.isDark(i + 3, r) && t.isDark(i + 4, r) && !t.isDark(i + 5, r) && t.isDark(i + 6, r) && (n += 40);
                                var u = 0;
                                for (r = 0; r < e; r += 1)
                                    for (i = 0; i < e; i += 1)
                                        t.isDark(i, r) && (u += 1);
                                return n + Math.abs(100 * u / e / e - 50) / 5 * 10
                            }
                            ,
                            r), l = function() {
                                for (var t = new Array(256), e = new Array(256), n = 0; n < 8; n += 1)
                                    t[n] = 1 << n;
                                for (n = 8; n < 256; n += 1)
                                    t[n] = t[n - 4] ^ t[n - 5] ^ t[n - 6] ^ t[n - 8];
                                for (n = 0; n < 255; n += 1)
                                    e[t[n]] = n;
                                return {
                                    glog: function(t) {
                                        if (t < 1)
                                            throw "glog(" + t + ")";
                                        return e[t]
                                    },
                                    gexp: function(e) {
                                        for (; e < 0; )
                                            e += 255;
                                        for (; e >= 256; )
                                            e -= 255;
                                        return t[e]
                                    }
                                }
                            }();
                            function c(t, e) {
                                if (void 0 === t.length)
                                    throw t.length + "/" + e;
                                var n = function() {
                                    for (var n = 0; n < t.length && 0 == t[n]; )
                                        n += 1;
                                    for (var i = new Array(t.length - n + e), r = 0; r < t.length - n; r += 1)
                                        i[r] = t[r + n];
                                    return i
                                }()
                                  , i = {
                                    getAt: function(t) {
                                        return n[t]
                                    },
                                    getLength: function() {
                                        return n.length
                                    },
                                    multiply: function(t) {
                                        for (var e = new Array(i.getLength() + t.getLength() - 1), n = 0; n < i.getLength(); n += 1)
                                            for (var r = 0; r < t.getLength(); r += 1)
                                                e[n + r] ^= l.gexp(l.glog(i.getAt(n)) + l.glog(t.getAt(r)));
                                        return c(e, 0)
                                    },
                                    mod: function(t) {
                                        if (i.getLength() - t.getLength() < 0)
                                            return i;
                                        for (var e = l.glog(i.getAt(0)) - l.glog(t.getAt(0)), n = new Array(i.getLength()), r = 0; r < i.getLength(); r += 1)
                                            n[r] = i.getAt(r);
                                        for (r = 0; r < t.getLength(); r += 1)
                                            n[r] ^= l.gexp(l.glog(t.getAt(r)) + e);
                                        return c(n, 0).mod(t)
                                    }
                                };
                                return i
                            }
                            var u = function() {
                                var t = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
                                  , e = function(t, e) {
                                    var n = {};
                                    return n.totalCount = t,
                                    n.dataCount = e,
                                    n
                                }
                                  , n = {
                                    getRSBlocks: function(n, i) {
                                        var r = function(e, n) {
                                            switch (n) {
                                            case o.L:
                                                return t[4 * (e - 1) + 0];
                                            case o.M:
                                                return t[4 * (e - 1) + 1];
                                            case o.Q:
                                                return t[4 * (e - 1) + 2];
                                            case o.H:
                                                return t[4 * (e - 1) + 3];
                                            default:
                                                return
                                            }
                                        }(n, i);
                                        if (void 0 === r)
                                            throw "bad rs block @ typeNumber:" + n + "/errorCorrectionLevel:" + i;
                                        for (var s = r.length / 3, a = [], l = 0; l < s; l += 1)
                                            for (var c = r[3 * l + 0], u = r[3 * l + 1], h = r[3 * l + 2], d = 0; d < c; d += 1)
                                                a.push(e(u, h));
                                        return a
                                    }
                                };
                                return n
                            }()
                              , h = function() {
                                var t = []
                                  , e = 0
                                  , n = {
                                    getBuffer: function() {
                                        return t
                                    },
                                    getAt: function(e) {
                                        var n = Math.floor(e / 8);
                                        return 1 == (t[n] >>> 7 - e % 8 & 1)
                                    },
                                    put: function(t, e) {
                                        for (var i = 0; i < e; i += 1)
                                            n.putBit(1 == (t >>> e - i - 1 & 1))
                                    },
                                    getLengthInBits: function() {
                                        return e
                                    },
                                    putBit: function(n) {
                                        var i = Math.floor(e / 8);
                                        t.length <= i && t.push(0),
                                        n && (t[i] |= 128 >>> e % 8),
                                        e += 1
                                    }
                                };
                                return n
                            }
                              , d = function(t) {
                                var e = t
                                  , n = {
                                    getMode: function() {
                                        return 1
                                    },
                                    getLength: function(t) {
                                        return e.length
                                    },
                                    write: function(t) {
                                        for (var n = e, r = 0; r + 2 < n.length; )
                                            t.put(i(n.substring(r, r + 3)), 10),
                                            r += 3;
                                        r < n.length && (n.length - r == 1 ? t.put(i(n.substring(r, r + 1)), 4) : n.length - r == 2 && t.put(i(n.substring(r, r + 2)), 7))
                                    }
                                }
                                  , i = function(t) {
                                    for (var e = 0, n = 0; n < t.length; n += 1)
                                        e = 10 * e + r(t.charAt(n));
                                    return e
                                }
                                  , r = function(t) {
                                    if ("0" <= t && t <= "9")
                                        return t.charCodeAt(0) - "0".charCodeAt(0);
                                    throw "illegal char :" + t
                                };
                                return n
                            }
                              , p = function(t) {
                                var e = t
                                  , n = {
                                    getMode: function() {
                                        return 2
                                    },
                                    getLength: function(t) {
                                        return e.length
                                    },
                                    write: function(t) {
                                        for (var n = e, r = 0; r + 1 < n.length; )
                                            t.put(45 * i(n.charAt(r)) + i(n.charAt(r + 1)), 11),
                                            r += 2;
                                        r < n.length && t.put(i(n.charAt(r)), 6)
                                    }
                                }
                                  , i = function(t) {
                                    if ("0" <= t && t <= "9")
                                        return t.charCodeAt(0) - "0".charCodeAt(0);
                                    if ("A" <= t && t <= "Z")
                                        return t.charCodeAt(0) - "A".charCodeAt(0) + 10;
                                    switch (t) {
                                    case " ":
                                        return 36;
                                    case "$":
                                        return 37;
                                    case "%":
                                        return 38;
                                    case "*":
                                        return 39;
                                    case "+":
                                        return 40;
                                    case "-":
                                        return 41;
                                    case ".":
                                        return 42;
                                    case "/":
                                        return 43;
                                    case ":":
                                        return 44;
                                    default:
                                        throw "illegal char :" + t
                                    }
                                };
                                return n
                            }
                              , f = function(e) {
                                var n = t.stringToBytes(e);
                                return {
                                    getMode: function() {
                                        return 4
                                    },
                                    getLength: function(t) {
                                        return n.length
                                    },
                                    write: function(t) {
                                        for (var e = 0; e < n.length; e += 1)
                                            t.put(n[e], 8)
                                    }
                                }
                            }
                              , A = function(e) {
                                var n = t.stringToBytesFuncs.SJIS;
                                if (!n)
                                    throw "sjis not supported.";
                                !function(t, e) {
                                    var i = n("友");
                                    if (2 != i.length || 38726 != (i[0] << 8 | i[1]))
                                        throw "sjis not supported."
                                }();
                                var i = n(e);
                                return {
                                    getMode: function() {
                                        return 8
                                    },
                                    getLength: function(t) {
                                        return ~~(i.length / 2)
                                    },
                                    write: function(t) {
                                        for (var e = i, n = 0; n + 1 < e.length; ) {
                                            var r = (255 & e[n]) << 8 | 255 & e[n + 1];
                                            if (33088 <= r && r <= 40956)
                                                r -= 33088;
                                            else {
                                                if (!(57408 <= r && r <= 60351))
                                                    throw "illegal char at " + (n + 1) + "/" + r;
                                                r -= 49472
                                            }
                                            r = 192 * (r >>> 8 & 255) + (255 & r),
                                            t.put(r, 13),
                                            n += 2
                                        }
                                        if (n < e.length)
                                            throw "illegal char at " + (n + 1)
                                    }
                                }
                            }
                              , g = function() {
                                var t = []
                                  , e = {
                                    writeByte: function(e) {
                                        t.push(255 & e)
                                    },
                                    writeShort: function(t) {
                                        e.writeByte(t),
                                        e.writeByte(t >>> 8)
                                    },
                                    writeBytes: function(t, n, i) {
                                        n = n || 0,
                                        i = i || t.length;
                                        for (var r = 0; r < i; r += 1)
                                            e.writeByte(t[r + n])
                                    },
                                    writeString: function(t) {
                                        for (var n = 0; n < t.length; n += 1)
                                            e.writeByte(t.charCodeAt(n))
                                    },
                                    toByteArray: function() {
                                        return t
                                    },
                                    toString: function() {
                                        var e = "";
                                        e += "[";
                                        for (var n = 0; n < t.length; n += 1)
                                            n > 0 && (e += ","),
                                            e += t[n];
                                        return e + "]"
                                    }
                                };
                                return e
                            }
                              , m = function(t) {
                                var e = t
                                  , n = 0
                                  , i = 0
                                  , r = 0
                                  , s = {
                                    read: function() {
                                        for (; r < 8; ) {
                                            if (n >= e.length) {
                                                if (0 == r)
                                                    return -1;
                                                throw "unexpected end of file./" + r
                                            }
                                            var t = e.charAt(n);
                                            if (n += 1,
                                            "=" == t)
                                                return r = 0,
                                                -1;
                                            t.match(/^\s$/) || (i = i << 6 | o(t.charCodeAt(0)),
                                            r += 6)
                                        }
                                        var s = i >>> r - 8 & 255;
                                        return r -= 8,
                                        s
                                    }
                                }
                                  , o = function(t) {
                                    if (65 <= t && t <= 90)
                                        return t - 65;
                                    if (97 <= t && t <= 122)
                                        return t - 97 + 26;
                                    if (48 <= t && t <= 57)
                                        return t - 48 + 52;
                                    if (43 == t)
                                        return 62;
                                    if (47 == t)
                                        return 63;
                                    throw "c:" + t
                                };
                                return s
                            }
                              , v = function(t, e, n) {
                                for (var i = function(t, e) {
                                    var n = t
                                      , i = e
                                      , r = new Array(t * e)
                                      , s = {
                                        setPixel: function(t, e, i) {
                                            r[e * n + t] = i
                                        },
                                        write: function(t) {
                                            t.writeString("GIF87a"),
                                            t.writeShort(n),
                                            t.writeShort(i),
                                            t.writeByte(128),
                                            t.writeByte(0),
                                            t.writeByte(0),
                                            t.writeByte(0),
                                            t.writeByte(0),
                                            t.writeByte(0),
                                            t.writeByte(255),
                                            t.writeByte(255),
                                            t.writeByte(255),
                                            t.writeString(","),
                                            t.writeShort(0),
                                            t.writeShort(0),
                                            t.writeShort(n),
                                            t.writeShort(i),
                                            t.writeByte(0);
                                            var e = o(2);
                                            t.writeByte(2);
                                            for (var r = 0; e.length - r > 255; )
                                                t.writeByte(255),
                                                t.writeBytes(e, r, 255),
                                                r += 255;
                                            t.writeByte(e.length - r),
                                            t.writeBytes(e, r, e.length - r),
                                            t.writeByte(0),
                                            t.writeString(";")
                                        }
                                    }
                                      , o = function(t) {
                                        for (var e = 1 << t, n = 1 + (1 << t), i = t + 1, s = a(), o = 0; o < e; o += 1)
                                            s.add(String.fromCharCode(o));
                                        s.add(String.fromCharCode(e)),
                                        s.add(String.fromCharCode(n));
                                        var l, c, u, h = g(), d = (l = h,
                                        c = 0,
                                        u = 0,
                                        {
                                            write: function(t, e) {
                                                if (t >>> e != 0)
                                                    throw "length over";
                                                for (; c + e >= 8; )
                                                    l.writeByte(255 & (t << c | u)),
                                                    e -= 8 - c,
                                                    t >>>= 8 - c,
                                                    u = 0,
                                                    c = 0;
                                                u |= t << c,
                                                c += e
                                            },
                                            flush: function() {
                                                c > 0 && l.writeByte(u)
                                            }
                                        });
                                        d.write(e, i);
                                        var p = 0
                                          , f = String.fromCharCode(r[p]);
                                        for (p += 1; p < r.length; ) {
                                            var A = String.fromCharCode(r[p]);
                                            p += 1,
                                            s.contains(f + A) ? f += A : (d.write(s.indexOf(f), i),
                                            s.size() < 4095 && (s.size() == 1 << i && (i += 1),
                                            s.add(f + A)),
                                            f = A)
                                        }
                                        return d.write(s.indexOf(f), i),
                                        d.write(n, i),
                                        d.flush(),
                                        h.toByteArray()
                                    }
                                      , a = function() {
                                        var t = {}
                                          , e = 0
                                          , n = {
                                            add: function(i) {
                                                if (n.contains(i))
                                                    throw "dup key:" + i;
                                                t[i] = e,
                                                e += 1
                                            },
                                            size: function() {
                                                return e
                                            },
                                            indexOf: function(e) {
                                                return t[e]
                                            },
                                            contains: function(e) {
                                                return void 0 !== t[e]
                                            }
                                        };
                                        return n
                                    };
                                    return s
                                }(t, e), r = 0; r < e; r += 1)
                                    for (var s = 0; s < t; s += 1)
                                        i.setPixel(s, r, n(s, r));
                                var o = g();
                                i.write(o);
                                for (var a = function() {
                                    var t = 0
                                      , e = 0
                                      , n = 0
                                      , i = ""
                                      , r = {}
                                      , s = function(t) {
                                        i += String.fromCharCode(o(63 & t))
                                    }
                                      , o = function(t) {
                                        if (t < 0)
                                            ;
                                        else {
                                            if (t < 26)
                                                return 65 + t;
                                            if (t < 52)
                                                return t - 26 + 97;
                                            if (t < 62)
                                                return t - 52 + 48;
                                            if (62 == t)
                                                return 43;
                                            if (63 == t)
                                                return 47
                                        }
                                        throw "n:" + t
                                    };
                                    return r.writeByte = function(i) {
                                        for (t = t << 8 | 255 & i,
                                        e += 8,
                                        n += 1; e >= 6; )
                                            s(t >>> e - 6),
                                            e -= 6
                                    }
                                    ,
                                    r.flush = function() {
                                        if (e > 0 && (s(t << 6 - e),
                                        t = 0,
                                        e = 0),
                                        n % 3 != 0)
                                            for (var r = 3 - n % 3, o = 0; o < r; o += 1)
                                                i += "="
                                    }
                                    ,
                                    r.toString = function() {
                                        return i
                                    }
                                    ,
                                    r
                                }(), l = o.toByteArray(), c = 0; c < l.length; c += 1)
                                    a.writeByte(l[c]);
                                return a.flush(),
                                "data:image/gif;base64," + a
                            };
                            return t
                        }();
                        r.stringToBytesFuncs["UTF-8"] = function(t) {
                            return function(t) {
                                for (var e = [], n = 0; n < t.length; n++) {
                                    var i = t.charCodeAt(n);
                                    i < 128 ? e.push(i) : i < 2048 ? e.push(192 | i >> 6, 128 | 63 & i) : i < 55296 || i >= 57344 ? e.push(224 | i >> 12, 128 | i >> 6 & 63, 128 | 63 & i) : (n++,
                                    i = 65536 + ((1023 & i) << 10 | 1023 & t.charCodeAt(n)),
                                    e.push(240 | i >> 18, 128 | i >> 12 & 63, 128 | i >> 6 & 63, 128 | 63 & i))
                                }
                                return e
                            }(t)
                        }
                        ,
                        void 0 === (i = "function" == typeof (n = function() {
                            return r
                        }
                        ) ? n.apply(e, []) : n) || (t.exports = i)
                    }
                    ,
                    676: (t,e,n)=>{
                        "use strict";
                        n.d(e, {
                            default: ()=>D
                        });
                        var i = function() {
                            return (i = Object.assign || function(t) {
                                for (var e, n = 1, i = arguments.length; n < i; n++)
                                    for (var r in e = arguments[n])
                                        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                                return t
                            }
                            ).apply(this, arguments)
                        }
                          , r = function() {
                            for (var t = 0, e = 0, n = arguments.length; e < n; e++)
                                t += arguments[e].length;
                            var i = Array(t)
                              , r = 0;
                            for (e = 0; e < n; e++)
                                for (var s = arguments[e], o = 0, a = s.length; o < a; o++,
                                r++)
                                    i[r] = s[o];
                            return i
                        }
                          , s = function(t) {
                            return !!t && "object" == typeof t && !Array.isArray(t)
                        };
                        function o(t) {
                            for (var e = [], n = 1; n < arguments.length; n++)
                                e[n - 1] = arguments[n];
                            if (!e.length)
                                return t;
                            var a = e.shift();
                            return void 0 !== a && s(t) && s(a) ? (t = i({}, t),
                            Object.keys(a).forEach((function(e) {
                                var n = t[e]
                                  , i = a[e];
                                Array.isArray(n) && Array.isArray(i) ? t[e] = i : s(n) && s(i) ? t[e] = o(Object.assign({}, n), i) : t[e] = i
                            }
                            )),
                            o.apply(void 0, r([t], e))) : t
                        }
                        function a(t, e) {
                            var n = document.createElement("a");
                            n.download = e,
                            n.href = t,
                            document.body.appendChild(n),
                            n.click(),
                            document.body.removeChild(n)
                        }
                        function l(t) {
                            return e = this,
                            n = void 0,
                            r = function() {
                                return function(t, e) {
                                    var n, i, r, s, o = {
                                        label: 0,
                                        sent: function() {
                                            if (1 & r[0])
                                                throw r[1];
                                            return r[1]
                                        },
                                        trys: [],
                                        ops: []
                                    };
                                    return s = {
                                        next: a(0),
                                        throw: a(1),
                                        return: a(2)
                                    },
                                    "function" == typeof Symbol && (s[Symbol.iterator] = function() {
                                        return this
                                    }
                                    ),
                                    s;
                                    function a(s) {
                                        return function(a) {
                                            return function(s) {
                                                if (n)
                                                    throw new TypeError("Generator is already executing.");
                                                for (; o; )
                                                    try {
                                                        if (n = 1,
                                                        i && (r = 2 & s[0] ? i.return : s[0] ? i.throw || ((r = i.return) && r.call(i),
                                                        0) : i.next) && !(r = r.call(i, s[1])).done)
                                                            return r;
                                                        switch (i = 0,
                                                        r && (s = [2 & s[0], r.value]),
                                                        s[0]) {
                                                        case 0:
                                                        case 1:
                                                            r = s;
                                                            break;
                                                        case 4:
                                                            return o.label++,
                                                            {
                                                                value: s[1],
                                                                done: !1
                                                            };
                                                        case 5:
                                                            o.label++,
                                                            i = s[1],
                                                            s = [0];
                                                            continue;
                                                        case 7:
                                                            s = o.ops.pop(),
                                                            o.trys.pop();
                                                            continue;
                                                        default:
                                                            if (!((r = (r = o.trys).length > 0 && r[r.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                                o = 0;
                                                                continue
                                                            }
                                                            if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                                                                o.label = s[1];
                                                                break
                                                            }
                                                            if (6 === s[0] && o.label < r[1]) {
                                                                o.label = r[1],
                                                                r = s;
                                                                break
                                                            }
                                                            if (r && o.label < r[2]) {
                                                                o.label = r[2],
                                                                o.ops.push(s);
                                                                break
                                                            }
                                                            r[2] && o.ops.pop(),
                                                            o.trys.pop();
                                                            continue
                                                        }
                                                        s = e.call(t, o)
                                                    } catch (t) {
                                                        s = [6, t],
                                                        i = 0
                                                    } finally {
                                                        n = r = 0
                                                    }
                                                if (5 & s[0])
                                                    throw s[1];
                                                return {
                                                    value: s[0] ? s[1] : void 0,
                                                    done: !0
                                                }
                                            }([s, a])
                                        }
                                    }
                                }(this, (function(e) {
                                    return [2, new Promise((function(e) {
                                        var n = new XMLHttpRequest;
                                        n.onload = function() {
                                            var t = new FileReader;
                                            t.onloadend = function() {
                                                e(t.result)
                                            }
                                            ,
                                            t.readAsDataURL(n.response)
                                        }
                                        ,
                                        n.open("GET", t),
                                        n.responseType = "blob",
                                        n.send()
                                    }
                                    ))]
                                }
                                ))
                            }
                            ,
                            new ((i = void 0) || (i = Promise))((function(t, s) {
                                function o(t) {
                                    try {
                                        l(r.next(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function a(t) {
                                    try {
                                        l(r.throw(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function l(e) {
                                    var n;
                                    e.done ? t(e.value) : (n = e.value,
                                    n instanceof i ? n : new i((function(t) {
                                        t(n)
                                    }
                                    ))).then(o, a)
                                }
                                l((r = r.apply(e, n || [])).next())
                            }
                            ));
                            var e, n, i, r
                        }
                        const c = {
                            L: .07,
                            M: .15,
                            Q: .25,
                            H: .3
                        };
                        var u = function() {
                            return (u = Object.assign || function(t) {
                                for (var e, n = 1, i = arguments.length; n < i; n++)
                                    for (var r in e = arguments[n])
                                        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                                return t
                            }
                            ).apply(this, arguments)
                        };
                        const h = function() {
                            function t(t) {
                                var e = t.svg
                                  , n = t.type;
                                this._svg = e,
                                this._type = n
                            }
                            return t.prototype.draw = function(t, e, n, i) {
                                var r;
                                switch (this._type) {
                                case "dots":
                                    r = this._drawDot;
                                    break;
                                case "classy":
                                    r = this._drawClassy;
                                    break;
                                case "classy-rounded":
                                    r = this._drawClassyRounded;
                                    break;
                                case "rounded":
                                    r = this._drawRounded;
                                    break;
                                case "extra-rounded":
                                    r = this._drawExtraRounded;
                                    break;
                                default:
                                    r = this._drawSquare
                                }
                                r.call(this, {
                                    x: t,
                                    y: e,
                                    size: n,
                                    getNeighbor: i
                                })
                            }
                            ,
                            t.prototype._rotateFigure = function(t) {
                                var e, n = t.x, i = t.y, r = t.size, s = t.rotation, o = void 0 === s ? 0 : s, a = n + r / 2, l = i + r / 2;
                                (0,
                                t.draw)(),
                                null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * o / Math.PI + "," + a + "," + l + ")")
                            }
                            ,
                            t.prototype._basicDot = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"),
                                        e._element.setAttribute("cx", String(i + n / 2)),
                                        e._element.setAttribute("cy", String(r + n / 2)),
                                        e._element.setAttribute("r", String(n / 2))
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicSquare = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"),
                                        e._element.setAttribute("x", String(i)),
                                        e._element.setAttribute("y", String(r)),
                                        e._element.setAttribute("width", String(n)),
                                        e._element.setAttribute("height", String(n))
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicSideRounded = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("d", "M " + i + " " + r + "v " + n + "h " + n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, 0 " + -n)
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicCornerRounded = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("d", "M " + i + " " + r + "v " + n + "h " + n + "v " + -n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + -n / 2 + " " + -n / 2)
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicCornerExtraRounded = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("d", "M " + i + " " + r + "v " + n + "h " + n + "a " + n + " " + n + ", 0, 0, 0, " + -n + " " + -n)
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicCornersRounded = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(u(u({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("d", "M " + i + " " + r + "v " + n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + n / 2 + " " + n / 2 + "h " + n / 2 + "v " + -n / 2 + "a " + n / 2 + " " + n / 2 + ", 0, 0, 0, " + -n / 2 + " " + -n / 2)
                                    }
                                }))
                            }
                            ,
                            t.prototype._drawDot = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size;
                                this._basicDot({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: 0
                                })
                            }
                            ,
                            t.prototype._drawSquare = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size;
                                this._basicSquare({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: 0
                                })
                            }
                            ,
                            t.prototype._drawRounded = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.getNeighbor
                                  , s = r ? +r(-1, 0) : 0
                                  , o = r ? +r(1, 0) : 0
                                  , a = r ? +r(0, -1) : 0
                                  , l = r ? +r(0, 1) : 0
                                  , c = s + o + a + l;
                                if (0 !== c)
                                    if (c > 2 || s && o || a && l)
                                        this._basicSquare({
                                            x: e,
                                            y: n,
                                            size: i,
                                            rotation: 0
                                        });
                                    else {
                                        if (2 === c) {
                                            var u = 0;
                                            return s && a ? u = Math.PI / 2 : a && o ? u = Math.PI : o && l && (u = -Math.PI / 2),
                                            void this._basicCornerRounded({
                                                x: e,
                                                y: n,
                                                size: i,
                                                rotation: u
                                            })
                                        }
                                        if (1 === c)
                                            return u = 0,
                                            a ? u = Math.PI / 2 : o ? u = Math.PI : l && (u = -Math.PI / 2),
                                            void this._basicSideRounded({
                                                x: e,
                                                y: n,
                                                size: i,
                                                rotation: u
                                            })
                                    }
                                else
                                    this._basicDot({
                                        x: e,
                                        y: n,
                                        size: i,
                                        rotation: 0
                                    })
                            }
                            ,
                            t.prototype._drawExtraRounded = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.getNeighbor
                                  , s = r ? +r(-1, 0) : 0
                                  , o = r ? +r(1, 0) : 0
                                  , a = r ? +r(0, -1) : 0
                                  , l = r ? +r(0, 1) : 0
                                  , c = s + o + a + l;
                                if (0 !== c)
                                    if (c > 2 || s && o || a && l)
                                        this._basicSquare({
                                            x: e,
                                            y: n,
                                            size: i,
                                            rotation: 0
                                        });
                                    else {
                                        if (2 === c) {
                                            var u = 0;
                                            return s && a ? u = Math.PI / 2 : a && o ? u = Math.PI : o && l && (u = -Math.PI / 2),
                                            void this._basicCornerExtraRounded({
                                                x: e,
                                                y: n,
                                                size: i,
                                                rotation: u
                                            })
                                        }
                                        if (1 === c)
                                            return u = 0,
                                            a ? u = Math.PI / 2 : o ? u = Math.PI : l && (u = -Math.PI / 2),
                                            void this._basicSideRounded({
                                                x: e,
                                                y: n,
                                                size: i,
                                                rotation: u
                                            })
                                    }
                                else
                                    this._basicDot({
                                        x: e,
                                        y: n,
                                        size: i,
                                        rotation: 0
                                    })
                            }
                            ,
                            t.prototype._drawClassy = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.getNeighbor
                                  , s = r ? +r(-1, 0) : 0
                                  , o = r ? +r(1, 0) : 0
                                  , a = r ? +r(0, -1) : 0
                                  , l = r ? +r(0, 1) : 0;
                                0 !== s + o + a + l ? s || a ? o || l ? this._basicSquare({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: 0
                                }) : this._basicCornerRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: Math.PI / 2
                                }) : this._basicCornerRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: -Math.PI / 2
                                }) : this._basicCornersRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: Math.PI / 2
                                })
                            }
                            ,
                            t.prototype._drawClassyRounded = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.getNeighbor
                                  , s = r ? +r(-1, 0) : 0
                                  , o = r ? +r(1, 0) : 0
                                  , a = r ? +r(0, -1) : 0
                                  , l = r ? +r(0, 1) : 0;
                                0 !== s + o + a + l ? s || a ? o || l ? this._basicSquare({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: 0
                                }) : this._basicCornerExtraRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: Math.PI / 2
                                }) : this._basicCornerExtraRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: -Math.PI / 2
                                }) : this._basicCornersRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: Math.PI / 2
                                })
                            }
                            ,
                            t
                        }();
                        var d = function() {
                            return (d = Object.assign || function(t) {
                                for (var e, n = 1, i = arguments.length; n < i; n++)
                                    for (var r in e = arguments[n])
                                        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                                return t
                            }
                            ).apply(this, arguments)
                        };
                        const p = function() {
                            function t(t) {
                                var e = t.svg
                                  , n = t.type;
                                this._svg = e,
                                this._type = n
                            }
                            return t.prototype.draw = function(t, e, n, i) {
                                var r;
                                switch (this._type) {
                                case "square":
                                    r = this._drawSquare;
                                    break;
                                case "extra-rounded":
                                    r = this._drawExtraRounded;
                                    break;
                                default:
                                    r = this._drawDot
                                }
                                r.call(this, {
                                    x: t,
                                    y: e,
                                    size: n,
                                    rotation: i
                                })
                            }
                            ,
                            t.prototype._rotateFigure = function(t) {
                                var e, n = t.x, i = t.y, r = t.size, s = t.rotation, o = void 0 === s ? 0 : s, a = n + r / 2, l = i + r / 2;
                                (0,
                                t.draw)(),
                                null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * o / Math.PI + "," + a + "," + l + ")")
                            }
                            ,
                            t.prototype._basicDot = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y
                                  , s = n / 7;
                                this._rotateFigure(d(d({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("clip-rule", "evenodd"),
                                        e._element.setAttribute("d", "M " + (i + n / 2) + " " + r + "a " + n / 2 + " " + n / 2 + " 0 1 0 0.1 0zm 0 " + s + "a " + (n / 2 - s) + " " + (n / 2 - s) + " 0 1 1 -0.1 0Z")
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicSquare = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y
                                  , s = n / 7;
                                this._rotateFigure(d(d({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("clip-rule", "evenodd"),
                                        e._element.setAttribute("d", "M " + i + " " + r + "v " + n + "h " + n + "v " + -n + "zM " + (i + s) + " " + (r + s) + "h " + (n - 2 * s) + "v " + (n - 2 * s) + "h " + (2 * s - n) + "z")
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicExtraRounded = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y
                                  , s = n / 7;
                                this._rotateFigure(d(d({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                                        e._element.setAttribute("clip-rule", "evenodd"),
                                        e._element.setAttribute("d", "M " + i + " " + (r + 2.5 * s) + "v " + 2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * s + " " + 2.5 * s + "h " + 2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * s + " " + 2.5 * -s + "v " + -2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * -s + " " + 2.5 * -s + "h " + -2 * s + "a " + 2.5 * s + " " + 2.5 * s + ", 0, 0, 0, " + 2.5 * -s + " " + 2.5 * s + "M " + (i + 2.5 * s) + " " + (r + s) + "h " + 2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * s + " " + 1.5 * s + "v " + 2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * -s + " " + 1.5 * s + "h " + -2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * -s + " " + 1.5 * -s + "v " + -2 * s + "a " + 1.5 * s + " " + 1.5 * s + ", 0, 0, 1, " + 1.5 * s + " " + 1.5 * -s)
                                    }
                                }))
                            }
                            ,
                            t.prototype._drawDot = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.rotation;
                                this._basicDot({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: r
                                })
                            }
                            ,
                            t.prototype._drawSquare = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.rotation;
                                this._basicSquare({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: r
                                })
                            }
                            ,
                            t.prototype._drawExtraRounded = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.rotation;
                                this._basicExtraRounded({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: r
                                })
                            }
                            ,
                            t
                        }();
                        var f = function() {
                            return (f = Object.assign || function(t) {
                                for (var e, n = 1, i = arguments.length; n < i; n++)
                                    for (var r in e = arguments[n])
                                        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                                return t
                            }
                            ).apply(this, arguments)
                        };
                        const A = function() {
                            function t(t) {
                                var e = t.svg
                                  , n = t.type;
                                this._svg = e,
                                this._type = n
                            }
                            return t.prototype.draw = function(t, e, n, i) {
                                ("square" === this._type ? this._drawSquare : this._drawDot).call(this, {
                                    x: t,
                                    y: e,
                                    size: n,
                                    rotation: i
                                })
                            }
                            ,
                            t.prototype._rotateFigure = function(t) {
                                var e, n = t.x, i = t.y, r = t.size, s = t.rotation, o = void 0 === s ? 0 : s, a = n + r / 2, l = i + r / 2;
                                (0,
                                t.draw)(),
                                null === (e = this._element) || void 0 === e || e.setAttribute("transform", "rotate(" + 180 * o / Math.PI + "," + a + "," + l + ")")
                            }
                            ,
                            t.prototype._basicDot = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(f(f({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"),
                                        e._element.setAttribute("cx", String(i + n / 2)),
                                        e._element.setAttribute("cy", String(r + n / 2)),
                                        e._element.setAttribute("r", String(n / 2))
                                    }
                                }))
                            }
                            ,
                            t.prototype._basicSquare = function(t) {
                                var e = this
                                  , n = t.size
                                  , i = t.x
                                  , r = t.y;
                                this._rotateFigure(f(f({}, t), {
                                    draw: function() {
                                        e._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"),
                                        e._element.setAttribute("x", String(i)),
                                        e._element.setAttribute("y", String(r)),
                                        e._element.setAttribute("width", String(n)),
                                        e._element.setAttribute("height", String(n))
                                    }
                                }))
                            }
                            ,
                            t.prototype._drawDot = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.rotation;
                                this._basicDot({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: r
                                })
                            }
                            ,
                            t.prototype._drawSquare = function(t) {
                                var e = t.x
                                  , n = t.y
                                  , i = t.size
                                  , r = t.rotation;
                                this._basicSquare({
                                    x: e,
                                    y: n,
                                    size: i,
                                    rotation: r
                                })
                            }
                            ,
                            t
                        }()
                          , g = "circle";
                        var m = function(t, e, n, i) {
                            return new (n || (n = Promise))((function(r, s) {
                                function o(t) {
                                    try {
                                        l(i.next(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function a(t) {
                                    try {
                                        l(i.throw(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function l(t) {
                                    var e;
                                    t.done ? r(t.value) : (e = t.value,
                                    e instanceof n ? e : new n((function(t) {
                                        t(e)
                                    }
                                    ))).then(o, a)
                                }
                                l((i = i.apply(t, e || [])).next())
                            }
                            ))
                        }
                          , v = function(t, e) {
                            var n, i, r, s, o = {
                                label: 0,
                                sent: function() {
                                    if (1 & r[0])
                                        throw r[1];
                                    return r[1]
                                },
                                trys: [],
                                ops: []
                            };
                            return s = {
                                next: a(0),
                                throw: a(1),
                                return: a(2)
                            },
                            "function" == typeof Symbol && (s[Symbol.iterator] = function() {
                                return this
                            }
                            ),
                            s;
                            function a(s) {
                                return function(a) {
                                    return function(s) {
                                        if (n)
                                            throw new TypeError("Generator is already executing.");
                                        for (; o; )
                                            try {
                                                if (n = 1,
                                                i && (r = 2 & s[0] ? i.return : s[0] ? i.throw || ((r = i.return) && r.call(i),
                                                0) : i.next) && !(r = r.call(i, s[1])).done)
                                                    return r;
                                                switch (i = 0,
                                                r && (s = [2 & s[0], r.value]),
                                                s[0]) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return o.label++,
                                                    {
                                                        value: s[1],
                                                        done: !1
                                                    };
                                                case 5:
                                                    o.label++,
                                                    i = s[1],
                                                    s = [0];
                                                    continue;
                                                case 7:
                                                    s = o.ops.pop(),
                                                    o.trys.pop();
                                                    continue;
                                                default:
                                                    if (!((r = (r = o.trys).length > 0 && r[r.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                        o = 0;
                                                        continue
                                                    }
                                                    if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                                                        o.label = s[1];
                                                        break
                                                    }
                                                    if (6 === s[0] && o.label < r[1]) {
                                                        o.label = r[1],
                                                        r = s;
                                                        break
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        o.label = r[2],
                                                        o.ops.push(s);
                                                        break
                                                    }
                                                    r[2] && o.ops.pop(),
                                                    o.trys.pop();
                                                    continue
                                                }
                                                s = e.call(t, o)
                                            } catch (t) {
                                                s = [6, t],
                                                i = 0
                                            } finally {
                                                n = r = 0
                                            }
                                        if (5 & s[0])
                                            throw s[1];
                                        return {
                                            value: s[0] ? s[1] : void 0,
                                            done: !0
                                        }
                                    }([s, a])
                                }
                            }
                        }
                          , y = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]
                          , _ = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
                        const E = function() {
                            function t(t) {
                                this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"),
                                this._element.setAttribute("width", String(t.width)),
                                this._element.setAttribute("height", String(t.height)),
                                this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"),
                                this._element.appendChild(this._defs),
                                this._options = t
                            }
                            return Object.defineProperty(t.prototype, "width", {
                                get: function() {
                                    return this._options.width
                                },
                                enumerable: !1,
                                configurable: !0
                            }),
                            Object.defineProperty(t.prototype, "height", {
                                get: function() {
                                    return this._options.height
                                },
                                enumerable: !1,
                                configurable: !0
                            }),
                            t.prototype.getElement = function() {
                                return this._element
                            }
                            ,
                            t.prototype.drawQR = function(t) {
                                return m(this, void 0, void 0, (function() {
                                    var e, n, i, r, s, o, a, l, u, h, d = this;
                                    return v(this, (function(p) {
                                        switch (p.label) {
                                        case 0:
                                            return e = t.getModuleCount(),
                                            n = Math.min(this._options.width, this._options.height) - 2 * this._options.margin,
                                            i = this._options.shape === g ? n / Math.sqrt(2) : n,
                                            r = Math.floor(i / e),
                                            s = {
                                                hideXDots: 0,
                                                hideYDots: 0,
                                                width: 0,
                                                height: 0
                                            },
                                            this._qr = t,
                                            this._options.image ? [4, this.loadImage()] : [3, 2];
                                        case 1:
                                            if (p.sent(),
                                            !this._image)
                                                return [2];
                                            o = this._options,
                                            a = o.imageOptions,
                                            l = o.qrOptions,
                                            u = a.imageSize * c[l.errorCorrectionLevel],
                                            h = Math.floor(u * e * e),
                                            s = function(t) {
                                                var e = t.originalHeight
                                                  , n = t.originalWidth
                                                  , i = t.maxHiddenDots
                                                  , r = t.maxHiddenAxisDots
                                                  , s = t.dotSize
                                                  , o = {
                                                    x: 0,
                                                    y: 0
                                                }
                                                  , a = {
                                                    x: 0,
                                                    y: 0
                                                };
                                                if (e <= 0 || n <= 0 || i <= 0 || s <= 0)
                                                    return {
                                                        height: 0,
                                                        width: 0,
                                                        hideYDots: 0,
                                                        hideXDots: 0
                                                    };
                                                var l = e / n;
                                                return o.x = Math.floor(Math.sqrt(i / l)),
                                                o.x <= 0 && (o.x = 1),
                                                r && r < o.x && (o.x = r),
                                                o.x % 2 == 0 && o.x--,
                                                a.x = o.x * s,
                                                o.y = 1 + 2 * Math.ceil((o.x * l - 1) / 2),
                                                a.y = Math.round(a.x * l),
                                                (o.y * o.x > i || r && r < o.y) && (r && r < o.y ? (o.y = r,
                                                o.y % 2 == 0 && o.x--) : o.y -= 2,
                                                a.y = o.y * s,
                                                o.x = 1 + 2 * Math.ceil((o.y / l - 1) / 2),
                                                a.x = Math.round(a.y / l)),
                                                {
                                                    height: a.y,
                                                    width: a.x,
                                                    hideYDots: o.y,
                                                    hideXDots: o.x
                                                }
                                            }({
                                                originalWidth: this._image.width,
                                                originalHeight: this._image.height,
                                                maxHiddenDots: h,
                                                maxHiddenAxisDots: e - 14,
                                                dotSize: r
                                            }),
                                            p.label = 2;
                                        case 2:
                                            return this.drawBackground(),
                                            this.drawDots((function(t, n) {
                                                var i, r, o, a, l, c;
                                                return !(d._options.imageOptions.hideBackgroundDots && t >= (e - s.hideXDots) / 2 && t < (e + s.hideXDots) / 2 && n >= (e - s.hideYDots) / 2 && n < (e + s.hideYDots) / 2 || (null === (i = y[t]) || void 0 === i ? void 0 : i[n]) || (null === (r = y[t - e + 7]) || void 0 === r ? void 0 : r[n]) || (null === (o = y[t]) || void 0 === o ? void 0 : o[n - e + 7]) || (null === (a = _[t]) || void 0 === a ? void 0 : a[n]) || (null === (l = _[t - e + 7]) || void 0 === l ? void 0 : l[n]) || (null === (c = _[t]) || void 0 === c ? void 0 : c[n - e + 7]))
                                            }
                                            )),
                                            this.drawCorners(),
                                            this._options.image ? [4, this.drawImage({
                                                width: s.width,
                                                height: s.height,
                                                count: e,
                                                dotSize: r
                                            })] : [3, 4];
                                        case 3:
                                            p.sent(),
                                            p.label = 4;
                                        case 4:
                                            return [2]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            ,
                            t.prototype.drawBackground = function() {
                                var t, e, n, i = this._element, r = this._options;
                                if (i) {
                                    var s = null === (t = r.backgroundOptions) || void 0 === t ? void 0 : t.gradient
                                      , o = null === (e = r.backgroundOptions) || void 0 === e ? void 0 : e.color;
                                    if ((s || o) && this._createColor({
                                        options: s,
                                        color: o,
                                        additionalRotation: 0,
                                        x: 0,
                                        y: 0,
                                        height: r.height,
                                        width: r.width,
                                        name: "background-color"
                                    }),
                                    null === (n = r.backgroundOptions) || void 0 === n ? void 0 : n.round) {
                                        var a = Math.min(r.width, r.height)
                                          , l = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                        this._backgroundClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                                        this._backgroundClipPath.setAttribute("id", "clip-path-background-color"),
                                        this._defs.appendChild(this._backgroundClipPath),
                                        l.setAttribute("x", String((r.width - a) / 2)),
                                        l.setAttribute("y", String((r.height - a) / 2)),
                                        l.setAttribute("width", String(a)),
                                        l.setAttribute("height", String(a)),
                                        l.setAttribute("rx", String(a / 2 * r.backgroundOptions.round)),
                                        this._backgroundClipPath.appendChild(l)
                                    }
                                }
                            }
                            ,
                            t.prototype.drawDots = function(t) {
                                var e, n, i = this;
                                if (!this._qr)
                                    throw "QR code is not defined";
                                var r = this._options
                                  , s = this._qr.getModuleCount();
                                if (s > r.width || s > r.height)
                                    throw "The canvas is too small.";
                                var o = Math.min(r.width, r.height) - 2 * r.margin
                                  , a = r.shape === g ? o / Math.sqrt(2) : o
                                  , l = Math.floor(a / s)
                                  , c = Math.floor((r.width - s * l) / 2)
                                  , u = Math.floor((r.height - s * l) / 2)
                                  , d = new h({
                                    svg: this._element,
                                    type: r.dotsOptions.type
                                });
                                this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"),
                                this._dotsClipPath.setAttribute("id", "clip-path-dot-color"),
                                this._defs.appendChild(this._dotsClipPath),
                                this._createColor({
                                    options: null === (e = r.dotsOptions) || void 0 === e ? void 0 : e.gradient,
                                    color: r.dotsOptions.color,
                                    additionalRotation: 0,
                                    x: 0,
                                    y: 0,
                                    height: r.height,
                                    width: r.width,
                                    name: "dot-color"
                                });
                                for (var p = function(e) {
                                    for (var r = function(r) {
                                        return t && !t(e, r) ? "continue" : (null === (n = f._qr) || void 0 === n ? void 0 : n.isDark(e, r)) ? (d.draw(c + e * l, u + r * l, l, (function(n, o) {
                                            return !(e + n < 0 || r + o < 0 || e + n >= s || r + o >= s) && !(t && !t(e + n, r + o)) && !!i._qr && i._qr.isDark(e + n, r + o)
                                        }
                                        )),
                                        void (d._element && f._dotsClipPath && f._dotsClipPath.appendChild(d._element))) : "continue"
                                    }, o = 0; o < s; o++)
                                        r(o)
                                }, f = this, A = 0; A < s; A++)
                                    p(A);
                                if (r.shape === g) {
                                    var m = Math.floor((o / l - s) / 2)
                                      , v = s + 2 * m
                                      , y = c - m * l
                                      , _ = u - m * l
                                      , E = []
                                      , b = Math.floor(v / 2);
                                    for (A = 0; A < v; A++) {
                                        E[A] = [];
                                        for (var x = 0; x < v; x++)
                                            A >= m - 1 && A <= v - m && x >= m - 1 && x <= v - m || Math.sqrt((A - b) * (A - b) + (x - b) * (x - b)) > b ? E[A][x] = 0 : E[A][x] = this._qr.isDark(x - 2 * m < 0 ? x : x >= s ? x - 2 * m : x - m, A - 2 * m < 0 ? A : A >= s ? A - 2 * m : A - m) ? 1 : 0
                                    }
                                    var w = function(t) {
                                        for (var e = function(e) {
                                            if (!E[t][e])
                                                return "continue";
                                            d.draw(y + t * l, _ + e * l, l, (function(n, i) {
                                                var r;
                                                return !!(null === (r = E[t + n]) || void 0 === r ? void 0 : r[e + i])
                                            }
                                            )),
                                            d._element && S._dotsClipPath && S._dotsClipPath.appendChild(d._element)
                                        }, n = 0; n < v; n++)
                                            e(n)
                                    }
                                      , S = this;
                                    for (A = 0; A < v; A++)
                                        w(A)
                                }
                            }
                            ,
                            t.prototype.drawCorners = function() {
                                var t = this;
                                if (!this._qr)
                                    throw "QR code is not defined";
                                var e = this._element
                                  , n = this._options;
                                if (!e)
                                    throw "Element code is not defined";
                                var i = this._qr.getModuleCount()
                                  , r = Math.min(n.width, n.height) - 2 * n.margin
                                  , s = n.shape === g ? r / Math.sqrt(2) : r
                                  , o = Math.floor(s / i)
                                  , a = 7 * o
                                  , l = 3 * o
                                  , c = Math.floor((n.width - i * o) / 2)
                                  , u = Math.floor((n.height - i * o) / 2);
                                [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach((function(e) {
                                    var r, s, d, f, g, m, v, E, b, x, w, S, C = e[0], M = e[1], I = e[2], T = c + C * o * (i - 7), B = u + M * o * (i - 7), R = t._dotsClipPath, L = t._dotsClipPath;
                                    if (((null === (r = n.cornersSquareOptions) || void 0 === r ? void 0 : r.gradient) || (null === (s = n.cornersSquareOptions) || void 0 === s ? void 0 : s.color)) && ((R = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-" + C + "-" + M),
                                    t._defs.appendChild(R),
                                    t._cornersSquareClipPath = t._cornersDotClipPath = L = R,
                                    t._createColor({
                                        options: null === (d = n.cornersSquareOptions) || void 0 === d ? void 0 : d.gradient,
                                        color: null === (f = n.cornersSquareOptions) || void 0 === f ? void 0 : f.color,
                                        additionalRotation: I,
                                        x: T,
                                        y: B,
                                        height: a,
                                        width: a,
                                        name: "corners-square-color-" + C + "-" + M
                                    })),
                                    null === (g = n.cornersSquareOptions) || void 0 === g ? void 0 : g.type) {
                                        var D = new p({
                                            svg: t._element,
                                            type: n.cornersSquareOptions.type
                                        });
                                        D.draw(T, B, a, I),
                                        D._element && R && R.appendChild(D._element)
                                    } else
                                        for (var P = new h({
                                            svg: t._element,
                                            type: n.dotsOptions.type
                                        }), U = function(t) {
                                            for (var e = function(e) {
                                                if (!(null === (m = y[t]) || void 0 === m ? void 0 : m[e]))
                                                    return "continue";
                                                P.draw(T + t * o, B + e * o, o, (function(n, i) {
                                                    var r;
                                                    return !!(null === (r = y[t + n]) || void 0 === r ? void 0 : r[e + i])
                                                }
                                                )),
                                                P._element && R && R.appendChild(P._element)
                                            }, n = 0; n < y[t].length; n++)
                                                e(n)
                                        }, O = 0; O < y.length; O++)
                                            U(O);
                                    if (((null === (v = n.cornersDotOptions) || void 0 === v ? void 0 : v.gradient) || (null === (E = n.cornersDotOptions) || void 0 === E ? void 0 : E.color)) && ((L = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-" + C + "-" + M),
                                    t._defs.appendChild(L),
                                    t._cornersDotClipPath = L,
                                    t._createColor({
                                        options: null === (b = n.cornersDotOptions) || void 0 === b ? void 0 : b.gradient,
                                        color: null === (x = n.cornersDotOptions) || void 0 === x ? void 0 : x.color,
                                        additionalRotation: I,
                                        x: T + 2 * o,
                                        y: B + 2 * o,
                                        height: l,
                                        width: l,
                                        name: "corners-dot-color-" + C + "-" + M
                                    })),
                                    null === (w = n.cornersDotOptions) || void 0 === w ? void 0 : w.type) {
                                        var N = new A({
                                            svg: t._element,
                                            type: n.cornersDotOptions.type
                                        });
                                        N.draw(T + 2 * o, B + 2 * o, l, I),
                                        N._element && L && L.appendChild(N._element)
                                    } else {
                                        P = new h({
                                            svg: t._element,
                                            type: n.dotsOptions.type
                                        });
                                        var F = function(t) {
                                            for (var e = function(e) {
                                                if (!(null === (S = _[t]) || void 0 === S ? void 0 : S[e]))
                                                    return "continue";
                                                P.draw(T + t * o, B + e * o, o, (function(n, i) {
                                                    var r;
                                                    return !!(null === (r = _[t + n]) || void 0 === r ? void 0 : r[e + i])
                                                }
                                                )),
                                                P._element && L && L.appendChild(P._element)
                                            }, n = 0; n < _[t].length; n++)
                                                e(n)
                                        };
                                        for (O = 0; O < _.length; O++)
                                            F(O)
                                    }
                                }
                                ))
                            }
                            ,
                            t.prototype.loadImage = function() {
                                var t = this;
                                return new Promise((function(e, n) {
                                    var i = t._options
                                      , r = new Image;
                                    if (!i.image)
                                        return n("Image is not defined");
                                    "string" == typeof i.imageOptions.crossOrigin && (r.crossOrigin = i.imageOptions.crossOrigin),
                                    t._image = r,
                                    r.onload = function() {
                                        e()
                                    }
                                    ,
                                    r.src = i.image
                                }
                                ))
                            }
                            ,
                            t.prototype.drawImage = function(t) {
                                var e = t.width
                                  , n = t.height
                                  , i = t.count
                                  , r = t.dotSize;
                                return m(this, void 0, void 0, (function() {
                                    var t, s, o, a, c, u, h, d, p;
                                    return v(this, (function(f) {
                                        switch (f.label) {
                                        case 0:
                                            return t = this._options,
                                            s = Math.floor((t.width - i * r) / 2),
                                            o = Math.floor((t.height - i * r) / 2),
                                            a = s + t.imageOptions.margin + (i * r - e) / 2,
                                            c = o + t.imageOptions.margin + (i * r - n) / 2,
                                            u = e - 2 * t.imageOptions.margin,
                                            h = n - 2 * t.imageOptions.margin,
                                            (d = document.createElementNS("http://www.w3.org/2000/svg", "image")).setAttribute("x", String(a)),
                                            d.setAttribute("y", String(c)),
                                            d.setAttribute("width", u + "px"),
                                            d.setAttribute("height", h + "px"),
                                            [4, l(t.image || "")];
                                        case 1:
                                            return p = f.sent(),
                                            d.setAttribute("href", p || ""),
                                            this._element.appendChild(d),
                                            [2]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            ,
                            t.prototype._createColor = function(t) {
                                var e = t.options
                                  , n = t.color
                                  , i = t.additionalRotation
                                  , r = t.x
                                  , s = t.y
                                  , o = t.height
                                  , a = t.width
                                  , l = t.name
                                  , c = a > o ? a : o
                                  , u = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                                if (u.setAttribute("x", String(r)),
                                u.setAttribute("y", String(s)),
                                u.setAttribute("height", String(o)),
                                u.setAttribute("width", String(a)),
                                u.setAttribute("clip-path", "url('#clip-path-" + l + "')"),
                                e) {
                                    var h;
                                    if ("radial" === e.type)
                                        (h = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", l),
                                        h.setAttribute("gradientUnits", "userSpaceOnUse"),
                                        h.setAttribute("fx", String(r + a / 2)),
                                        h.setAttribute("fy", String(s + o / 2)),
                                        h.setAttribute("cx", String(r + a / 2)),
                                        h.setAttribute("cy", String(s + o / 2)),
                                        h.setAttribute("r", String(c / 2));
                                    else {
                                        var d = ((e.rotation || 0) + i) % (2 * Math.PI)
                                          , p = (d + 2 * Math.PI) % (2 * Math.PI)
                                          , f = r + a / 2
                                          , A = s + o / 2
                                          , g = r + a / 2
                                          , m = s + o / 2;
                                        p >= 0 && p <= .25 * Math.PI || p > 1.75 * Math.PI && p <= 2 * Math.PI ? (f -= a / 2,
                                        A -= o / 2 * Math.tan(d),
                                        g += a / 2,
                                        m += o / 2 * Math.tan(d)) : p > .25 * Math.PI && p <= .75 * Math.PI ? (A -= o / 2,
                                        f -= a / 2 / Math.tan(d),
                                        m += o / 2,
                                        g += a / 2 / Math.tan(d)) : p > .75 * Math.PI && p <= 1.25 * Math.PI ? (f += a / 2,
                                        A += o / 2 * Math.tan(d),
                                        g -= a / 2,
                                        m -= o / 2 * Math.tan(d)) : p > 1.25 * Math.PI && p <= 1.75 * Math.PI && (A += o / 2,
                                        f += a / 2 / Math.tan(d),
                                        m -= o / 2,
                                        g -= a / 2 / Math.tan(d)),
                                        (h = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", l),
                                        h.setAttribute("gradientUnits", "userSpaceOnUse"),
                                        h.setAttribute("x1", String(Math.round(f))),
                                        h.setAttribute("y1", String(Math.round(A))),
                                        h.setAttribute("x2", String(Math.round(g))),
                                        h.setAttribute("y2", String(Math.round(m)))
                                    }
                                    e.colorStops.forEach((function(t) {
                                        var e = t.offset
                                          , n = t.color
                                          , i = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                                        i.setAttribute("offset", 100 * e + "%"),
                                        i.setAttribute("stop-color", n),
                                        h.appendChild(i)
                                    }
                                    )),
                                    u.setAttribute("fill", "url('#" + l + "')"),
                                    this._defs.appendChild(h)
                                } else
                                    n && u.setAttribute("fill", n);
                                this._element.appendChild(u)
                            }
                            ,
                            t
                        }()
                          , b = "canvas";
                        for (var x = {}, w = 0; w <= 40; w++)
                            x[w] = w;
                        const S = {
                            type: b,
                            shape: "square",
                            width: 300,
                            height: 300,
                            data: "",
                            margin: 0,
                            qrOptions: {
                                typeNumber: x[0],
                                mode: void 0,
                                errorCorrectionLevel: "Q"
                            },
                            imageOptions: {
                                hideBackgroundDots: !0,
                                imageSize: .4,
                                crossOrigin: void 0,
                                margin: 0
                            },
                            dotsOptions: {
                                type: "square",
                                color: "#000"
                            },
                            backgroundOptions: {
                                round: 0,
                                color: "#fff"
                            }
                        };
                        var C = function() {
                            return (C = Object.assign || function(t) {
                                for (var e, n = 1, i = arguments.length; n < i; n++)
                                    for (var r in e = arguments[n])
                                        Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                                return t
                            }
                            ).apply(this, arguments)
                        };
                        function M(t) {
                            var e = C({}, t);
                            if (!e.colorStops || !e.colorStops.length)
                                throw "Field 'colorStops' is required in gradient";
                            return e.rotation ? e.rotation = Number(e.rotation) : e.rotation = 0,
                            e.colorStops = e.colorStops.map((function(t) {
                                return C(C({}, t), {
                                    offset: Number(t.offset)
                                })
                            }
                            )),
                            e
                        }
                        function I(t) {
                            var e = C({}, t);
                            return e.width = Number(e.width),
                            e.height = Number(e.height),
                            e.margin = Number(e.margin),
                            e.imageOptions = C(C({}, e.imageOptions), {
                                hideBackgroundDots: Boolean(e.imageOptions.hideBackgroundDots),
                                imageSize: Number(e.imageOptions.imageSize),
                                margin: Number(e.imageOptions.margin)
                            }),
                            e.margin > Math.min(e.width, e.height) && (e.margin = Math.min(e.width, e.height)),
                            e.dotsOptions = C({}, e.dotsOptions),
                            e.dotsOptions.gradient && (e.dotsOptions.gradient = M(e.dotsOptions.gradient)),
                            e.cornersSquareOptions && (e.cornersSquareOptions = C({}, e.cornersSquareOptions),
                            e.cornersSquareOptions.gradient && (e.cornersSquareOptions.gradient = M(e.cornersSquareOptions.gradient))),
                            e.cornersDotOptions && (e.cornersDotOptions = C({}, e.cornersDotOptions),
                            e.cornersDotOptions.gradient && (e.cornersDotOptions.gradient = M(e.cornersDotOptions.gradient))),
                            e.backgroundOptions && (e.backgroundOptions = C({}, e.backgroundOptions),
                            e.backgroundOptions.gradient && (e.backgroundOptions.gradient = M(e.backgroundOptions.gradient))),
                            e
                        }
                        var T = n(192)
                          , B = n.n(T)
                          , R = function(t, e, n, i) {
                            return new (n || (n = Promise))((function(r, s) {
                                function o(t) {
                                    try {
                                        l(i.next(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function a(t) {
                                    try {
                                        l(i.throw(t))
                                    } catch (t) {
                                        s(t)
                                    }
                                }
                                function l(t) {
                                    var e;
                                    t.done ? r(t.value) : (e = t.value,
                                    e instanceof n ? e : new n((function(t) {
                                        t(e)
                                    }
                                    ))).then(o, a)
                                }
                                l((i = i.apply(t, e || [])).next())
                            }
                            ))
                        }
                          , L = function(t, e) {
                            var n, i, r, s, o = {
                                label: 0,
                                sent: function() {
                                    if (1 & r[0])
                                        throw r[1];
                                    return r[1]
                                },
                                trys: [],
                                ops: []
                            };
                            return s = {
                                next: a(0),
                                throw: a(1),
                                return: a(2)
                            },
                            "function" == typeof Symbol && (s[Symbol.iterator] = function() {
                                return this
                            }
                            ),
                            s;
                            function a(s) {
                                return function(a) {
                                    return function(s) {
                                        if (n)
                                            throw new TypeError("Generator is already executing.");
                                        for (; o; )
                                            try {
                                                if (n = 1,
                                                i && (r = 2 & s[0] ? i.return : s[0] ? i.throw || ((r = i.return) && r.call(i),
                                                0) : i.next) && !(r = r.call(i, s[1])).done)
                                                    return r;
                                                switch (i = 0,
                                                r && (s = [2 & s[0], r.value]),
                                                s[0]) {
                                                case 0:
                                                case 1:
                                                    r = s;
                                                    break;
                                                case 4:
                                                    return o.label++,
                                                    {
                                                        value: s[1],
                                                        done: !1
                                                    };
                                                case 5:
                                                    o.label++,
                                                    i = s[1],
                                                    s = [0];
                                                    continue;
                                                case 7:
                                                    s = o.ops.pop(),
                                                    o.trys.pop();
                                                    continue;
                                                default:
                                                    if (!((r = (r = o.trys).length > 0 && r[r.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                                        o = 0;
                                                        continue
                                                    }
                                                    if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                                                        o.label = s[1];
                                                        break
                                                    }
                                                    if (6 === s[0] && o.label < r[1]) {
                                                        o.label = r[1],
                                                        r = s;
                                                        break
                                                    }
                                                    if (r && o.label < r[2]) {
                                                        o.label = r[2],
                                                        o.ops.push(s);
                                                        break
                                                    }
                                                    r[2] && o.ops.pop(),
                                                    o.trys.pop();
                                                    continue
                                                }
                                                s = e.call(t, o)
                                            } catch (t) {
                                                s = [6, t],
                                                i = 0
                                            } finally {
                                                n = r = 0
                                            }
                                        if (5 & s[0])
                                            throw s[1];
                                        return {
                                            value: s[0] ? s[1] : void 0,
                                            done: !0
                                        }
                                    }([s, a])
                                }
                            }
                        };
                        const D = function() {
                            function t(t) {
                                this._options = t ? I(o(S, t)) : S,
                                this.update()
                            }
                            return t._clearContainer = function(t) {
                                t && (t.innerHTML = "")
                            }
                            ,
                            t.prototype._setupSvg = function() {
                                var t = this;
                                if (this._qr) {
                                    var e = new E(this._options);
                                    this._svg = e.getElement(),
                                    this._svgDrawingPromise = e.drawQR(this._qr).then((function() {
                                        var n;
                                        t._svg && (null === (n = t._extension) || void 0 === n || n.call(t, e.getElement(), t._options))
                                    }
                                    ))
                                }
                            }
                            ,
                            t.prototype._setupCanvas = function() {
                                var t, e = this;
                                this._qr && (this._canvas = document.createElement("canvas"),
                                this._canvas.width = this._options.width,
                                this._canvas.height = this._options.height,
                                this._setupSvg(),
                                this._canvasDrawingPromise = null === (t = this._svgDrawingPromise) || void 0 === t ? void 0 : t.then((function() {
                                    if (e._svg) {
                                        var t = e._svg
                                          , n = (new XMLSerializer).serializeToString(t)
                                          , i = "data:image/svg+xml;base64," + btoa(n)
                                          , r = new Image;
                                        return new Promise((function(t) {
                                            r.onload = function() {
                                                var n, i;
                                                null === (i = null === (n = e._canvas) || void 0 === n ? void 0 : n.getContext("2d")) || void 0 === i || i.drawImage(r, 0, 0),
                                                t()
                                            }
                                            ,
                                            r.src = i
                                        }
                                        ))
                                    }
                                }
                                )))
                            }
                            ,
                            t.prototype._getElement = function(t) {
                                return void 0 === t && (t = "png"),
                                R(this, void 0, void 0, (function() {
                                    return L(this, (function(e) {
                                        switch (e.label) {
                                        case 0:
                                            if (!this._qr)
                                                throw "QR code is empty";
                                            return "svg" !== t.toLowerCase() ? [3, 2] : (this._svg && this._svgDrawingPromise || this._setupSvg(),
                                            [4, this._svgDrawingPromise]);
                                        case 1:
                                            return e.sent(),
                                            [2, this._svg];
                                        case 2:
                                            return this._canvas && this._canvasDrawingPromise || this._setupCanvas(),
                                            [4, this._canvasDrawingPromise];
                                        case 3:
                                            return e.sent(),
                                            [2, this._canvas]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            ,
                            t.prototype.update = function(e) {
                                t._clearContainer(this._container),
                                this._options = e ? I(o(this._options, e)) : this._options,
                                this._options.data && (this._qr = B()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel),
                                this._qr.addData(this._options.data, this._options.qrOptions.mode || function(t) {
                                    switch (!0) {
                                    case /^[0-9]*$/.test(t):
                                        return "Numeric";
                                    case /^[0-9A-Z $%*+\-./:]*$/.test(t):
                                        return "Alphanumeric";
                                    default:
                                        return "Byte"
                                    }
                                }(this._options.data)),
                                this._qr.make(),
                                this._options.type === b ? this._setupCanvas() : this._setupSvg(),
                                this.append(this._container))
                            }
                            ,
                            t.prototype.append = function(t) {
                                if (t) {
                                    if ("function" != typeof t.appendChild)
                                        throw "Container should be a single DOM node";
                                    this._options.type === b ? this._canvas && t.appendChild(this._canvas) : this._svg && t.appendChild(this._svg),
                                    this._container = t
                                }
                            }
                            ,
                            t.prototype.applyExtension = function(t) {
                                if (!t)
                                    throw "Extension function should be defined.";
                                this._extension = t,
                                this.update()
                            }
                            ,
                            t.prototype.deleteExtension = function() {
                                this._extension = void 0,
                                this.update()
                            }
                            ,
                            t.prototype.getRawData = function(t) {
                                return void 0 === t && (t = "png"),
                                R(this, void 0, void 0, (function() {
                                    var e, n, i;
                                    return L(this, (function(r) {
                                        switch (r.label) {
                                        case 0:
                                            if (!this._qr)
                                                throw "QR code is empty";
                                            return [4, this._getElement(t)];
                                        case 1:
                                            return (e = r.sent()) ? "svg" === t.toLowerCase() ? (n = new XMLSerializer,
                                            i = n.serializeToString(e),
                                            [2, new Blob(['<?xml version="1.0" standalone="no"?>\r\n' + i],{
                                                type: "image/svg+xml"
                                            })]) : [2, new Promise((function(n) {
                                                return e.toBlob(n, "image/" + t, 1)
                                            }
                                            ))] : [2, null]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            ,
                            t.prototype.download = function(t) {
                                return R(this, void 0, void 0, (function() {
                                    var e, n, i, r, s;
                                    return L(this, (function(o) {
                                        switch (o.label) {
                                        case 0:
                                            if (!this._qr)
                                                throw "QR code is empty";
                                            return e = "png",
                                            n = "qr",
                                            "string" == typeof t ? (e = t,
                                            console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t && null !== t && (t.name && (n = t.name),
                                            t.extension && (e = t.extension)),
                                            [4, this._getElement(e)];
                                        case 1:
                                            return (i = o.sent()) ? ("svg" === e.toLowerCase() ? (r = new XMLSerializer,
                                            s = '<?xml version="1.0" standalone="no"?>\r\n' + (s = r.serializeToString(i)),
                                            a("data:image/svg+xml;charset=utf-8," + encodeURIComponent(s), n + ".svg")) : a(i.toDataURL("image/" + e), n + "." + e),
                                            [2]) : [2]
                                        }
                                    }
                                    ))
                                }
                                ))
                            }
                            ,
                            t
                        }()
                    }
                }
                  , e = {};
                function n(i) {
                    if (e[i])
                        return e[i].exports;
                    var r = e[i] = {
                        exports: {}
                    };
                    return t[i](r, r.exports, n),
                    r.exports
                }
                return n.n = t=>{
                    var e = t && t.__esModule ? ()=>t.default : ()=>t;
                    return n.d(e, {
                        a: e
                    }),
                    e
                }
                ,
                n.d = (t,e)=>{
                    for (var i in e)
                        n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                            enumerable: !0,
                            get: e[i]
                        })
                }
                ,
                n.o = (t,e)=>Object.prototype.hasOwnProperty.call(t, e),
                n(676)
            }
            )().default
        },
        6118: function(t, e, n) {
            var i = {
                "./ar-button.png": 2547,
                "./ar-icon-btn.svg": 2833,
                "./arrow-left-icon-swiper.svg": 3093,
                "./arrow-right-icon-swiper.svg": 221,
                "./close-icon-swiper.svg": 5293,
                "./close-qr-btn.svg": 4472,
                "./google.png": 1886,
                "./hand.png": 7626,
                "./load-icon.svg": 5045,
                "./logo-ar.svg": 7559,
                "./main-logo.png": 9120,
                "./open-icon-swiper.svg": 8600,
                "./point-phone-hand.svg": 2382,
                "./point-phone.png": 2100,
                "./qr-code.png": 3777,
                "./spinner.svg": 6262,
                "./zarbo-logo-min.png": 4695,
                "./zarbo-logo.png": 6068
            };
            function r(t) {
                var e = s(t);
                return n(e)
            }
            function s(t) {
                if (!n.o(i, t)) {
                    var e = new Error("Cannot find module '" + t + "'");
                    throw e.code = "MODULE_NOT_FOUND",
                    e
                }
                return i[t]
            }
            r.keys = function() {
                return Object.keys(i)
            }
            ,
            r.resolve = s,
            t.exports = r,
            r.id = 6118
        },
        7340: function(t) {
            function e(t) {
                return Promise.resolve().then((function() {
                    var e = new Error("Cannot find module '" + t + "'");
                    throw e.code = "MODULE_NOT_FOUND",
                    e
                }
                ))
            }
            e.keys = function() {
                return []
            }
            ,
            e.resolve = e,
            e.id = 7340,
            t.exports = e
        },
        2547: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/ar-button.png"
        },
        2833: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/ar-icon-btn.svg"
        },
        3093: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/arrow-left-icon-swiper.svg"
        },
        221: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/arrow-right-icon-swiper.svg"
        },
        5293: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/close-icon-swiper.svg"
        },
        4472: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/close-qr-btn.svg"
        },
        1886: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/google.png"
        },
        7626: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/hand.png"
        },
        5045: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/load-icon.svg"
        },
        7559: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/logo-ar.svg"
        },
        9120: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/main-logo.png"
        },
        8600: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/open-icon-swiper.svg"
        },
        2382: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/point-phone-hand.svg"
        },
        2100: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/point-phone.png"
        },
        3777: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/qr-code.png"
        },
        6262: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/spinner.svg"
        },
        4695: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/zarbo-logo-min.png"
        },
        6068: function(t, e, n) {
            "use strict";
            t.exports = n.p + "assets/images/zarbo-logo.png"
        },
        7218: function(t, e, n) {
            "use strict";
            function i(t, e) {
                return function() {
                    return t.apply(e, arguments)
                }
            }
            const {toString: r} = Object.prototype
              , {getPrototypeOf: s} = Object
              , o = (a = Object.create(null),
            t=>{
                const e = r.call(t);
                return a[e] || (a[e] = e.slice(8, -1).toLowerCase())
            }
            );
            var a;
            const l = t=>(t = t.toLowerCase(),
            e=>o(e) === t)
              , c = t=>e=>typeof e === t
              , {isArray: u} = Array
              , h = c("undefined");
            const d = l("ArrayBuffer");
            const p = c("string")
              , f = c("function")
              , A = c("number")
              , g = t=>null !== t && "object" == typeof t
              , m = t=>{
                if ("object" !== o(t))
                    return !1;
                const e = s(t);
                return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || Symbol.toStringTag in t || Symbol.iterator in t)
            }
              , v = l("Date")
              , y = l("File")
              , _ = l("Blob")
              , E = l("FileList")
              , b = l("URLSearchParams");
            function x(t, e, {allOwnKeys: n=!1}={}) {
                if (null == t)
                    return;
                let i, r;
                if ("object" != typeof t && (t = [t]),
                u(t))
                    for (i = 0,
                    r = t.length; i < r; i++)
                        e.call(null, t[i], i, t);
                else {
                    const r = n ? Object.getOwnPropertyNames(t) : Object.keys(t)
                      , s = r.length;
                    let o;
                    for (i = 0; i < s; i++)
                        o = r[i],
                        e.call(null, t[o], o, t)
                }
            }
            function w(t, e) {
                e = e.toLowerCase();
                const n = Object.keys(t);
                let i, r = n.length;
                for (; r-- > 0; )
                    if (i = n[r],
                    e === i.toLowerCase())
                        return i;
                return null
            }
            const S = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : n.g
              , C = t=>!h(t) && t !== S;
            const M = (I = "undefined" != typeof Uint8Array && s(Uint8Array),
            t=>I && t instanceof I);
            var I;
            const T = l("HTMLFormElement")
              , B = (({hasOwnProperty: t})=>(e,n)=>t.call(e, n))(Object.prototype)
              , R = l("RegExp")
              , L = (t,e)=>{
                const n = Object.getOwnPropertyDescriptors(t)
                  , i = {};
                x(n, ((n,r)=>{
                    let s;
                    !1 !== (s = e(n, r, t)) && (i[r] = s || n)
                }
                )),
                Object.defineProperties(t, i)
            }
              , D = "abcdefghijklmnopqrstuvwxyz"
              , P = "0123456789"
              , U = {
                DIGIT: P,
                ALPHA: D,
                ALPHA_DIGIT: D + D.toUpperCase() + P
            };
            const O = l("AsyncFunction");
            var N = {
                isArray: u,
                isArrayBuffer: d,
                isBuffer: function(t) {
                    return null !== t && !h(t) && null !== t.constructor && !h(t.constructor) && f(t.constructor.isBuffer) && t.constructor.isBuffer(t)
                },
                isFormData: t=>{
                    let e;
                    return t && ("function" == typeof FormData && t instanceof FormData || f(t.append) && ("formdata" === (e = o(t)) || "object" === e && f(t.toString) && "[object FormData]" === t.toString()))
                }
                ,
                isArrayBufferView: function(t) {
                    let e;
                    return e = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && d(t.buffer),
                    e
                },
                isString: p,
                isNumber: A,
                isBoolean: t=>!0 === t || !1 === t,
                isObject: g,
                isPlainObject: m,
                isUndefined: h,
                isDate: v,
                isFile: y,
                isBlob: _,
                isRegExp: R,
                isFunction: f,
                isStream: t=>g(t) && f(t.pipe),
                isURLSearchParams: b,
                isTypedArray: M,
                isFileList: E,
                forEach: x,
                merge: function t() {
                    const {caseless: e} = C(this) && this || {}
                      , n = {}
                      , i = (i,r)=>{
                        const s = e && w(n, r) || r;
                        m(n[s]) && m(i) ? n[s] = t(n[s], i) : m(i) ? n[s] = t({}, i) : u(i) ? n[s] = i.slice() : n[s] = i
                    }
                    ;
                    for (let t = 0, e = arguments.length; t < e; t++)
                        arguments[t] && x(arguments[t], i);
                    return n
                },
                extend: (t,e,n,{allOwnKeys: r}={})=>(x(e, ((e,r)=>{
                    n && f(e) ? t[r] = i(e, n) : t[r] = e
                }
                ), {
                    allOwnKeys: r
                }),
                t),
                trim: t=>t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                stripBOM: t=>(65279 === t.charCodeAt(0) && (t = t.slice(1)),
                t),
                inherits: (t,e,n,i)=>{
                    t.prototype = Object.create(e.prototype, i),
                    t.prototype.constructor = t,
                    Object.defineProperty(t, "super", {
                        value: e.prototype
                    }),
                    n && Object.assign(t.prototype, n)
                }
                ,
                toFlatObject: (t,e,n,i)=>{
                    let r, o, a;
                    const l = {};
                    if (e = e || {},
                    null == t)
                        return e;
                    do {
                        for (r = Object.getOwnPropertyNames(t),
                        o = r.length; o-- > 0; )
                            a = r[o],
                            i && !i(a, t, e) || l[a] || (e[a] = t[a],
                            l[a] = !0);
                        t = !1 !== n && s(t)
                    } while (t && (!n || n(t, e)) && t !== Object.prototype);
                    return e
                }
                ,
                kindOf: o,
                kindOfTest: l,
                endsWith: (t,e,n)=>{
                    t = String(t),
                    (void 0 === n || n > t.length) && (n = t.length),
                    n -= e.length;
                    const i = t.indexOf(e, n);
                    return -1 !== i && i === n
                }
                ,
                toArray: t=>{
                    if (!t)
                        return null;
                    if (u(t))
                        return t;
                    let e = t.length;
                    if (!A(e))
                        return null;
                    const n = new Array(e);
                    for (; e-- > 0; )
                        n[e] = t[e];
                    return n
                }
                ,
                forEachEntry: (t,e)=>{
                    const n = (t && t[Symbol.iterator]).call(t);
                    let i;
                    for (; (i = n.next()) && !i.done; ) {
                        const n = i.value;
                        e.call(t, n[0], n[1])
                    }
                }
                ,
                matchAll: (t,e)=>{
                    let n;
                    const i = [];
                    for (; null !== (n = t.exec(e)); )
                        i.push(n);
                    return i
                }
                ,
                isHTMLForm: T,
                hasOwnProperty: B,
                hasOwnProp: B,
                reduceDescriptors: L,
                freezeMethods: t=>{
                    L(t, ((e,n)=>{
                        if (f(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                            return !1;
                        const i = t[n];
                        f(i) && (e.enumerable = !1,
                        "writable"in e ? e.writable = !1 : e.set || (e.set = ()=>{
                            throw Error("Can not rewrite read-only method '" + n + "'")
                        }
                        ))
                    }
                    ))
                }
                ,
                toObjectSet: (t,e)=>{
                    const n = {}
                      , i = t=>{
                        t.forEach((t=>{
                            n[t] = !0
                        }
                        ))
                    }
                    ;
                    return u(t) ? i(t) : i(String(t).split(e)),
                    n
                }
                ,
                toCamelCase: t=>t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(t, e, n) {
                    return e.toUpperCase() + n
                }
                )),
                noop: ()=>{}
                ,
                toFiniteNumber: (t,e)=>(t = +t,
                Number.isFinite(t) ? t : e),
                findKey: w,
                global: S,
                isContextDefined: C,
                ALPHABET: U,
                generateString: (t=16,e=U.ALPHA_DIGIT)=>{
                    let n = "";
                    const {length: i} = e;
                    for (; t--; )
                        n += e[Math.random() * i | 0];
                    return n
                }
                ,
                isSpecCompliantForm: function(t) {
                    return !!(t && f(t.append) && "FormData" === t[Symbol.toStringTag] && t[Symbol.iterator])
                },
                toJSONObject: t=>{
                    const e = new Array(10)
                      , n = (t,i)=>{
                        if (g(t)) {
                            if (e.indexOf(t) >= 0)
                                return;
                            if (!("toJSON"in t)) {
                                e[i] = t;
                                const r = u(t) ? [] : {};
                                return x(t, ((t,e)=>{
                                    const s = n(t, i + 1);
                                    !h(s) && (r[e] = s)
                                }
                                )),
                                e[i] = void 0,
                                r
                            }
                        }
                        return t
                    }
                    ;
                    return n(t, 0)
                }
                ,
                isAsyncFn: O,
                isThenable: t=>t && (g(t) || f(t)) && f(t.then) && f(t.catch)
            };
            function F(t, e, n, i, r) {
                Error.call(this),
                Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
                this.message = t,
                this.name = "AxiosError",
                e && (this.code = e),
                n && (this.config = n),
                i && (this.request = i),
                r && (this.response = r)
            }
            N.inherits(F, Error, {
                toJSON: function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: N.toJSONObject(this.config),
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            const Q = F.prototype
              , k = {};
            ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t=>{
                k[t] = {
                    value: t
                }
            }
            )),
            Object.defineProperties(F, k),
            Object.defineProperty(Q, "isAxiosError", {
                value: !0
            }),
            F.from = (t,e,n,i,r,s)=>{
                const o = Object.create(Q);
                return N.toFlatObject(t, o, (function(t) {
                    return t !== Error.prototype
                }
                ), (t=>"isAxiosError" !== t)),
                F.call(o, t.message, e, n, i, r),
                o.cause = t,
                o.name = t.name,
                s && Object.assign(o, s),
                o
            }
            ;
            function G(t) {
                return N.isPlainObject(t) || N.isArray(t)
            }
            function H(t) {
                return N.endsWith(t, "[]") ? t.slice(0, -2) : t
            }
            function z(t, e, n) {
                return t ? t.concat(e).map((function(t, e) {
                    return t = H(t),
                    !n && e ? "[" + t + "]" : t
                }
                )).join(n ? "." : "") : e
            }
            const V = N.toFlatObject(N, {}, null, (function(t) {
                return /^is[A-Z]/.test(t)
            }
            ));
            function W(t, e, n) {
                if (!N.isObject(t))
                    throw new TypeError("target must be an object");
                e = e || new FormData;
                const i = (n = N.toFlatObject(n, {
                    metaTokens: !0,
                    dots: !1,
                    indexes: !1
                }, !1, (function(t, e) {
                    return !N.isUndefined(e[t])
                }
                ))).metaTokens
                  , r = n.visitor || c
                  , s = n.dots
                  , o = n.indexes
                  , a = (n.Blob || "undefined" != typeof Blob && Blob) && N.isSpecCompliantForm(e);
                if (!N.isFunction(r))
                    throw new TypeError("visitor must be a function");
                function l(t) {
                    if (null === t)
                        return "";
                    if (N.isDate(t))
                        return t.toISOString();
                    if (!a && N.isBlob(t))
                        throw new F("Blob is not supported. Use a Buffer instead.");
                    return N.isArrayBuffer(t) || N.isTypedArray(t) ? a && "function" == typeof Blob ? new Blob([t]) : Buffer.from(t) : t
                }
                function c(t, n, r) {
                    let a = t;
                    if (t && !r && "object" == typeof t)
                        if (N.endsWith(n, "{}"))
                            n = i ? n : n.slice(0, -2),
                            t = JSON.stringify(t);
                        else if (N.isArray(t) && function(t) {
                            return N.isArray(t) && !t.some(G)
                        }(t) || (N.isFileList(t) || N.endsWith(n, "[]")) && (a = N.toArray(t)))
                            return n = H(n),
                            a.forEach((function(t, i) {
                                !N.isUndefined(t) && null !== t && e.append(!0 === o ? z([n], i, s) : null === o ? n : n + "[]", l(t))
                            }
                            )),
                            !1;
                    return !!G(t) || (e.append(z(r, n, s), l(t)),
                    !1)
                }
                const u = []
                  , h = Object.assign(V, {
                    defaultVisitor: c,
                    convertValue: l,
                    isVisitable: G
                });
                if (!N.isObject(t))
                    throw new TypeError("data must be an object");
                return function t(n, i) {
                    if (!N.isUndefined(n)) {
                        if (-1 !== u.indexOf(n))
                            throw Error("Circular reference detected in " + i.join("."));
                        u.push(n),
                        N.forEach(n, (function(n, s) {
                            !0 === (!(N.isUndefined(n) || null === n) && r.call(e, n, N.isString(s) ? s.trim() : s, i, h)) && t(n, i ? i.concat(s) : [s])
                        }
                        )),
                        u.pop()
                    }
                }(t),
                e
            }
            function q(t) {
                const e = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\0"
                };
                return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, (function(t) {
                    return e[t]
                }
                ))
            }
            function j(t, e) {
                this._pairs = [],
                t && W(t, this, e)
            }
            const X = j.prototype;
            function Y(t) {
                return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }
            function K(t, e, n) {
                if (!e)
                    return t;
                const i = n && n.encode || Y
                  , r = n && n.serialize;
                let s;
                if (s = r ? r(e, n) : N.isURLSearchParams(e) ? e.toString() : new j(e,n).toString(i),
                s) {
                    const e = t.indexOf("#");
                    -1 !== e && (t = t.slice(0, e)),
                    t += (-1 === t.indexOf("?") ? "?" : "&") + s
                }
                return t
            }
            X.append = function(t, e) {
                this._pairs.push([t, e])
            }
            ,
            X.toString = function(t) {
                const e = t ? function(e) {
                    return t.call(this, e, q)
                }
                : q;
                return this._pairs.map((function(t) {
                    return e(t[0]) + "=" + e(t[1])
                }
                ), "").join("&")
            }
            ;
            var J = class {
                constructor() {
                    this.handlers = []
                }
                use(t, e, n) {
                    return this.handlers.push({
                        fulfilled: t,
                        rejected: e,
                        synchronous: !!n && n.synchronous,
                        runWhen: n ? n.runWhen : null
                    }),
                    this.handlers.length - 1
                }
                eject(t) {
                    this.handlers[t] && (this.handlers[t] = null)
                }
                clear() {
                    this.handlers && (this.handlers = [])
                }
                forEach(t) {
                    N.forEach(this.handlers, (function(e) {
                        null !== e && t(e)
                    }
                    ))
                }
            }
              , $ = {
                silentJSONParsing: !0,
                forcedJSONParsing: !0,
                clarifyTimeoutError: !1
            };
            var Z = {
                isBrowser: !0,
                classes: {
                    URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : j,
                    FormData: "undefined" != typeof FormData ? FormData : null,
                    Blob: "undefined" != typeof Blob ? Blob : null
                },
                isStandardBrowserEnv: (()=>{
                    let t;
                    return ("undefined" == typeof navigator || "ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t) && ("undefined" != typeof window && "undefined" != typeof document)
                }
                )(),
                isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
                protocols: ["http", "https", "file", "blob", "url", "data"]
            };
            function tt(t) {
                function e(t, n, i, r) {
                    let s = t[r++];
                    const o = Number.isFinite(+s)
                      , a = r >= t.length;
                    if (s = !s && N.isArray(i) ? i.length : s,
                    a)
                        return N.hasOwnProp(i, s) ? i[s] = [i[s], n] : i[s] = n,
                        !o;
                    i[s] && N.isObject(i[s]) || (i[s] = []);
                    return e(t, n, i[s], r) && N.isArray(i[s]) && (i[s] = function(t) {
                        const e = {}
                          , n = Object.keys(t);
                        let i;
                        const r = n.length;
                        let s;
                        for (i = 0; i < r; i++)
                            s = n[i],
                            e[s] = t[s];
                        return e
                    }(i[s])),
                    !o
                }
                if (N.isFormData(t) && N.isFunction(t.entries)) {
                    const n = {};
                    return N.forEachEntry(t, ((t,i)=>{
                        e(function(t) {
                            return N.matchAll(/\w+|\[(\w*)]/g, t).map((t=>"[]" === t[0] ? "" : t[1] || t[0]))
                        }(t), i, n, 0)
                    }
                    )),
                    n
                }
                return null
            }
            const et = {
                transitional: $,
                adapter: Z.isNode ? "http" : "xhr",
                transformRequest: [function(t, e) {
                    const n = e.getContentType() || ""
                      , i = n.indexOf("application/json") > -1
                      , r = N.isObject(t);
                    r && N.isHTMLForm(t) && (t = new FormData(t));
                    if (N.isFormData(t))
                        return i && i ? JSON.stringify(tt(t)) : t;
                    if (N.isArrayBuffer(t) || N.isBuffer(t) || N.isStream(t) || N.isFile(t) || N.isBlob(t))
                        return t;
                    if (N.isArrayBufferView(t))
                        return t.buffer;
                    if (N.isURLSearchParams(t))
                        return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                        t.toString();
                    let s;
                    if (r) {
                        if (n.indexOf("application/x-www-form-urlencoded") > -1)
                            return function(t, e) {
                                return W(t, new Z.classes.URLSearchParams, Object.assign({
                                    visitor: function(t, e, n, i) {
                                        return Z.isNode && N.isBuffer(t) ? (this.append(e, t.toString("base64")),
                                        !1) : i.defaultVisitor.apply(this, arguments)
                                    }
                                }, e))
                            }(t, this.formSerializer).toString();
                        if ((s = N.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
                            const e = this.env && this.env.FormData;
                            return W(s ? {
                                "files[]": t
                            } : t, e && new e, this.formSerializer)
                        }
                    }
                    return r || i ? (e.setContentType("application/json", !1),
                    function(t, e, n) {
                        if (N.isString(t))
                            try {
                                return (e || JSON.parse)(t),
                                N.trim(t)
                            } catch (t) {
                                if ("SyntaxError" !== t.name)
                                    throw t
                            }
                        return (n || JSON.stringify)(t)
                    }(t)) : t
                }
                ],
                transformResponse: [function(t) {
                    const e = this.transitional || et.transitional
                      , n = e && e.forcedJSONParsing
                      , i = "json" === this.responseType;
                    if (t && N.isString(t) && (n && !this.responseType || i)) {
                        const n = !(e && e.silentJSONParsing) && i;
                        try {
                            return JSON.parse(t)
                        } catch (t) {
                            if (n) {
                                if ("SyntaxError" === t.name)
                                    throw F.from(t, F.ERR_BAD_RESPONSE, this, null, this.response);
                                throw t
                            }
                        }
                    }
                    return t
                }
                ],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: Z.classes.FormData,
                    Blob: Z.classes.Blob
                },
                validateStatus: function(t) {
                    return t >= 200 && t < 300
                },
                headers: {
                    common: {
                        Accept: "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            N.forEach(["delete", "get", "head", "post", "put", "patch"], (t=>{
                et.headers[t] = {}
            }
            ));
            var nt = et;
            const it = N.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
            const rt = Symbol("internals");
            function st(t) {
                return t && String(t).trim().toLowerCase()
            }
            function ot(t) {
                return !1 === t || null == t ? t : N.isArray(t) ? t.map(ot) : String(t)
            }
            function at(t, e, n, i, r) {
                return N.isFunction(i) ? i.call(this, e, n) : (r && (e = n),
                N.isString(e) ? N.isString(i) ? -1 !== e.indexOf(i) : N.isRegExp(i) ? i.test(e) : void 0 : void 0)
            }
            class lt {
                constructor(t) {
                    t && this.set(t)
                }
                set(t, e, n) {
                    const i = this;
                    function r(t, e, n) {
                        const r = st(e);
                        if (!r)
                            throw new Error("header name must be a non-empty string");
                        const s = N.findKey(i, r);
                        (!s || void 0 === i[s] || !0 === n || void 0 === n && !1 !== i[s]) && (i[s || e] = ot(t))
                    }
                    const s = (t,e)=>N.forEach(t, ((t,n)=>r(t, n, e)));
                    return N.isPlainObject(t) || t instanceof this.constructor ? s(t, e) : N.isString(t) && (t = t.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()) ? s((t=>{
                        const e = {};
                        let n, i, r;
                        return t && t.split("\n").forEach((function(t) {
                            r = t.indexOf(":"),
                            n = t.substring(0, r).trim().toLowerCase(),
                            i = t.substring(r + 1).trim(),
                            !n || e[n] && it[n] || ("set-cookie" === n ? e[n] ? e[n].push(i) : e[n] = [i] : e[n] = e[n] ? e[n] + ", " + i : i)
                        }
                        )),
                        e
                    }
                    )(t), e) : null != t && r(e, t, n),
                    this
                }
                get(t, e) {
                    if (t = st(t)) {
                        const n = N.findKey(this, t);
                        if (n) {
                            const t = this[n];
                            if (!e)
                                return t;
                            if (!0 === e)
                                return function(t) {
                                    const e = Object.create(null)
                                      , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                    let i;
                                    for (; i = n.exec(t); )
                                        e[i[1]] = i[2];
                                    return e
                                }(t);
                            if (N.isFunction(e))
                                return e.call(this, t, n);
                            if (N.isRegExp(e))
                                return e.exec(t);
                            throw new TypeError("parser must be boolean|regexp|function")
                        }
                    }
                }
                has(t, e) {
                    if (t = st(t)) {
                        const n = N.findKey(this, t);
                        return !(!n || void 0 === this[n] || e && !at(0, this[n], n, e))
                    }
                    return !1
                }
                delete(t, e) {
                    const n = this;
                    let i = !1;
                    function r(t) {
                        if (t = st(t)) {
                            const r = N.findKey(n, t);
                            !r || e && !at(0, n[r], r, e) || (delete n[r],
                            i = !0)
                        }
                    }
                    return N.isArray(t) ? t.forEach(r) : r(t),
                    i
                }
                clear(t) {
                    const e = Object.keys(this);
                    let n = e.length
                      , i = !1;
                    for (; n--; ) {
                        const r = e[n];
                        t && !at(0, this[r], r, t, !0) || (delete this[r],
                        i = !0)
                    }
                    return i
                }
                normalize(t) {
                    const e = this
                      , n = {};
                    return N.forEach(this, ((i,r)=>{
                        const s = N.findKey(n, r);
                        if (s)
                            return e[s] = ot(i),
                            void delete e[r];
                        const o = t ? function(t) {
                            return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((t,e,n)=>e.toUpperCase() + n))
                        }(r) : String(r).trim();
                        o !== r && delete e[r],
                        e[o] = ot(i),
                        n[o] = !0
                    }
                    )),
                    this
                }
                concat(...t) {
                    return this.constructor.concat(this, ...t)
                }
                toJSON(t) {
                    const e = Object.create(null);
                    return N.forEach(this, ((n,i)=>{
                        null != n && !1 !== n && (e[i] = t && N.isArray(n) ? n.join(", ") : n)
                    }
                    )),
                    e
                }
                [Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]()
                }
                toString() {
                    return Object.entries(this.toJSON()).map((([t,e])=>t + ": " + e)).join("\n")
                }
                get[Symbol.toStringTag]() {
                    return "AxiosHeaders"
                }
                static from(t) {
                    return t instanceof this ? t : new this(t)
                }
                static concat(t, ...e) {
                    const n = new this(t);
                    return e.forEach((t=>n.set(t))),
                    n
                }
                static accessor(t) {
                    const e = (this[rt] = this[rt] = {
                        accessors: {}
                    }).accessors
                      , n = this.prototype;
                    function i(t) {
                        const i = st(t);
                        e[i] || (!function(t, e) {
                            const n = N.toCamelCase(" " + e);
                            ["get", "set", "has"].forEach((i=>{
                                Object.defineProperty(t, i + n, {
                                    value: function(t, n, r) {
                                        return this[i].call(this, e, t, n, r)
                                    },
                                    configurable: !0
                                })
                            }
                            ))
                        }(n, t),
                        e[i] = !0)
                    }
                    return N.isArray(t) ? t.forEach(i) : i(t),
                    this
                }
            }
            lt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
            N.reduceDescriptors(lt.prototype, (({value: t},e)=>{
                let n = e[0].toUpperCase() + e.slice(1);
                return {
                    get: ()=>t,
                    set(t) {
                        this[n] = t
                    }
                }
            }
            )),
            N.freezeMethods(lt);
            var ct = lt;
            function ut(t, e) {
                const n = this || nt
                  , i = e || n
                  , r = ct.from(i.headers);
                let s = i.data;
                return N.forEach(t, (function(t) {
                    s = t.call(n, s, r.normalize(), e ? e.status : void 0)
                }
                )),
                r.normalize(),
                s
            }
            function ht(t) {
                return !(!t || !t.__CANCEL__)
            }
            function dt(t, e, n) {
                F.call(this, null == t ? "canceled" : t, F.ERR_CANCELED, e, n),
                this.name = "CanceledError"
            }
            N.inherits(dt, F, {
                __CANCEL__: !0
            });
            var pt = Z.isStandardBrowserEnv ? {
                write: function(t, e, n, i, r, s) {
                    const o = [];
                    o.push(t + "=" + encodeURIComponent(e)),
                    N.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()),
                    N.isString(i) && o.push("path=" + i),
                    N.isString(r) && o.push("domain=" + r),
                    !0 === s && o.push("secure"),
                    document.cookie = o.join("; ")
                },
                read: function(t) {
                    const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
                    return e ? decodeURIComponent(e[3]) : null
                },
                remove: function(t) {
                    this.write(t, "", Date.now() - 864e5)
                }
            } : {
                write: function() {},
                read: function() {
                    return null
                },
                remove: function() {}
            };
            function ft(t, e) {
                return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) ? function(t, e) {
                    return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
                }(t, e) : e
            }
            var At = Z.isStandardBrowserEnv ? function() {
                const t = /(msie|trident)/i.test(navigator.userAgent)
                  , e = document.createElement("a");
                let n;
                function i(n) {
                    let i = n;
                    return t && (e.setAttribute("href", i),
                    i = e.href),
                    e.setAttribute("href", i),
                    {
                        href: e.href,
                        protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                        host: e.host,
                        search: e.search ? e.search.replace(/^\?/, "") : "",
                        hash: e.hash ? e.hash.replace(/^#/, "") : "",
                        hostname: e.hostname,
                        port: e.port,
                        pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname
                    }
                }
                return n = i(window.location.href),
                function(t) {
                    const e = N.isString(t) ? i(t) : t;
                    return e.protocol === n.protocol && e.host === n.host
                }
            }() : function() {
                return !0
            }
            ;
            function gt(t, e) {
                let n = 0;
                const i = function(t, e) {
                    t = t || 10;
                    const n = new Array(t)
                      , i = new Array(t);
                    let r, s = 0, o = 0;
                    return e = void 0 !== e ? e : 1e3,
                    function(a) {
                        const l = Date.now()
                          , c = i[o];
                        r || (r = l),
                        n[s] = a,
                        i[s] = l;
                        let u = o
                          , h = 0;
                        for (; u !== s; )
                            h += n[u++],
                            u %= t;
                        if (s = (s + 1) % t,
                        s === o && (o = (o + 1) % t),
                        l - r < e)
                            return;
                        const d = c && l - c;
                        return d ? Math.round(1e3 * h / d) : void 0
                    }
                }(50, 250);
                return r=>{
                    const s = r.loaded
                      , o = r.lengthComputable ? r.total : void 0
                      , a = s - n
                      , l = i(a);
                    n = s;
                    const c = {
                        loaded: s,
                        total: o,
                        progress: o ? s / o : void 0,
                        bytes: a,
                        rate: l || void 0,
                        estimated: l && o && s <= o ? (o - s) / l : void 0,
                        event: r
                    };
                    c[e ? "download" : "upload"] = !0,
                    t(c)
                }
            }
            const mt = {
                http: null,
                xhr: "undefined" != typeof XMLHttpRequest && function(t) {
                    return new Promise((function(e, n) {
                        let i = t.data;
                        const r = ct.from(t.headers).normalize()
                          , s = t.responseType;
                        let o;
                        function a() {
                            t.cancelToken && t.cancelToken.unsubscribe(o),
                            t.signal && t.signal.removeEventListener("abort", o)
                        }
                        N.isFormData(i) && (Z.isStandardBrowserEnv || Z.isStandardBrowserWebWorkerEnv ? r.setContentType(!1) : r.setContentType("multipart/form-data;", !1));
                        let l = new XMLHttpRequest;
                        if (t.auth) {
                            const e = t.auth.username || ""
                              , n = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
                            r.set("Authorization", "Basic " + btoa(e + ":" + n))
                        }
                        const c = ft(t.baseURL, t.url);
                        function u() {
                            if (!l)
                                return;
                            const i = ct.from("getAllResponseHeaders"in l && l.getAllResponseHeaders());
                            !function(t, e, n) {
                                const i = n.config.validateStatus;
                                n.status && i && !i(n.status) ? e(new F("Request failed with status code " + n.status,[F.ERR_BAD_REQUEST, F.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : t(n)
                            }((function(t) {
                                e(t),
                                a()
                            }
                            ), (function(t) {
                                n(t),
                                a()
                            }
                            ), {
                                data: s && "text" !== s && "json" !== s ? l.response : l.responseText,
                                status: l.status,
                                statusText: l.statusText,
                                headers: i,
                                config: t,
                                request: l
                            }),
                            l = null
                        }
                        if (l.open(t.method.toUpperCase(), K(c, t.params, t.paramsSerializer), !0),
                        l.timeout = t.timeout,
                        "onloadend"in l ? l.onloadend = u : l.onreadystatechange = function() {
                            l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(u)
                        }
                        ,
                        l.onabort = function() {
                            l && (n(new F("Request aborted",F.ECONNABORTED,t,l)),
                            l = null)
                        }
                        ,
                        l.onerror = function() {
                            n(new F("Network Error",F.ERR_NETWORK,t,l)),
                            l = null
                        }
                        ,
                        l.ontimeout = function() {
                            let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
                            const i = t.transitional || $;
                            t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                            n(new F(e,i.clarifyTimeoutError ? F.ETIMEDOUT : F.ECONNABORTED,t,l)),
                            l = null
                        }
                        ,
                        Z.isStandardBrowserEnv) {
                            const e = (t.withCredentials || At(c)) && t.xsrfCookieName && pt.read(t.xsrfCookieName);
                            e && r.set(t.xsrfHeaderName, e)
                        }
                        void 0 === i && r.setContentType(null),
                        "setRequestHeader"in l && N.forEach(r.toJSON(), (function(t, e) {
                            l.setRequestHeader(e, t)
                        }
                        )),
                        N.isUndefined(t.withCredentials) || (l.withCredentials = !!t.withCredentials),
                        s && "json" !== s && (l.responseType = t.responseType),
                        "function" == typeof t.onDownloadProgress && l.addEventListener("progress", gt(t.onDownloadProgress, !0)),
                        "function" == typeof t.onUploadProgress && l.upload && l.upload.addEventListener("progress", gt(t.onUploadProgress)),
                        (t.cancelToken || t.signal) && (o = e=>{
                            l && (n(!e || e.type ? new dt(null,t,l) : e),
                            l.abort(),
                            l = null)
                        }
                        ,
                        t.cancelToken && t.cancelToken.subscribe(o),
                        t.signal && (t.signal.aborted ? o() : t.signal.addEventListener("abort", o)));
                        const h = function(t) {
                            const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                            return e && e[1] || ""
                        }(c);
                        h && -1 === Z.protocols.indexOf(h) ? n(new F("Unsupported protocol " + h + ":",F.ERR_BAD_REQUEST,t)) : l.send(i || null)
                    }
                    ))
                }
            };
            N.forEach(mt, ((t,e)=>{
                if (t) {
                    try {
                        Object.defineProperty(t, "name", {
                            value: e
                        })
                    } catch (t) {}
                    Object.defineProperty(t, "adapterName", {
                        value: e
                    })
                }
            }
            ));
            var vt = t=>{
                t = N.isArray(t) ? t : [t];
                const {length: e} = t;
                let n, i;
                for (let r = 0; r < e && (n = t[r],
                !(i = N.isString(n) ? mt[n.toLowerCase()] : n)); r++)
                    ;
                if (!i) {
                    if (!1 === i)
                        throw new F(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT");
                    throw new Error(N.hasOwnProp(mt, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`)
                }
                if (!N.isFunction(i))
                    throw new TypeError("adapter is not a function");
                return i
            }
            ;
            function yt(t) {
                if (t.cancelToken && t.cancelToken.throwIfRequested(),
                t.signal && t.signal.aborted)
                    throw new dt(null,t)
            }
            function _t(t) {
                yt(t),
                t.headers = ct.from(t.headers),
                t.data = ut.call(t, t.transformRequest),
                -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1);
                return vt(t.adapter || nt.adapter)(t).then((function(e) {
                    return yt(t),
                    e.data = ut.call(t, t.transformResponse, e),
                    e.headers = ct.from(e.headers),
                    e
                }
                ), (function(e) {
                    return ht(e) || (yt(t),
                    e && e.response && (e.response.data = ut.call(t, t.transformResponse, e.response),
                    e.response.headers = ct.from(e.response.headers))),
                    Promise.reject(e)
                }
                ))
            }
            const Et = t=>t instanceof ct ? t.toJSON() : t;
            function bt(t, e) {
                e = e || {};
                const n = {};
                function i(t, e, n) {
                    return N.isPlainObject(t) && N.isPlainObject(e) ? N.merge.call({
                        caseless: n
                    }, t, e) : N.isPlainObject(e) ? N.merge({}, e) : N.isArray(e) ? e.slice() : e
                }
                function r(t, e, n) {
                    return N.isUndefined(e) ? N.isUndefined(t) ? void 0 : i(void 0, t, n) : i(t, e, n)
                }
                function s(t, e) {
                    if (!N.isUndefined(e))
                        return i(void 0, e)
                }
                function o(t, e) {
                    return N.isUndefined(e) ? N.isUndefined(t) ? void 0 : i(void 0, t) : i(void 0, e)
                }
                function a(n, r, s) {
                    return s in e ? i(n, r) : s in t ? i(void 0, n) : void 0
                }
                const l = {
                    url: s,
                    method: s,
                    data: s,
                    baseURL: o,
                    transformRequest: o,
                    transformResponse: o,
                    paramsSerializer: o,
                    timeout: o,
                    timeoutMessage: o,
                    withCredentials: o,
                    adapter: o,
                    responseType: o,
                    xsrfCookieName: o,
                    xsrfHeaderName: o,
                    onUploadProgress: o,
                    onDownloadProgress: o,
                    decompress: o,
                    maxContentLength: o,
                    maxBodyLength: o,
                    beforeRedirect: o,
                    transport: o,
                    httpAgent: o,
                    httpsAgent: o,
                    cancelToken: o,
                    socketPath: o,
                    responseEncoding: o,
                    validateStatus: a,
                    headers: (t,e)=>r(Et(t), Et(e), !0)
                };
                return N.forEach(Object.keys(Object.assign({}, t, e)), (function(i) {
                    const s = l[i] || r
                      , o = s(t[i], e[i], i);
                    N.isUndefined(o) && s !== a || (n[i] = o)
                }
                )),
                n
            }
            const xt = "1.5.0"
              , wt = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach(((t,e)=>{
                wt[t] = function(n) {
                    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t
                }
            }
            ));
            const St = {};
            wt.transitional = function(t, e, n) {
                function i(t, e) {
                    return "[Axios v1.5.0] Transitional option '" + t + "'" + e + (n ? ". " + n : "")
                }
                return (n,r,s)=>{
                    if (!1 === t)
                        throw new F(i(r, " has been removed" + (e ? " in " + e : "")),F.ERR_DEPRECATED);
                    return e && !St[r] && (St[r] = !0,
                    console.warn(i(r, " has been deprecated since v" + e + " and will be removed in the near future"))),
                    !t || t(n, r, s)
                }
            }
            ;
            var Ct = {
                assertOptions: function(t, e, n) {
                    if ("object" != typeof t)
                        throw new F("options must be an object",F.ERR_BAD_OPTION_VALUE);
                    const i = Object.keys(t);
                    let r = i.length;
                    for (; r-- > 0; ) {
                        const s = i[r]
                          , o = e[s];
                        if (o) {
                            const e = t[s]
                              , n = void 0 === e || o(e, s, t);
                            if (!0 !== n)
                                throw new F("option " + s + " must be " + n,F.ERR_BAD_OPTION_VALUE)
                        } else if (!0 !== n)
                            throw new F("Unknown option " + s,F.ERR_BAD_OPTION)
                    }
                },
                validators: wt
            };
            const Mt = Ct.validators;
            class It {
                constructor(t) {
                    this.defaults = t,
                    this.interceptors = {
                        request: new J,
                        response: new J
                    }
                }
                request(t, e) {
                    "string" == typeof t ? (e = e || {}).url = t : e = t || {},
                    e = bt(this.defaults, e);
                    const {transitional: n, paramsSerializer: i, headers: r} = e;
                    void 0 !== n && Ct.assertOptions(n, {
                        silentJSONParsing: Mt.transitional(Mt.boolean),
                        forcedJSONParsing: Mt.transitional(Mt.boolean),
                        clarifyTimeoutError: Mt.transitional(Mt.boolean)
                    }, !1),
                    null != i && (N.isFunction(i) ? e.paramsSerializer = {
                        serialize: i
                    } : Ct.assertOptions(i, {
                        encode: Mt.function,
                        serialize: Mt.function
                    }, !0)),
                    e.method = (e.method || this.defaults.method || "get").toLowerCase();
                    let s = r && N.merge(r.common, r[e.method]);
                    r && N.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (t=>{
                        delete r[t]
                    }
                    )),
                    e.headers = ct.concat(s, r);
                    const o = [];
                    let a = !0;
                    this.interceptors.request.forEach((function(t) {
                        "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous,
                        o.unshift(t.fulfilled, t.rejected))
                    }
                    ));
                    const l = [];
                    let c;
                    this.interceptors.response.forEach((function(t) {
                        l.push(t.fulfilled, t.rejected)
                    }
                    ));
                    let u, h = 0;
                    if (!a) {
                        const t = [_t.bind(this), void 0];
                        for (t.unshift.apply(t, o),
                        t.push.apply(t, l),
                        u = t.length,
                        c = Promise.resolve(e); h < u; )
                            c = c.then(t[h++], t[h++]);
                        return c
                    }
                    u = o.length;
                    let d = e;
                    for (h = 0; h < u; ) {
                        const t = o[h++]
                          , e = o[h++];
                        try {
                            d = t(d)
                        } catch (t) {
                            e.call(this, t);
                            break
                        }
                    }
                    try {
                        c = _t.call(this, d)
                    } catch (t) {
                        return Promise.reject(t)
                    }
                    for (h = 0,
                    u = l.length; h < u; )
                        c = c.then(l[h++], l[h++]);
                    return c
                }
                getUri(t) {
                    return K(ft((t = bt(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer)
                }
            }
            N.forEach(["delete", "get", "head", "options"], (function(t) {
                It.prototype[t] = function(e, n) {
                    return this.request(bt(n || {}, {
                        method: t,
                        url: e,
                        data: (n || {}).data
                    }))
                }
            }
            )),
            N.forEach(["post", "put", "patch"], (function(t) {
                function e(e) {
                    return function(n, i, r) {
                        return this.request(bt(r || {}, {
                            method: t,
                            headers: e ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url: n,
                            data: i
                        }))
                    }
                }
                It.prototype[t] = e(),
                It.prototype[t + "Form"] = e(!0)
            }
            ));
            var Tt = It;
            class Bt {
                constructor(t) {
                    if ("function" != typeof t)
                        throw new TypeError("executor must be a function.");
                    let e;
                    this.promise = new Promise((function(t) {
                        e = t
                    }
                    ));
                    const n = this;
                    this.promise.then((t=>{
                        if (!n._listeners)
                            return;
                        let e = n._listeners.length;
                        for (; e-- > 0; )
                            n._listeners[e](t);
                        n._listeners = null
                    }
                    )),
                    this.promise.then = t=>{
                        let e;
                        const i = new Promise((t=>{
                            n.subscribe(t),
                            e = t
                        }
                        )).then(t);
                        return i.cancel = function() {
                            n.unsubscribe(e)
                        }
                        ,
                        i
                    }
                    ,
                    t((function(t, i, r) {
                        n.reason || (n.reason = new dt(t,i,r),
                        e(n.reason))
                    }
                    ))
                }
                throwIfRequested() {
                    if (this.reason)
                        throw this.reason
                }
                subscribe(t) {
                    this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t]
                }
                unsubscribe(t) {
                    if (!this._listeners)
                        return;
                    const e = this._listeners.indexOf(t);
                    -1 !== e && this._listeners.splice(e, 1)
                }
                static source() {
                    let t;
                    return {
                        token: new Bt((function(e) {
                            t = e
                        }
                        )),
                        cancel: t
                    }
                }
            }
            var Rt = Bt;
            const Lt = {
                Continue: 100,
                SwitchingProtocols: 101,
                Processing: 102,
                EarlyHints: 103,
                Ok: 200,
                Created: 201,
                Accepted: 202,
                NonAuthoritativeInformation: 203,
                NoContent: 204,
                ResetContent: 205,
                PartialContent: 206,
                MultiStatus: 207,
                AlreadyReported: 208,
                ImUsed: 226,
                MultipleChoices: 300,
                MovedPermanently: 301,
                Found: 302,
                SeeOther: 303,
                NotModified: 304,
                UseProxy: 305,
                Unused: 306,
                TemporaryRedirect: 307,
                PermanentRedirect: 308,
                BadRequest: 400,
                Unauthorized: 401,
                PaymentRequired: 402,
                Forbidden: 403,
                NotFound: 404,
                MethodNotAllowed: 405,
                NotAcceptable: 406,
                ProxyAuthenticationRequired: 407,
                RequestTimeout: 408,
                Conflict: 409,
                Gone: 410,
                LengthRequired: 411,
                PreconditionFailed: 412,
                PayloadTooLarge: 413,
                UriTooLong: 414,
                UnsupportedMediaType: 415,
                RangeNotSatisfiable: 416,
                ExpectationFailed: 417,
                ImATeapot: 418,
                MisdirectedRequest: 421,
                UnprocessableEntity: 422,
                Locked: 423,
                FailedDependency: 424,
                TooEarly: 425,
                UpgradeRequired: 426,
                PreconditionRequired: 428,
                TooManyRequests: 429,
                RequestHeaderFieldsTooLarge: 431,
                UnavailableForLegalReasons: 451,
                InternalServerError: 500,
                NotImplemented: 501,
                BadGateway: 502,
                ServiceUnavailable: 503,
                GatewayTimeout: 504,
                HttpVersionNotSupported: 505,
                VariantAlsoNegotiates: 506,
                InsufficientStorage: 507,
                LoopDetected: 508,
                NotExtended: 510,
                NetworkAuthenticationRequired: 511
            };
            Object.entries(Lt).forEach((([t,e])=>{
                Lt[e] = t
            }
            ));
            var Dt = Lt;
            const Pt = function t(e) {
                const n = new Tt(e)
                  , r = i(Tt.prototype.request, n);
                return N.extend(r, Tt.prototype, n, {
                    allOwnKeys: !0
                }),
                N.extend(r, n, null, {
                    allOwnKeys: !0
                }),
                r.create = function(n) {
                    return t(bt(e, n))
                }
                ,
                r
            }(nt);
            Pt.Axios = Tt,
            Pt.CanceledError = dt,
            Pt.CancelToken = Rt,
            Pt.isCancel = ht,
            Pt.VERSION = xt,
            Pt.toFormData = W,
            Pt.AxiosError = F,
            Pt.Cancel = Pt.CanceledError,
            Pt.all = function(t) {
                return Promise.all(t)
            }
            ,
            Pt.spread = function(t) {
                return function(e) {
                    return t.apply(null, e)
                }
            }
            ,
            Pt.isAxiosError = function(t) {
                return N.isObject(t) && !0 === t.isAxiosError
            }
            ,
            Pt.mergeConfig = bt,
            Pt.AxiosHeaders = ct,
            Pt.formToJSON = t=>tt(N.isHTMLForm(t) ? new FormData(t) : t),
            Pt.getAdapter = vt,
            Pt.HttpStatusCode = Dt,
            Pt.default = Pt,
            t.exports = Pt
        }
    }
      , e = {};
    function n(i) {
        var r = e[i];
        if (void 0 !== r)
            return r.exports;
        var s = e[i] = {
            exports: {}
        };
        return t[i](s, s.exports, n),
        s.exports
    }
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, {
            a: e
        }),
        e
    }
    ,
    n.d = function(t, e) {
        for (var i in e)
            n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            })
    }
    ,
    n.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window)
                return window
        }
    }(),
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }
    ,
    function() {
        var t;
        n.g.importScripts && (t = n.g.location + "");
        var e = n.g.document;
        if (!t && e && (e.currentScript && (t = e.currentScript.src),
        !t)) {
            var i = e.getElementsByTagName("script");
            if (i.length)
                for (var r = i.length - 1; r > -1 && !t; )
                    t = i[r--].src
        }
        if (!t)
            throw new Error("Automatic publicPath is not supported in this browser");
        t = t.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
        n.p = t + "../"
    }(),
    function() {
        "use strict";
        n(1983);
        var t, e = (t = n(115)) && t.__esModule ? t : {
            default: t
        };
        e.default._babelPolyfill && "undefined" != typeof console && console.warn && console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."),
        e.default._babelPolyfill = !0
    }(),
    function() {
        "use strict";
        var t = {};
        function e(t) {
            for (var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
                n[i - 1] = arguments[i];
            throw Error("[Immer] minified error nr: " + t + (n.length ? " " + n.map((function(t) {
                return "'" + t + "'"
            }
            )).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf")
        }
        function i(t) {
            return !!t && !!t[q]
        }
        function r(t) {
            var e;
            return !!t && (function(t) {
                if (!t || "object" != typeof t)
                    return !1;
                var e = Object.getPrototypeOf(t);
                if (null === e)
                    return !0;
                var n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
                return n === Object || "function" == typeof n && Function.toString.call(n) === j
            }(t) || Array.isArray(t) || !!t[W] || !!(null === (e = t.constructor) || void 0 === e ? void 0 : e[W]) || h(t) || d(t))
        }
        function s(t, e, n) {
            void 0 === n && (n = !1),
            0 === o(t) ? (n ? Object.keys : X)(t).forEach((function(i) {
                n && "symbol" == typeof i || e(i, t[i], t)
            }
            )) : t.forEach((function(n, i) {
                return e(i, n, t)
            }
            ))
        }
        function o(t) {
            var e = t[q];
            return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(t) ? 1 : h(t) ? 2 : d(t) ? 3 : 0
        }
        function a(t, e) {
            return 2 === o(t) ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e)
        }
        function l(t, e) {
            return 2 === o(t) ? t.get(e) : t[e]
        }
        function c(t, e, n) {
            var i = o(t);
            2 === i ? t.set(e, n) : 3 === i ? t.add(n) : t[e] = n
        }
        function u(t, e) {
            return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
        }
        function h(t) {
            return G && t instanceof Map
        }
        function d(t) {
            return H && t instanceof Set
        }
        function p(t) {
            return t.o || t.t
        }
        function f(t) {
            if (Array.isArray(t))
                return Array.prototype.slice.call(t);
            var e = Y(t);
            delete e[q];
            for (var n = X(e), i = 0; i < n.length; i++) {
                var r = n[i]
                  , s = e[r];
                !1 === s.writable && (s.writable = !0,
                s.configurable = !0),
                (s.get || s.set) && (e[r] = {
                    configurable: !0,
                    writable: !0,
                    enumerable: s.enumerable,
                    value: t[r]
                })
            }
            return Object.create(Object.getPrototypeOf(t), e)
        }
        function A(t, e) {
            return void 0 === e && (e = !1),
            m(t) || i(t) || !r(t) || (o(t) > 1 && (t.set = t.add = t.clear = t.delete = g),
            Object.freeze(t),
            e && s(t, (function(t, e) {
                return A(e, !0)
            }
            ), !0)),
            t
        }
        function g() {
            e(2)
        }
        function m(t) {
            return null == t || "object" != typeof t || Object.isFrozen(t)
        }
        function v(t) {
            var n = K[t];
            return n || e(18, t),
            n
        }
        function y(t, e) {
            K[t] || (K[t] = e)
        }
        function _() {
            return Q
        }
        function E(t, e) {
            e && (v("Patches"),
            t.u = [],
            t.s = [],
            t.v = e)
        }
        function b(t) {
            x(t),
            t.p.forEach(S),
            t.p = null
        }
        function x(t) {
            t === Q && (Q = t.l)
        }
        function w(t) {
            return Q = {
                p: [],
                l: Q,
                h: t,
                m: !0,
                _: 0
            }
        }
        function S(t) {
            var e = t[q];
            0 === e.i || 1 === e.i ? e.j() : e.g = !0
        }
        function C(t, n) {
            n._ = n.p.length;
            var i = n.p[0]
              , s = void 0 !== t && t !== i;
            return n.h.O || v("ES5").S(n, t, s),
            s ? (i[q].P && (b(n),
            e(4)),
            r(t) && (t = M(n, t),
            n.l || T(n, t)),
            n.u && v("Patches").M(i[q].t, t, n.u, n.s)) : t = M(n, i, []),
            b(n),
            n.u && n.v(n.u, n.s),
            t !== V ? t : void 0
        }
        function M(t, e, n) {
            if (m(e))
                return e;
            var i = e[q];
            if (!i)
                return s(e, (function(r, s) {
                    return I(t, i, e, r, s, n)
                }
                ), !0),
                e;
            if (i.A !== t)
                return e;
            if (!i.P)
                return T(t, i.t, !0),
                i.t;
            if (!i.I) {
                i.I = !0,
                i.A._--;
                var r = 4 === i.i || 5 === i.i ? i.o = f(i.k) : i.o
                  , o = r
                  , a = !1;
                3 === i.i && (o = new Set(r),
                r.clear(),
                a = !0),
                s(o, (function(e, s) {
                    return I(t, i, r, e, s, n, a)
                }
                )),
                T(t, r, !1),
                n && t.u && v("Patches").N(i, n, t.u, t.s)
            }
            return i.o
        }
        function I(t, e, n, s, o, l, u) {
            if (i(o)) {
                var h = M(t, o, l && e && 3 !== e.i && !a(e.R, s) ? l.concat(s) : void 0);
                if (c(n, s, h),
                !i(h))
                    return;
                t.m = !1
            } else
                u && n.add(o);
            if (r(o) && !m(o)) {
                if (!t.h.D && t._ < 1)
                    return;
                M(t, o),
                e && e.A.l || T(t, o)
            }
        }
        function T(t, e, n) {
            void 0 === n && (n = !1),
            !t.l && t.h.D && t.m && A(e, n)
        }
        function B(t, e) {
            var n = t[q];
            return (n ? p(n) : t)[e]
        }
        function R(t, e) {
            if (e in t)
                for (var n = Object.getPrototypeOf(t); n; ) {
                    var i = Object.getOwnPropertyDescriptor(n, e);
                    if (i)
                        return i;
                    n = Object.getPrototypeOf(n)
                }
        }
        function L(t) {
            t.P || (t.P = !0,
            t.l && L(t.l))
        }
        function D(t) {
            t.o || (t.o = f(t.t))
        }
        function P(t, e, n) {
            var i = h(e) ? v("MapSet").F(e, n) : d(e) ? v("MapSet").T(e, n) : t.O ? function(t, e) {
                var n = Array.isArray(t)
                  , i = {
                    i: n ? 1 : 0,
                    A: e ? e.A : _(),
                    P: !1,
                    I: !1,
                    R: {},
                    l: e,
                    t: t,
                    k: null,
                    o: null,
                    j: null,
                    C: !1
                }
                  , r = i
                  , s = J;
                n && (r = [i],
                s = $);
                var o = Proxy.revocable(r, s)
                  , a = o.revoke
                  , l = o.proxy;
                return i.k = l,
                i.j = a,
                l
            }(e, n) : v("ES5").J(e, n);
            return (n ? n.A : _()).p.push(i),
            i
        }
        function U(t) {
            return i(t) || e(22, t),
            function t(e) {
                if (!r(e))
                    return e;
                var n, i = e[q], a = o(e);
                if (i) {
                    if (!i.P && (i.i < 4 || !v("ES5").K(i)))
                        return i.t;
                    i.I = !0,
                    n = O(e, a),
                    i.I = !1
                } else
                    n = O(e, a);
                return s(n, (function(e, r) {
                    i && l(i.t, e) === r || c(n, e, t(r))
                }
                )),
                3 === a ? new Set(n) : n
            }(t)
        }
        function O(t, e) {
            switch (e) {
            case 2:
                return new Map(t);
            case 3:
                return Array.from(t)
            }
            return f(t)
        }
        function N() {
            function t(t, e) {
                var n = o[t];
                return n ? n.enumerable = e : o[t] = n = {
                    configurable: !0,
                    enumerable: e,
                    get: function() {
                        var e = this[q];
                        return J.get(e, t)
                    },
                    set: function(e) {
                        var n = this[q];
                        J.set(n, t, e)
                    }
                },
                n
            }
            function e(t) {
                for (var e = t.length - 1; e >= 0; e--) {
                    var i = t[e][q];
                    if (!i.P)
                        switch (i.i) {
                        case 5:
                            r(i) && L(i);
                            break;
                        case 4:
                            n(i) && L(i)
                        }
                }
            }
            function n(t) {
                for (var e = t.t, n = t.k, i = X(n), r = i.length - 1; r >= 0; r--) {
                    var s = i[r];
                    if (s !== q) {
                        var o = e[s];
                        if (void 0 === o && !a(e, s))
                            return !0;
                        var l = n[s]
                          , c = l && l[q];
                        if (c ? c.t !== o : !u(l, o))
                            return !0
                    }
                }
                var h = !!e[q];
                return i.length !== X(e).length + (h ? 0 : 1)
            }
            function r(t) {
                var e = t.k;
                if (e.length !== t.t.length)
                    return !0;
                var n = Object.getOwnPropertyDescriptor(e, e.length - 1);
                if (n && !n.get)
                    return !0;
                for (var i = 0; i < e.length; i++)
                    if (!e.hasOwnProperty(i))
                        return !0;
                return !1
            }
            var o = {};
            y("ES5", {
                J: function(e, n) {
                    var i = Array.isArray(e)
                      , r = function(e, n) {
                        if (e) {
                            for (var i = Array(n.length), r = 0; r < n.length; r++)
                                Object.defineProperty(i, "" + r, t(r, !0));
                            return i
                        }
                        var s = Y(n);
                        delete s[q];
                        for (var o = X(s), a = 0; a < o.length; a++) {
                            var l = o[a];
                            s[l] = t(l, e || !!s[l].enumerable)
                        }
                        return Object.create(Object.getPrototypeOf(n), s)
                    }(i, e)
                      , s = {
                        i: i ? 5 : 4,
                        A: n ? n.A : _(),
                        P: !1,
                        I: !1,
                        R: {},
                        l: n,
                        t: e,
                        k: r,
                        o: null,
                        g: !1,
                        C: !1
                    };
                    return Object.defineProperty(r, q, {
                        value: s,
                        writable: !0
                    }),
                    r
                },
                S: function(t, n, o) {
                    o ? i(n) && n[q].A === t && e(t.p) : (t.u && function t(e) {
                        if (e && "object" == typeof e) {
                            var n = e[q];
                            if (n) {
                                var i = n.t
                                  , o = n.k
                                  , l = n.R
                                  , c = n.i;
                                if (4 === c)
                                    s(o, (function(e) {
                                        e !== q && (void 0 !== i[e] || a(i, e) ? l[e] || t(o[e]) : (l[e] = !0,
                                        L(n)))
                                    }
                                    )),
                                    s(i, (function(t) {
                                        void 0 !== o[t] || a(o, t) || (l[t] = !1,
                                        L(n))
                                    }
                                    ));
                                else if (5 === c) {
                                    if (r(n) && (L(n),
                                    l.length = !0),
                                    o.length < i.length)
                                        for (var u = o.length; u < i.length; u++)
                                            l[u] = !1;
                                    else
                                        for (var h = i.length; h < o.length; h++)
                                            l[h] = !0;
                                    for (var d = Math.min(o.length, i.length), p = 0; p < d; p++)
                                        o.hasOwnProperty(p) || (l[p] = !0),
                                        void 0 === l[p] && t(o[p])
                                }
                            }
                        }
                    }(t.p[0]),
                    e(t.p))
                },
                K: function(t) {
                    return 4 === t.i ? n(t) : r(t)
                }
            })
        }
        n.r(t),
        n.d(t, {
            addNewKey: function() {
                return fe
            },
            changeMaterial: function() {
                return dn
            },
            default: function() {
                return vn
            },
            updateAR: function() {
                return Ae
            },
            updateActionIconId: function() {
                return ln
            },
            updateAndroidSrc: function() {
                return nn
            },
            updateArModes: function() {
                return Fe
            },
            updateArPlacement: function() {
                return ge
            },
            updateArScale: function() {
                return me
            },
            updateArbtn: function() {
                return Xe
            },
            updateArbtnPosition: function() {
                return Ye
            },
            updateArbtnSubtitle: function() {
                return Je
            },
            updateArbtnTitle: function() {
                return Ke
            },
            updateArrSpeed: function() {
                return Re
            },
            updateBackgroundColor: function() {
                return He
            },
            updateBaseApiUrl: function() {
                return sn
            },
            updateBlockSelector: function() {
                return xe
            },
            updateButtonQR: function() {
                return rn
            },
            updateCameraControls: function() {
                return ve
            },
            updateCameraOrbit: function() {
                return We
            },
            updateChangeMaterial: function() {
                return Me
            },
            updateClassMaterial: function() {
                return hn
            },
            updateCurrentMaterial: function() {
                return Ie
            },
            updateCurrentPlacement: function() {
                return Se
            },
            updateCurrentQuality: function() {
                return Oe
            },
            updateCustomMetric: function() {
                return un
            },
            updateData: function() {
                return Ue
            },
            updateDisableZoom: function() {
                return ye
            },
            updateEyebrowIcon: function() {
                return pn
            },
            updateEyebrowIconId: function() {
                return Ge
            },
            updateFirstLoad: function() {
                return Ne
            },
            updateHdri: function() {
                return An
            },
            updateHdriAsBackground: function() {
                return fn
            },
            updateIcon: function() {
                return Qe
            },
            updateIosSrc: function() {
                return Ee
            },
            updateIsStartSessionBefore: function() {
                return qe
            },
            updateLoadingType: function() {
                return Te
            },
            updateMaterials: function() {
                return Ce
            },
            updateMaxCameraOrbit: function() {
                return ze
            },
            updateMinCameraOrbit: function() {
                return Ve
            },
            updateModelSize: function() {
                return Le
            },
            updateOptimization: function() {
                return Be
            },
            updateOurMetric: function() {
                return cn
            },
            updatePoster: function() {
                return _e
            },
            updateProgressMain: function() {
                return mn
            },
            updateProgressMaterialCount: function() {
                return gn
            },
            updateQrColor: function() {
                return $e
            },
            updateQrImage: function() {
                return tn
            },
            updateQrRounded: function() {
                return Ze
            },
            updateQualities: function() {
                return Pe
            },
            updateSpeed: function() {
                return De
            },
            updateSrc: function() {
                return en
            },
            updateToggleAR: function() {
                return je
            },
            updateUrlIcon: function() {
                return ke
            },
            updateUrlParams: function() {
                return be
            },
            updateViewerUrl: function() {
                return on
            },
            updateWidget: function() {
                return we
            },
            updateWidgetId: function() {
                return an
            }
        });
        var F, Q, k = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), G = "undefined" != typeof Map, H = "undefined" != typeof Set, z = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, V = k ? Symbol.for("immer-nothing") : ((F = {})["immer-nothing"] = !0,
        F), W = k ? Symbol.for("immer-draftable") : "__$immer_draftable", q = k ? Symbol.for("immer-state") : "__$immer_state", j = ("undefined" != typeof Symbol && Symbol.iterator,
        "" + Object.prototype.constructor), X = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(t) {
            return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
        }
        : Object.getOwnPropertyNames, Y = Object.getOwnPropertyDescriptors || function(t) {
            var e = {};
            return X(t).forEach((function(n) {
                e[n] = Object.getOwnPropertyDescriptor(t, n)
            }
            )),
            e
        }
        , K = {}, J = {
            get: function(t, e) {
                if (e === q)
                    return t;
                var n = p(t);
                if (!a(n, e))
                    return function(t, e, n) {
                        var i, r = R(e, n);
                        return r ? "value"in r ? r.value : null === (i = r.get) || void 0 === i ? void 0 : i.call(t.k) : void 0
                    }(t, n, e);
                var i = n[e];
                return t.I || !r(i) ? i : i === B(t.t, e) ? (D(t),
                t.o[e] = P(t.A.h, i, t)) : i
            },
            has: function(t, e) {
                return e in p(t)
            },
            ownKeys: function(t) {
                return Reflect.ownKeys(p(t))
            },
            set: function(t, e, n) {
                var i = R(p(t), e);
                if (null == i ? void 0 : i.set)
                    return i.set.call(t.k, n),
                    !0;
                if (!t.P) {
                    var r = B(p(t), e)
                      , s = null == r ? void 0 : r[q];
                    if (s && s.t === n)
                        return t.o[e] = n,
                        t.R[e] = !1,
                        !0;
                    if (u(n, r) && (void 0 !== n || a(t.t, e)))
                        return !0;
                    D(t),
                    L(t)
                }
                return t.o[e] === n && (void 0 !== n || e in t.o) || Number.isNaN(n) && Number.isNaN(t.o[e]) || (t.o[e] = n,
                t.R[e] = !0),
                !0
            },
            deleteProperty: function(t, e) {
                return void 0 !== B(t.t, e) || e in t.t ? (t.R[e] = !1,
                D(t),
                L(t)) : delete t.R[e],
                t.o && delete t.o[e],
                !0
            },
            getOwnPropertyDescriptor: function(t, e) {
                var n = p(t)
                  , i = Reflect.getOwnPropertyDescriptor(n, e);
                return i ? {
                    writable: !0,
                    configurable: 1 !== t.i || "length" !== e,
                    enumerable: i.enumerable,
                    value: n[e]
                } : i
            },
            defineProperty: function() {
                e(11)
            },
            getPrototypeOf: function(t) {
                return Object.getPrototypeOf(t.t)
            },
            setPrototypeOf: function() {
                e(12)
            }
        }, $ = {};
        s(J, (function(t, e) {
            $[t] = function() {
                return arguments[0] = arguments[0][0],
                e.apply(this, arguments)
            }
        }
        )),
        $.deleteProperty = function(t, e) {
            return $.set.call(this, t, e, void 0)
        }
        ,
        $.set = function(t, e, n) {
            return J.set.call(this, t[0], e, n, t[0])
        }
        ;
        var Z = function() {
            function t(t) {
                var n = this;
                this.O = z,
                this.D = !0,
                this.produce = function(t, i, s) {
                    if ("function" == typeof t && "function" != typeof i) {
                        var o = i;
                        i = t;
                        var a = n;
                        return function(t) {
                            var e = this;
                            void 0 === t && (t = o);
                            for (var n = arguments.length, r = Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
                                r[s - 1] = arguments[s];
                            return a.produce(t, (function(t) {
                                var n;
                                return (n = i).call.apply(n, [e, t].concat(r))
                            }
                            ))
                        }
                    }
                    var l;
                    if ("function" != typeof i && e(6),
                    void 0 !== s && "function" != typeof s && e(7),
                    r(t)) {
                        var c = w(n)
                          , u = P(n, t, void 0)
                          , h = !0;
                        try {
                            l = i(u),
                            h = !1
                        } finally {
                            h ? b(c) : x(c)
                        }
                        return "undefined" != typeof Promise && l instanceof Promise ? l.then((function(t) {
                            return E(c, s),
                            C(t, c)
                        }
                        ), (function(t) {
                            throw b(c),
                            t
                        }
                        )) : (E(c, s),
                        C(l, c))
                    }
                    if (!t || "object" != typeof t) {
                        if (void 0 === (l = i(t)) && (l = t),
                        l === V && (l = void 0),
                        n.D && A(l, !0),
                        s) {
                            var d = []
                              , p = [];
                            v("Patches").M(t, l, d, p),
                            s(d, p)
                        }
                        return l
                    }
                    e(21, t)
                }
                ,
                this.produceWithPatches = function(t, e) {
                    if ("function" == typeof t)
                        return function(e) {
                            for (var i = arguments.length, r = Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)
                                r[s - 1] = arguments[s];
                            return n.produceWithPatches(e, (function(e) {
                                return t.apply(void 0, [e].concat(r))
                            }
                            ))
                        }
                        ;
                    var i, r, s = n.produce(t, e, (function(t, e) {
                        i = t,
                        r = e
                    }
                    ));
                    return "undefined" != typeof Promise && s instanceof Promise ? s.then((function(t) {
                        return [t, i, r]
                    }
                    )) : [s, i, r]
                }
                ,
                "boolean" == typeof (null == t ? void 0 : t.useProxies) && this.setUseProxies(t.useProxies),
                "boolean" == typeof (null == t ? void 0 : t.autoFreeze) && this.setAutoFreeze(t.autoFreeze)
            }
            var n = t.prototype;
            return n.createDraft = function(t) {
                r(t) || e(8),
                i(t) && (t = U(t));
                var n = w(this)
                  , s = P(this, t, void 0);
                return s[q].C = !0,
                x(n),
                s
            }
            ,
            n.finishDraft = function(t, e) {
                var n = (t && t[q]).A;
                return E(n, e),
                C(void 0, n)
            }
            ,
            n.setAutoFreeze = function(t) {
                this.D = t
            }
            ,
            n.setUseProxies = function(t) {
                t && !z && e(20),
                this.O = t
            }
            ,
            n.applyPatches = function(t, e) {
                var n;
                for (n = e.length - 1; n >= 0; n--) {
                    var r = e[n];
                    if (0 === r.path.length && "replace" === r.op) {
                        t = r.value;
                        break
                    }
                }
                n > -1 && (e = e.slice(n + 1));
                var s = v("Patches").$;
                return i(t) ? s(t, e) : this.produce(t, (function(t) {
                    return s(t, e)
                }
                ))
            }
            ,
            t
        }()
          , tt = new Z
          , et = tt.produce
          , nt = (tt.produceWithPatches.bind(tt),
        tt.setAutoFreeze.bind(tt),
        tt.setUseProxies.bind(tt),
        tt.applyPatches.bind(tt),
        tt.createDraft.bind(tt),
        tt.finishDraft.bind(tt),
        et);
        function it(t) {
            return it = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            }
            : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }
            ,
            it(t)
        }
        function rt(t) {
            var e = function(t, e) {
                if ("object" !== it(t) || null === t)
                    return t;
                var n = t[Symbol.toPrimitive];
                if (void 0 !== n) {
                    var i = n.call(t, e || "default");
                    if ("object" !== it(i))
                        return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" === it(e) ? e : String(e)
        }
        function st(t, e) {
            var n = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var i = Object.getOwnPropertySymbols(t);
                e && (i = i.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }
                ))),
                n.push.apply(n, i)
            }
            return n
        }
        function ot(t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = null != arguments[e] ? arguments[e] : {};
                e % 2 ? st(Object(n), !0).forEach((function(e) {
                    var i, r, s;
                    i = t,
                    r = e,
                    s = n[e],
                    (r = rt(r))in i ? Object.defineProperty(i, r, {
                        value: s,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : i[r] = s
                }
                )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : st(Object(n)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                }
                ))
            }
            return t
        }
        function at(t) {
            return "Minified Redux error #" + t + "; visit https://redux.js.org/Errors?code=" + t + " for the full message or use the non-minified dev environment for full errors. "
        }
        var lt = "function" == typeof Symbol && Symbol.observable || "@@observable"
          , ct = function() {
            return Math.random().toString(36).substring(7).split("").join(".")
        }
          , ut = {
            INIT: "@@redux/INIT" + ct(),
            REPLACE: "@@redux/REPLACE" + ct(),
            PROBE_UNKNOWN_ACTION: function() {
                return "@@redux/PROBE_UNKNOWN_ACTION" + ct()
            }
        };
        function ht(t) {
            if ("object" != typeof t || null === t)
                return !1;
            for (var e = t; null !== Object.getPrototypeOf(e); )
                e = Object.getPrototypeOf(e);
            return Object.getPrototypeOf(t) === e
        }
        function dt(t, e, n) {
            var i;
            if ("function" == typeof e && "function" == typeof n || "function" == typeof n && "function" == typeof arguments[3])
                throw new Error(at(0));
            if ("function" == typeof e && void 0 === n && (n = e,
            e = void 0),
            void 0 !== n) {
                if ("function" != typeof n)
                    throw new Error(at(1));
                return n(dt)(t, e)
            }
            if ("function" != typeof t)
                throw new Error(at(2));
            var r = t
              , s = e
              , o = []
              , a = o
              , l = !1;
            function c() {
                a === o && (a = o.slice())
            }
            function u() {
                if (l)
                    throw new Error(at(3));
                return s
            }
            function h(t) {
                if ("function" != typeof t)
                    throw new Error(at(4));
                if (l)
                    throw new Error(at(5));
                var e = !0;
                return c(),
                a.push(t),
                function() {
                    if (e) {
                        if (l)
                            throw new Error(at(6));
                        e = !1,
                        c();
                        var n = a.indexOf(t);
                        a.splice(n, 1),
                        o = null
                    }
                }
            }
            function d(t) {
                if (!ht(t))
                    throw new Error(at(7));
                if (void 0 === t.type)
                    throw new Error(at(8));
                if (l)
                    throw new Error(at(9));
                try {
                    l = !0,
                    s = r(s, t)
                } finally {
                    l = !1
                }
                for (var e = o = a, n = 0; n < e.length; n++) {
                    (0,
                    e[n])()
                }
                return t
            }
            return d({
                type: ut.INIT
            }),
            (i = {
                dispatch: d,
                subscribe: h,
                getState: u,
                replaceReducer: function(t) {
                    if ("function" != typeof t)
                        throw new Error(at(10));
                    r = t,
                    d({
                        type: ut.REPLACE
                    })
                }
            })[lt] = function() {
                var t, e = h;
                return (t = {
                    subscribe: function(t) {
                        if ("object" != typeof t || null === t)
                            throw new Error(at(11));
                        function n() {
                            t.next && t.next(u())
                        }
                        return n(),
                        {
                            unsubscribe: e(n)
                        }
                    }
                })[lt] = function() {
                    return this
                }
                ,
                t
            }
            ,
            i
        }
        function pt(t) {
            for (var e = Object.keys(t), n = {}, i = 0; i < e.length; i++) {
                var r = e[i];
                0,
                "function" == typeof t[r] && (n[r] = t[r])
            }
            var s, o = Object.keys(n);
            try {
                !function(t) {
                    Object.keys(t).forEach((function(e) {
                        var n = t[e];
                        if (void 0 === n(void 0, {
                            type: ut.INIT
                        }))
                            throw new Error(at(12));
                        if (void 0 === n(void 0, {
                            type: ut.PROBE_UNKNOWN_ACTION()
                        }))
                            throw new Error(at(13))
                    }
                    ))
                }(n)
            } catch (t) {
                s = t
            }
            return function(t, e) {
                if (void 0 === t && (t = {}),
                s)
                    throw s;
                for (var i = !1, r = {}, a = 0; a < o.length; a++) {
                    var l = o[a]
                      , c = n[l]
                      , u = t[l]
                      , h = c(u, e);
                    if (void 0 === h) {
                        e && e.type;
                        throw new Error(at(14))
                    }
                    r[l] = h,
                    i = i || h !== u
                }
                return (i = i || o.length !== Object.keys(t).length) ? r : t
            }
        }
        function ft() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            return 0 === e.length ? function(t) {
                return t
            }
            : 1 === e.length ? e[0] : e.reduce((function(t, e) {
                return function() {
                    return t(e.apply(void 0, arguments))
                }
            }
            ))
        }
        function At() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            return function(t) {
                return function() {
                    var n = t.apply(void 0, arguments)
                      , i = function() {
                        throw new Error(at(15))
                    }
                      , r = {
                        getState: n.getState,
                        dispatch: function() {
                            return i.apply(void 0, arguments)
                        }
                    }
                      , s = e.map((function(t) {
                        return t(r)
                    }
                    ));
                    return i = ft.apply(void 0, s)(n.dispatch),
                    ot(ot({}, n), {}, {
                        dispatch: i
                    })
                }
            }
        }
        function gt(t) {
            return function(e) {
                var n = e.dispatch
                  , i = e.getState;
                return function(e) {
                    return function(r) {
                        return "function" == typeof r ? r(n, i, t) : e(r)
                    }
                }
            }
        }
        var mt = gt();
        mt.withExtraArgument = gt;
        var vt, yt = mt, _t = (vt = function(t, e) {
            return vt = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(t, e) {
                t.__proto__ = e
            }
            || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }
            ,
            vt(t, e)
        }
        ,
        function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
            function n() {
                this.constructor = t
            }
            vt(t, e),
            t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype,
            new n)
        }
        ), Et = function(t, e) {
            var n, i, r, s, o = {
                label: 0,
                sent: function() {
                    if (1 & r[0])
                        throw r[1];
                    return r[1]
                },
                trys: [],
                ops: []
            };
            return s = {
                next: a(0),
                throw: a(1),
                return: a(2)
            },
            "function" == typeof Symbol && (s[Symbol.iterator] = function() {
                return this
            }
            ),
            s;
            function a(s) {
                return function(a) {
                    return function(s) {
                        if (n)
                            throw new TypeError("Generator is already executing.");
                        for (; o; )
                            try {
                                if (n = 1,
                                i && (r = 2 & s[0] ? i.return : s[0] ? i.throw || ((r = i.return) && r.call(i),
                                0) : i.next) && !(r = r.call(i, s[1])).done)
                                    return r;
                                switch (i = 0,
                                r && (s = [2 & s[0], r.value]),
                                s[0]) {
                                case 0:
                                case 1:
                                    r = s;
                                    break;
                                case 4:
                                    return o.label++,
                                    {
                                        value: s[1],
                                        done: !1
                                    };
                                case 5:
                                    o.label++,
                                    i = s[1],
                                    s = [0];
                                    continue;
                                case 7:
                                    s = o.ops.pop(),
                                    o.trys.pop();
                                    continue;
                                default:
                                    if (!(r = o.trys,
                                    (r = r.length > 0 && r[r.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                        o = 0;
                                        continue
                                    }
                                    if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                                        o.label = s[1];
                                        break
                                    }
                                    if (6 === s[0] && o.label < r[1]) {
                                        o.label = r[1],
                                        r = s;
                                        break
                                    }
                                    if (r && o.label < r[2]) {
                                        o.label = r[2],
                                        o.ops.push(s);
                                        break
                                    }
                                    r[2] && o.ops.pop(),
                                    o.trys.pop();
                                    continue
                                }
                                s = e.call(t, o)
                            } catch (t) {
                                s = [6, t],
                                i = 0
                            } finally {
                                n = r = 0
                            }
                        if (5 & s[0])
                            throw s[1];
                        return {
                            value: s[0] ? s[1] : void 0,
                            done: !0
                        }
                    }([s, a])
                }
            }
        }, bt = function(t, e) {
            for (var n = 0, i = e.length, r = t.length; n < i; n++,
            r++)
                t[r] = e[n];
            return t
        }, xt = Object.defineProperty, wt = Object.defineProperties, St = Object.getOwnPropertyDescriptors, Ct = Object.getOwnPropertySymbols, Mt = Object.prototype.hasOwnProperty, It = Object.prototype.propertyIsEnumerable, Tt = function(t, e, n) {
            return e in t ? xt(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n
        }, Bt = function(t, e) {
            for (var n in e || (e = {}))
                Mt.call(e, n) && Tt(t, n, e[n]);
            if (Ct)
                for (var i = 0, r = Ct(e); i < r.length; i++) {
                    n = r[i];
                    It.call(e, n) && Tt(t, n, e[n])
                }
            return t
        }, Rt = function(t, e) {
            return wt(t, St(e))
        }, Lt = function(t, e, n) {
            return new Promise((function(i, r) {
                var s = function(t) {
                    try {
                        a(n.next(t))
                    } catch (t) {
                        r(t)
                    }
                }
                  , o = function(t) {
                    try {
                        a(n.throw(t))
                    } catch (t) {
                        r(t)
                    }
                }
                  , a = function(t) {
                    return t.done ? i(t.value) : Promise.resolve(t.value).then(s, o)
                };
                a((n = n.apply(t, e)).next())
            }
            ))
        }, Dt = "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
            if (0 !== arguments.length)
                return "object" == typeof arguments[0] ? ft : ft.apply(null, arguments)
        }
        ;
        "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__;
        function Pt(t) {
            if ("object" != typeof t || null === t)
                return !1;
            var e = Object.getPrototypeOf(t);
            if (null === e)
                return !0;
            for (var n = e; null !== Object.getPrototypeOf(n); )
                n = Object.getPrototypeOf(n);
            return e === n
        }
        var Ut = function(t) {
            function e() {
                for (var n = [], i = 0; i < arguments.length; i++)
                    n[i] = arguments[i];
                var r = t.apply(this, n) || this;
                return Object.setPrototypeOf(r, e.prototype),
                r
            }
            return _t(e, t),
            Object.defineProperty(e, Symbol.species, {
                get: function() {
                    return e
                },
                enumerable: !1,
                configurable: !0
            }),
            e.prototype.concat = function() {
                for (var e = [], n = 0; n < arguments.length; n++)
                    e[n] = arguments[n];
                return t.prototype.concat.apply(this, e)
            }
            ,
            e.prototype.prepend = function() {
                for (var t = [], n = 0; n < arguments.length; n++)
                    t[n] = arguments[n];
                return 1 === t.length && Array.isArray(t[0]) ? new (e.bind.apply(e, bt([void 0], t[0].concat(this)))) : new (e.bind.apply(e, bt([void 0], t.concat(this))))
            }
            ,
            e
        }(Array)
          , Ot = function(t) {
            function e() {
                for (var n = [], i = 0; i < arguments.length; i++)
                    n[i] = arguments[i];
                var r = t.apply(this, n) || this;
                return Object.setPrototypeOf(r, e.prototype),
                r
            }
            return _t(e, t),
            Object.defineProperty(e, Symbol.species, {
                get: function() {
                    return e
                },
                enumerable: !1,
                configurable: !0
            }),
            e.prototype.concat = function() {
                for (var e = [], n = 0; n < arguments.length; n++)
                    e[n] = arguments[n];
                return t.prototype.concat.apply(this, e)
            }
            ,
            e.prototype.prepend = function() {
                for (var t = [], n = 0; n < arguments.length; n++)
                    t[n] = arguments[n];
                return 1 === t.length && Array.isArray(t[0]) ? new (e.bind.apply(e, bt([void 0], t[0].concat(this)))) : new (e.bind.apply(e, bt([void 0], t.concat(this))))
            }
            ,
            e
        }(Array);
        function Nt(t) {
            return r(t) ? nt(t, (function() {}
            )) : t
        }
        function Ft() {
            return function(t) {
                return function(t) {
                    void 0 === t && (t = {});
                    var e = t.thunk
                      , n = void 0 === e || e
                      , i = (t.immutableCheck,
                    t.serializableCheck,
                    new Ut);
                    n && (!function(t) {
                        return "boolean" == typeof t
                    }(n) ? i.push(yt.withExtraArgument(n.extraArgument)) : i.push(yt));
                    0;
                    return i
                }(t)
            }
        }
        function Qt(t, e) {
            function n() {
                for (var n = [], i = 0; i < arguments.length; i++)
                    n[i] = arguments[i];
                if (e) {
                    var r = e.apply(void 0, n);
                    if (!r)
                        throw new Error("prepareAction did not return an object");
                    return Bt(Bt({
                        type: t,
                        payload: r.payload
                    }, "meta"in r && {
                        meta: r.meta
                    }), "error"in r && {
                        error: r.error
                    })
                }
                return {
                    type: t,
                    payload: n[0]
                }
            }
            return n.toString = function() {
                return "" + t
            }
            ,
            n.type = t,
            n.match = function(e) {
                return e.type === t
            }
            ,
            n
        }
        function kt(t) {
            var e, n = {}, i = [], r = {
                addCase: function(t, e) {
                    var i = "string" == typeof t ? t : t.type;
                    if (i in n)
                        throw new Error("addCase cannot be called with two reducers for the same action type");
                    return n[i] = e,
                    r
                },
                addMatcher: function(t, e) {
                    return i.push({
                        matcher: t,
                        reducer: e
                    }),
                    r
                },
                addDefaultCase: function(t) {
                    return e = t,
                    r
                }
            };
            return t(r),
            [n, i, e]
        }
        var Gt = function(t) {
            void 0 === t && (t = 21);
            for (var e = "", n = t; n--; )
                e += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64 * Math.random() | 0];
            return e
        }
          , Ht = ["name", "message", "stack", "code"]
          , zt = function(t, e) {
            this.payload = t,
            this.meta = e
        }
          , Vt = function(t, e) {
            this.payload = t,
            this.meta = e
        }
          , Wt = function(t) {
            if ("object" == typeof t && null !== t) {
                for (var e = {}, n = 0, i = Ht; n < i.length; n++) {
                    var r = i[n];
                    "string" == typeof t[r] && (e[r] = t[r])
                }
                return e
            }
            return {
                message: String(t)
            }
        };
        !function() {
            function t(t, e, n) {
                var i = Qt(t + "/fulfilled", (function(t, e, n, i) {
                    return {
                        payload: t,
                        meta: Rt(Bt({}, i || {}), {
                            arg: n,
                            requestId: e,
                            requestStatus: "fulfilled"
                        })
                    }
                }
                ))
                  , r = Qt(t + "/pending", (function(t, e, n) {
                    return {
                        payload: void 0,
                        meta: Rt(Bt({}, n || {}), {
                            arg: e,
                            requestId: t,
                            requestStatus: "pending"
                        })
                    }
                }
                ))
                  , s = Qt(t + "/rejected", (function(t, e, i, r, s) {
                    return {
                        payload: r,
                        error: (n && n.serializeError || Wt)(t || "Rejected"),
                        meta: Rt(Bt({}, s || {}), {
                            arg: i,
                            requestId: e,
                            rejectedWithValue: !!r,
                            requestStatus: "rejected",
                            aborted: "AbortError" === (null == t ? void 0 : t.name),
                            condition: "ConditionError" === (null == t ? void 0 : t.name)
                        })
                    }
                }
                ))
                  , o = "undefined" != typeof AbortController ? AbortController : function() {
                    function t() {
                        this.signal = {
                            aborted: !1,
                            addEventListener: function() {},
                            dispatchEvent: function() {
                                return !1
                            },
                            onabort: function() {},
                            removeEventListener: function() {},
                            reason: void 0,
                            throwIfAborted: function() {}
                        }
                    }
                    return t.prototype.abort = function() {
                        0
                    }
                    ,
                    t
                }();
                return Object.assign((function(t) {
                    return function(a, l, c) {
                        var u, h = (null == n ? void 0 : n.idGenerator) ? n.idGenerator(t) : Gt(), d = new o;
                        function p(t) {
                            u = t,
                            d.abort()
                        }
                        var f = function() {
                            return Lt(this, null, (function() {
                                var o, f, A, g, m, v;
                                return Et(this, (function(y) {
                                    switch (y.label) {
                                    case 0:
                                        return y.trys.push([0, 4, , 5]),
                                        g = null == (o = null == n ? void 0 : n.condition) ? void 0 : o.call(n, t, {
                                            getState: l,
                                            extra: c
                                        }),
                                        null === (_ = g) || "object" != typeof _ || "function" != typeof _.then ? [3, 2] : [4, g];
                                    case 1:
                                        g = y.sent(),
                                        y.label = 2;
                                    case 2:
                                        if (!1 === g || d.signal.aborted)
                                            throw {
                                                name: "ConditionError",
                                                message: "Aborted due to condition callback returning false."
                                            };
                                        return !0,
                                        m = new Promise((function(t, e) {
                                            return d.signal.addEventListener("abort", (function() {
                                                return e({
                                                    name: "AbortError",
                                                    message: u || "Aborted"
                                                })
                                            }
                                            ))
                                        }
                                        )),
                                        a(r(h, t, null == (f = null == n ? void 0 : n.getPendingMeta) ? void 0 : f.call(n, {
                                            requestId: h,
                                            arg: t
                                        }, {
                                            getState: l,
                                            extra: c
                                        }))),
                                        [4, Promise.race([m, Promise.resolve(e(t, {
                                            dispatch: a,
                                            getState: l,
                                            extra: c,
                                            requestId: h,
                                            signal: d.signal,
                                            abort: p,
                                            rejectWithValue: function(t, e) {
                                                return new zt(t,e)
                                            },
                                            fulfillWithValue: function(t, e) {
                                                return new Vt(t,e)
                                            }
                                        })).then((function(e) {
                                            if (e instanceof zt)
                                                throw e;
                                            return e instanceof Vt ? i(e.payload, h, t, e.meta) : i(e, h, t)
                                        }
                                        ))])];
                                    case 3:
                                        return A = y.sent(),
                                        [3, 5];
                                    case 4:
                                        return v = y.sent(),
                                        A = v instanceof zt ? s(null, h, t, v.payload, v.meta) : s(v, h, t),
                                        [3, 5];
                                    case 5:
                                        return n && !n.dispatchConditionRejection && s.match(A) && A.meta.condition || a(A),
                                        [2, A]
                                    }
                                    var _
                                }
                                ))
                            }
                            ))
                        }();
                        return Object.assign(f, {
                            abort: p,
                            requestId: h,
                            arg: t,
                            unwrap: function() {
                                return f.then(qt)
                            }
                        })
                    }
                }
                ), {
                    pending: r,
                    rejected: s,
                    fulfilled: i,
                    typePrefix: t
                })
            }
            t.withTypes = function() {
                return t
            }
        }();
        function qt(t) {
            if (t.meta && t.meta.rejectedWithValue)
                throw t.payload;
            if (t.error)
                throw t.error;
            return t.payload
        }
        Object.assign;
        var jt = "listenerMiddleware";
        Qt(jt + "/add"),
        Qt(jt + "/removeAll"),
        Qt(jt + "/remove");
        "function" == typeof queueMicrotask && queueMicrotask.bind("undefined" != typeof window ? window : void 0 !== n.g ? n.g : globalThis);
        var Xt, Yt = function(t) {
            return function(e) {
                setTimeout(e, t)
            }
        };
        "undefined" != typeof window && window.requestAnimationFrame ? window.requestAnimationFrame : Yt(10);
        N();
        var Kt = /iPhone/i
          , Jt = /iPod/i
          , $t = /iPad/i
          , Zt = /\biOS-universal(?:.+)Mac\b/i
          , te = /\bAndroid(?:.+)Mobile\b/i
          , ee = /Android/i
          , ne = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
          , ie = /Silk/i
          , re = /Windows Phone/i
          , se = /\bWindows(?:.+)ARM\b/i
          , oe = /BlackBerry/i
          , ae = /BB10/i
          , le = /Opera Mini/i
          , ce = /\b(CriOS|Chrome)(?:.+)Mobile/i
          , ue = /Mobile(?:.+)Firefox\b/i
          , he = function(t) {
            return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
        };
        function de() {
            return function(t) {
                var e = {
                    userAgent: "",
                    platform: "",
                    maxTouchPoints: 0
                };
                t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
                    userAgent: t.userAgent,
                    platform: t.platform,
                    maxTouchPoints: t.maxTouchPoints || 0
                }) : e = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    maxTouchPoints: navigator.maxTouchPoints || 0
                };
                var n = e.userAgent
                  , i = n.split("[FBAN");
                void 0 !== i[1] && (n = i[0]),
                void 0 !== (i = n.split("Twitter"))[1] && (n = i[0]);
                var r = function(t) {
                    return function(e) {
                        return e.test(t)
                    }
                }(n)
                  , s = {
                    apple: {
                        phone: r(Kt) && !r(re),
                        ipod: r(Jt),
                        tablet: !r(Kt) && (r($t) || he(e)) && !r(re),
                        universal: r(Zt),
                        device: (r(Kt) || r(Jt) || r($t) || r(Zt) || he(e)) && !r(re)
                    },
                    amazon: {
                        phone: r(ne),
                        tablet: !r(ne) && r(ie),
                        device: r(ne) || r(ie)
                    },
                    android: {
                        phone: !r(re) && r(ne) || !r(re) && r(te),
                        tablet: !r(re) && !r(ne) && !r(te) && (r(ie) || r(ee)),
                        device: !r(re) && (r(ne) || r(ie) || r(te) || r(ee)) || r(/\bokhttp\b/i)
                    },
                    windows: {
                        phone: r(re),
                        tablet: r(se),
                        device: r(re) || r(se)
                    },
                    other: {
                        blackberry: r(oe),
                        blackberry10: r(ae),
                        opera: r(le),
                        firefox: r(ue),
                        chrome: r(ce),
                        device: r(oe) || r(ae) || r(le) || r(ue) || r(ce)
                    },
                    any: !1,
                    phone: !1,
                    tablet: !1
                };
                return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device,
                s.phone = s.apple.phone || s.android.phone || s.windows.phone,
                s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet,
                s
            }(window.navigator).any
        }
        const pe = function(t) {
            var e = t.name;
            if (!e)
                throw new Error("`name` is a required option for createSlice");
            var n, s = "function" == typeof t.initialState ? t.initialState : Nt(t.initialState), o = t.reducers || {}, a = Object.keys(o), l = {}, c = {}, u = {};
            function h() {
                var e = "function" == typeof t.extraReducers ? kt(t.extraReducers) : [t.extraReducers]
                  , n = e[0]
                  , o = void 0 === n ? {} : n
                  , a = e[1]
                  , l = void 0 === a ? [] : a
                  , u = e[2]
                  , h = void 0 === u ? void 0 : u
                  , d = Bt(Bt({}, o), c);
                return function(t, e, n, s) {
                    void 0 === n && (n = []);
                    var o, a = "function" == typeof e ? kt(e) : [e, n, s], l = a[0], c = a[1], u = a[2];
                    if (function(t) {
                        return "function" == typeof t
                    }(t))
                        o = function() {
                            return Nt(t())
                        }
                        ;
                    else {
                        var h = Nt(t);
                        o = function() {
                            return h
                        }
                    }
                    function d(t, e) {
                        void 0 === t && (t = o());
                        var n = bt([l[e.type]], c.filter((function(t) {
                            return (0,
                            t.matcher)(e)
                        }
                        )).map((function(t) {
                            return t.reducer
                        }
                        )));
                        return 0 === n.filter((function(t) {
                            return !!t
                        }
                        )).length && (n = [u]),
                        n.reduce((function(t, n) {
                            if (n) {
                                var s;
                                if (i(t))
                                    return void 0 === (s = n(t, e)) ? t : s;
                                if (r(t))
                                    return nt(t, (function(t) {
                                        return n(t, e)
                                    }
                                    ));
                                if (void 0 === (s = n(t, e))) {
                                    if (null === t)
                                        return t;
                                    throw Error("A case reducer on a non-draftable value must not return undefined")
                                }
                                return s
                            }
                            return t
                        }
                        ), t)
                    }
                    return d.getInitialState = o,
                    d
                }(s, (function(t) {
                    for (var e in d)
                        t.addCase(e, d[e]);
                    for (var n = 0, i = l; n < i.length; n++) {
                        var r = i[n];
                        t.addMatcher(r.matcher, r.reducer)
                    }
                    h && t.addDefaultCase(h)
                }
                ))
            }
            return a.forEach((function(t) {
                var n, i, r = o[t], s = e + "/" + t;
                "reducer"in r ? (n = r.reducer,
                i = r.prepare) : n = r,
                l[t] = n,
                c[s] = n,
                u[t] = i ? Qt(s, i) : Qt(s)
            }
            )),
            {
                name: e,
                reducer: function(t, e) {
                    return n || (n = h()),
                    n(t, e)
                },
                actions: u,
                caseReducers: l,
                getInitialState: function() {
                    return n || (n = h()),
                    n.getInitialState()
                }
            }
        }({
            name: "storage",
            initialState: {
                ar: !0,
                arPlacement: "floor",
                arScale: !0,
                arrSpeed: [],
                arModes: "scene-viewer quick-look",
                arbtnPosition: null,
                arbtnTitle: "",
                arbtnSubtitle: "",
                androidSrc: null,
                backgroundColor: "rgba(0, 0, 0, 0)",
                baseApiUrl: null,
                blockSelector: ".zarbo-viewer",
                buttonQR: null,
                cameraControls: !0,
                currentPlacement: "floor",
                changeMaterial: !1,
                currentMaterial: null,
                currentQuality: null,
                cameraOrbit: null,
                customMetric: null,
                classMaterial: null,
                disableZoom: !1,
                data: {},
                eyebrowIconId: null,
                eyebrowIcon: {},
                firstLoad: !0,
                hdri: null,
                hdri_as_background: !1,
                iosSrc: null,
                icon: {},
                isStartSessionBefore: !1,
                loadingType: "auto",
                materials: null,
                maxCameraOrbit: null,
                minCameraOrbit: null,
                modelSize: 0,
                optimization: !1,
                ourMetric: null,
                poster: null,
                position: ["top-left", "top", "top-right", "bottom-left", "bottom", "bottom-right"],
                progressMaterialCount: 0,
                progressMain: 0,
                qualities: [],
                qrColor: "black",
                qrRounded: null,
                qrImage: null,
                src: null,
                speed: 0,
                toggleAR: null,
                urlParams: null,
                urlIcon: null,
                viewerUrl: null,
                widget: null,
                widgetId: null
            },
            reducers: {
                addNewKey: (t,e)=>{
                    t[e.payload.newKey] = e.payload.newValue
                }
                ,
                updateBaseApiUrl: (t,e)=>{
                    t.baseApiUrl = e.payload
                }
                ,
                updateViewerUrl: (t,e)=>{
                    t.viewerUrl = e.payload
                }
                ,
                updateWidgetId: (t,e)=>{
                    t.widgetId = e.payload
                }
                ,
                updateButtonQR: (t,e)=>{
                    t.buttonQR = e.payload
                }
                ,
                updateAndroidSrc: (t,e)=>{
                    t.androidSrc = e.payload,
                    t.widget._zarboAndroidSrc = e.payload
                }
                ,
                updateSrc: (t,e)=>{
                    t.src = e.payload,
                    t.widget._zarbo3dSrc = e.payload
                }
                ,
                updateQrRounded: (t,e)=>{
                    t.qrRounded = e.payload
                }
                ,
                updateQrImage: (t,e)=>{
                    t.qrImage = e.payload
                }
                ,
                updateQrColor: (t,e)=>{
                    t.qrColor = e.payload
                }
                ,
                updateAR: (t,e)=>{
                    t.toggleAR = e.payload;
                    const n = t.widget.querySelector(".ar-button");
                    e.payload ? (t.widget.setAttribute("ar", ""),
                    n && (n.style.visibility = "visible")) : (t.widget.removeAttribute("ar"),
                    n && (n.style.visibility = "hidden"))
                }
                ,
                updateArPlacement: (t,e)=>{
                    if (t.arPlacement = e.payload,
                    e.payload) {
                        const n = document.querySelector("#change-position-block");
                        n && document.querySelector(t.blockSelector).removeChild(n),
                        t.widget.setAttribute("ar-placement", e.payload)
                    } else if (null === e.payload) {
                        let e = document.createElement("div");
                        e.id = "change-position-block";
                        const n = document.createElement("div");
                        n.id = "change-position-button",
                        n.textContent = "Положение: Пол",
                        e.appendChild(n),
                        e.addEventListener("click", (()=>{
                            "floor" === t.currentPlacement ? (t.currentPlacement = "wall",
                            n.textContent = "Положение: Стена",
                            t.widget.setAttribute("ar-placement", "wall")) : (t.currentPlacement = "floor",
                            n.textContent = "Положение: Пол",
                            t.widget.setAttribute("ar-placement", "floor"))
                        }
                        )),
                        document.querySelector(t.blockSelector).appendChild(e)
                    } else
                        t.widget.removeAttribute("ar-placement")
                }
                ,
                updateArScale: (t,e)=>{
                    t.arScale = e.payload,
                    e.payload ? t.widget.setAttribute("ar-scale", "") : t.widget.setAttribute("ar-scale", "fixed")
                }
                ,
                updateCameraControls: (t,e)=>{
                    t.cameraControls = e.payload,
                    e.payload ? t.widget.setAttribute("camera-controls", "") : t.widget.removeAttribute("camera-controls")
                }
                ,
                updateDisableZoom: (t,e)=>{
                    t.disableZoom = e.payload,
                    e.payload ? t.widget.setAttribute("disable-zoom", "") : t.widget.removeAttribute("disable-zoom")
                }
                ,
                updatePoster: (t,e)=>{
                    t.poster = e.payload,
                    e.payload ? t.widget.setAttribute("poster", e.payload) : t.widget.removeAttribute("poster")
                }
                ,
                updateIosSrc: (t,e)=>{
                    t.iosSrc = e.payload;
                    let n = e.payload.split(".").splice(-1, 1)[0];
                    t.widget._zarboIosSrc = e.payload,
                    e.payload && "usdz" === n ? t.widget.setAttribute("ios-src", e.payload) : t.widget.removeAttribute("ios-src")
                }
                ,
                updateUrlParams: (t,e)=>{
                    t.urlParams = e.payload
                }
                ,
                updateBlockSelector: (t,e)=>{
                    t.blockSelector = e.payload
                }
                ,
                updateWidget: (t,e)=>{
                    t.widget = e.payload
                }
                ,
                updateWidgetAddAtr: (t,e)=>{
                    t.widget.setAttribute(e.payload.newKey, e.payload.newValue)
                }
                ,
                updateCurrentPlacement: (t,e)=>{
                    t.currentPlacement = e.payload
                }
                ,
                updateMaterials: (t,e)=>{
                    t.materials = e.payload
                }
                ,
                updateChangeMaterial: (t,e)=>{
                    t.changeMaterial = e.payload;
                    const n = document.querySelector(".toggle-swiper");
                    e.payload && n ? n.style.display = "flex" : !e.payload && n && (n.style.display = "none")
                }
                ,
                updateCurrentMaterial: (t,e)=>{
                    t.currentMaterial = e.payload
                }
                ,
                changeMaterial: (t,e)=>{
                    let n = t.classMaterial._getMaterialByCodename(e.payload);
                    t.classMaterial._prepareMaterial(n).then((e=>{
                        t.classMaterial._applyMaterial(e)
                    }
                    ))
                }
                ,
                updateClassMaterial: (t,e)=>{
                    t.classMaterial = e.payload
                }
                ,
                updateActionIconId: (t,e)=>{
                    t.icon = e.payload;
                    let n = document.querySelector(".logo-wrapper");
                    if (null !== n)
                        if (void 0 !== e.payload)
                            n.firstChild.src = e.payload?.image,
                            n.style.visibility = "visible";
                        else {
                            if ("visible" !== n.style.visibility)
                                return;
                            n.style.visibility = "hidden"
                        }
                }
                ,
                updateLoadingType: (t,e)=>{
                    if (t.loadingType = e.payload,
                    ["auto", "lazy", "eager"].includes(e.payload))
                        t.widget.setAttribute("loading", e.payload);
                    else if ("click" === e.payload) {
                        t.widget.setAttribute("reveal", "manual");
                        const e = document.createElement("div");
                        e.id = "lazy-load-poster",
                        e.setAttribute("slot", "poster"),
                        t.poster && (e.style.backgroundImage = "url(" + t.poster + ")");
                        let n = document.querySelector(`${t.blockSelector} zarbo-widget`);
                        e.addEventListener("click", (()=>{
                            n.dismissPoster(),
                            n.setAttribute("reveal", "auto")
                        }
                        )),
                        t.widget.appendChild(e);
                        const i = document.createElement("div");
                        i.id = "button-load",
                        i.setAttribute("slot", "poster"),
                        i.innerText = "Нажмите на изображение, чтобы загрузить 3D-модель",
                        t.widget.appendChild(i)
                    } else
                        t.widget.removeAttribute("reveal"),
                        t.widget.removeAttribute("loading")
                }
                ,
                updateOptimization: (t,e)=>{
                    t.optimization = e.payload
                }
                ,
                updateArrSpeed: (t,e)=>{
                    t.arrSpeed = e.payload
                }
                ,
                updateModelSize: (t,e)=>{
                    t.modelSize = e.payload
                }
                ,
                updateSpeed: (t,e)=>{
                    t.speed = e.payload
                }
                ,
                updateQualities: (t,e)=>{
                    t.qualities = e.payload
                }
                ,
                updateData: (t,e)=>{
                    t.data = e.payload
                }
                ,
                updateCurrentQuality: (t,e)=>{
                    if (t.currentQuality = e.payload,
                    e.payload) {
                        let n = (void 0)._getModelByDestiny(options.product, "3d")
                          , i = ((void 0)._getModelByDestiny(options.product, "ar_ios"),
                        (void 0)._getModelByDestiny(options.product, "ar_android"));
                        if (n && (t.src = n.file),
                        i && (t.androidSrc = i.file),
                        t.changeMaterial) {
                            const n = t._getMaterialWithQuality(t.data.product, t.currentMaterial, e.payload);
                            t.callbackAfterLoad = ()=>{
                                t.currentMaterial = n
                            }
                        }
                    }
                }
                ,
                updateFirstLoad: (t,e)=>{
                    t.firstLoad = e.payload
                }
                ,
                updateArModes: (t,e)=>{
                    t.arModes = e.payload,
                    t.widget.setAttribute("ar-modes", e.payload)
                }
                ,
                updateIcon: (t,e)=>{
                    if (t.icon = e.payload,
                    e.payload) {
                        t.icon = e.payload;
                        const n = t.widget.querySelector(".logo-wrapper");
                        n && (n.style.visibility = "visible",
                        n.addEventListener("click", (()=>{
                            t.urlIcon ? window.open(t.urlIcon, "_blank") : window.open("https://zarbo.tech", "_blank")
                        }
                        )));
                        const i = t.widget.querySelector(".logo-wrapper img");
                        i && (i.src = e.payload.image)
                    } else {
                        const e = t.widget.querySelector(".logo-wrapper");
                        e && (e.style.visibility = "hidden")
                    }
                }
                ,
                updateUrlIcon: (t,e)=>{
                    t.urlIcon = e.payload
                }
                ,
                updateEyebrowIcon: (t,e)=>{
                    t.eyebrowIcon = e.payload;
                    const n = document.querySelector(".main-logo-wrapper")
                      , i = document.querySelector(".main-logo");
                    n && ("" !== e.payload ? (i.style.background = `url(${e.payload.image}) center center / 80% 80% no-repeat`,
                    n.style.visibility = "visible") : (n.style.visibility = "hidden",
                    i.style.background = null))
                }
                ,
                updateEyebrowIconId: (t,e)=>{
                    t.eyebrowIconId = e.payload
                }
                ,
                updateBackgroundColor: (t,e)=>{
                    t.backgroundColor = e.payload;
                    document.querySelector(t.blockSelector).style.backgroundColor = e.payload
                }
                ,
                updateMaxCameraOrbit: (t,e)=>{
                    t.maxCameraOrbit = e.payload,
                    t.widget.setAttribute("max-camera-orbit", e.payload)
                }
                ,
                updateMinCameraOrbit: (t,e)=>{
                    t.minCameraOrbit = e.payload,
                    t.widget.setAttribute("min-camera-orbit", e.payload)
                }
                ,
                updateCameraOrbit: (t,e)=>{
                    t.cameraOrbit = e.payload,
                    t.widget.setAttribute("camera-orbit", e.payload)
                }
                ,
                updateIsStartSessionBefore: (t,e)=>{
                    t.isStartSessionBefore = e.payload
                }
                ,
                updateToggleAR: (t,e)=>{
                    switch (t.toggleAR = e.payload,
                    e.payload) {
                    case "3DAR":
                        t.widget.ar = !0,
                        t.loadingType = t.data.loading_type;
                        break;
                    case "3D":
                        t.widget.ar = !1,
                        t.loadingType = t.data.loading_type;
                        break;
                    case "AR":
                        t.widget.ar = !0,
                        t.loadingType = "click",
                        t.widget.setAttribute("reveal", "interaction");
                        const e = document.createElement("div");
                        e.id = "lazy-load-poster",
                        e.setAttribute("slot", "poster"),
                        t.widget.appendChild(e);
                        const n = document.createElement("div");
                        n.id = "button-load",
                        n.setAttribute("slot", "poster"),
                        n.innerText = "Нажмите на изображение, чтобы загрузить 3D-модель";
                        let i = document.querySelector(`${t.blockSelector} zarbo-widget`);
                        if (i.appendChild(n),
                        t.poster && (e.style.backgroundImage = "url(" + t.poster + ")"),
                        !e)
                            return;
                        e.addEventListener("click", (()=>{
                            try {
                                de() ? i.activateAR() : i.dismissPoster()
                            } catch (t) {
                                console.error(t)
                            }
                        }
                        )),
                        t.widget.appendChild(e);
                        break;
                    case void 0:
                        t.widget.ar = !0,
                        t.loadingType = t.data.loading_type
                    }
                }
                ,
                updateArbtn: (t,e)=>{
                    t.arbtn = e.payload
                }
                ,
                updateArbtnPosition: (t,e)=>{
                    t.arbtnPosition = e.payload,
                    t.arbtn && t.arbtn.setPosition(e.payload)
                }
                ,
                updateArbtnTitle: (t,e)=>{
                    t.arbtnTitle = e.payload,
                    t.arbtn && t.arbtn.setTitle(e.payload)
                }
                ,
                updateArbtnSubtitle: (t,e)=>{
                    t.arbtnSubtitle = e.payload,
                    t.arbtn && t.arbtn.setSubtitle(e.payload)
                }
                ,
                updateOurMetric: (t,e)=>{
                    t.ourMetric = e.payload
                }
                ,
                updateCustomMetric: (t,e)=>{
                    t.customMetric = e.payload
                }
                ,
                updateHdriAsBackground: (t,e)=>{
                    t.hdri_as_background = e.payload,
                    t.hdri && (e.payload ? (t.widget.setAttribute("skybox-image", t.hdri.file),
                    t.widget.removeAttribute("environment-image")) : (t.widget.removeAttribute("skybox-image"),
                    t.widget.setAttribute("environment-image", t.hdri.file)))
                }
                ,
                updateHdri: (t,e)=>{
                    0 !== t.progressMain && (e.payload ? (t.widget.setAttribute("environment-image", e.payload.file),
                    t.hdri_as_background && (t.widget.setAttribute("skybox-image", e.payload.file),
                    t.widget.removeAttribute("environment-image"))) : (t.widget.removeAttribute("environment-image"),
                    t.widget.removeAttribute("skybox-image"))),
                    t.hdri = e.payload
                }
                ,
                updateProgressMaterialCount: (t,e)=>{
                    if (t.changeMaterial) {
                        const n = document.querySelector(".toggle-swiper")
                          , i = document.querySelector(".progress-bar")
                          , r = n.querySelector("span")
                          , s = n.querySelector(".matherials-icon");
                        e.payload >= 99 ? (t.progressMaterialCount = 0,
                        r.style.display = "none",
                        s.style.display = "flex",
                        i.style.backgroundImage = "none",
                        n.disabled = !1) : (t.progressMaterialCount = e.payload,
                        r.style.display = "block",
                        r.innerHTML = e.payload + "%",
                        s.style.display = "none",
                        i.style.backgroundImage = `conic-gradient(#CACAEE ${e.payload}%, #efefff 0)`,
                        n.disabled = !0)
                    }
                }
                ,
                updateProgressMain: (t,e)=>{
                    const n = document.querySelector(".main-logo-wrapper");
                    100 !== e.payload ? n.style.visibility = "hidden" : n.style.visibility = "visible",
                    t.progressMain = e.payload
                }
            }
        })
          , {addNewKey: fe, updateAR: Ae, updateArPlacement: ge, updateArScale: me, updateCameraControls: ve, updateDisableZoom: ye, updatePoster: _e, updateIosSrc: Ee, updateUrlParams: be, updateBlockSelector: xe, updateWidget: we, updateCurrentPlacement: Se, updateMaterials: Ce, updateChangeMaterial: Me, updateCurrentMaterial: Ie, updateLoadingType: Te, updateOptimization: Be, updateArrSpeed: Re, updateModelSize: Le, updateSpeed: De, updateQualities: Pe, updateData: Ue, updateCurrentQuality: Oe, updateFirstLoad: Ne, updateArModes: Fe, updateIcon: Qe, updateUrlIcon: ke, updateEyebrowIconId: Ge, updateBackgroundColor: He, updateMaxCameraOrbit: ze, updateMinCameraOrbit: Ve, updateCameraOrbit: We, updateIsStartSessionBefore: qe, updateToggleAR: je, updateArbtn: Xe, updateArbtnPosition: Ye, updateArbtnTitle: Ke, updateArbtnSubtitle: Je, updateQrColor: $e, updateQrRounded: Ze, updateQrImage: tn, updateSrc: en, updateAndroidSrc: nn, updateButtonQR: rn, updateBaseApiUrl: sn, updateViewerUrl: on, updateWidgetId: an, updateActionIconId: ln, updateOurMetric: cn, updateCustomMetric: un, updateClassMaterial: hn, changeMaterial: dn, updateEyebrowIcon: pn, updateHdriAsBackground: fn, updateHdri: An, updateProgressMaterialCount: gn, updateProgressMain: mn} = pe.actions;
        var vn = pe.reducer;
        let yn = 0;
        var _n = t=>e=>n=>{
            if ("storage/updateProgressMain" === n.type && n.payload >= 99 && t.getState().storage.hdri) {
                if (yn++,
                2 === yn) {
                    const i = t.getState().storage.widget
                      , r = t.getState().storage.hdri.file;
                    try {
                        t.getState().storage.hdri_as_background ? i.setAttribute("skybox-image", r) : i.setAttribute("environment-image", r),
                        e(n)
                    } catch (t) {
                        console.error("Ошибка при загрузке файла:", t),
                        e(n)
                    }
                }
                e(n)
            } else
                e(n)
        }
        ;
        const En = function(t) {
            var e, n = Ft(), i = t || {}, r = i.reducer, s = void 0 === r ? void 0 : r, o = i.middleware, a = void 0 === o ? n() : o, l = i.devTools, c = void 0 === l || l, u = i.preloadedState, h = void 0 === u ? void 0 : u, d = i.enhancers, p = void 0 === d ? void 0 : d;
            if ("function" == typeof s)
                e = s;
            else {
                if (!Pt(s))
                    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
                e = pt(s)
            }
            var f = a;
            "function" == typeof f && (f = f(n));
            var A = At.apply(void 0, f)
              , g = ft;
            c && (g = Dt(Bt({
                trace: !1
            }, "object" == typeof c && c)));
            var m = new Ot(A)
              , v = m;
            return Array.isArray(p) ? v = bt([A], p) : "function" == typeof p && (v = p(m)),
            dt(e, h, g.apply(void 0, v))
        }({
            reducer: {
                storage: vn
            },
            middleware: t=>t({
                serializableCheck: {
                    ignoredActions: ["storage/updateWidget", "storage/updateUrlParams", "storage/updateArbtn", "storage/updateOurMetric", "storage/updateCustomMetric", "storage/updateClassMaterial"],
                    ignoredPaths: ["storage.urlParams", "storage.widget", "payload", "storage.arbtn", "storage.ourMetric", "storage.customMetric", "storage.classMaterial"]
                }
            }).concat(_n)
        });
        var bn = En;
        const xn = n(7218);
        class wn {
            constructor(t) {
                this.countMaterials = 0,
                this.progressMaterial = 0,
                this._arrProgress = {},
                this.materials = t.sort(((t,e)=>t.order < e.order ? -1 : 1)),
                this._proxy = new Proxy(this._arrProgress,{
                    get: (t,e)=>t[e],
                    set: (t,e,n)=>(t[e] = n,
                    this._updateCallback(this._arrProgress),
                    !0)
                }),
                this._updateCallback = ()=>{}
            }
            get arrProgress() {
                return this._proxy
            }
            viewArrProgress() {
                let t = 0;
                for (var e in this._arrProgress)
                    this._arrProgress.hasOwnProperty(e) && (t += this._arrProgress[e]);
                this.progressMaterial = t
            }
            setUpdateCallback(t) {
                this._updateCallback = t
            }
            set progressMaterial(t) {
                t && bn.dispatch(gn(t)),
                this._progressMaterial = t
            }
            get progressMaterial() {
                return this._progressMaterial
            }
            set widget(t) {
                this._widget = t
            }
            get widget() {
                return this._widget
            }
            _getStartMaterial() {
                let t = window.location.href;
                "/" !== t[t.length - 1] && (t += "/");
                let e = t.indexOf("materialCode=");
                if (-1 !== e) {
                    let n = t.substring(e + 13, t.length - 1);
                    n = decodeURIComponent(n);
                    let i = this._getMaterialByCodename(n);
                    if (i)
                        return i
                }
                let n = this.materials.find((t=>t.is_default));
                return n || null
            }
            _getMaterialByCodename(t) {
                if (!this.materials || !this.materials.length)
                    return null;
                const e = this.materials.find((e=>e.codename === t));
                return e ? this._getMaterialWithQuality(e) : null
            }
            _getMaterialWithQuality(t) {
                let e = this.materials.find((e=>null === e.parent_id && e.id === t.parent_id));
                return e || (e = t),
                e
            }
            _prepareMaterial(t) {
                return bn.dispatch(be(t.codename)),
                ["base_color", "metallic_roughness", "normals", "occlusion", "emission"].forEach((e=>{
                    t[e] && this.countMaterials++
                }
                )),
                Promise.all(["base_color", "metallic_roughness", "normals", "occlusion", "emission"].map((e=>{
                    const n = t[e];
                    return n ? this.loadAndSetTexture(n, this.countMaterials, e) : null
                }
                ))).then((t=>{
                    const [e,n,i,r,s] = t;
                    return this.countMaterials = 0,
                    {
                        baseColorTexture: e,
                        metallicRoughnessTexture: n,
                        normalTexture: i,
                        occlusionTexture: r,
                        emissiveTexture: s
                    }
                }
                ))
            }
            loadAndSetTexture(t, e, n) {
                return new Promise(((i,r)=>{
                    xn.get(t, {
                        responseType: "blob",
                        onDownloadProgress: t=>{
                            const i = Math.round(100 * t.loaded / t.total / e);
                            this._arrProgress[n] = i,
                            this.viewArrProgress()
                        }
                    }).then((async t=>{
                        const e = t.data
                          , n = URL.createObjectURL(e)
                          , r = await this.widget.createTexture(n, "myTexture");
                        i(r)
                    }
                    )).catch((t=>{
                        console.error("Error during image loading", t),
                        r(t)
                    }
                    )),
                    this._arrProgress = {}
                }
                ))
            }
            _applyMaterial(t) {
                const e = this.widget.model.materials[0];
                e.pbrMetallicRoughness.baseColorTexture.setTexture(t.baseColorTexture),
                e.pbrMetallicRoughness.metallicRoughnessTexture.setTexture(t.metallicRoughnessTexture),
                e.normalTexture.setTexture(t.normalTexture),
                e.occlusionTexture.setTexture(t.occlusionTexture),
                e.emissiveTexture.setTexture(t.emissiveTexture),
                this.widget.dismissPoster(),
                this._removeLoadingSpinner()
            }
            _applyPreparedMaterial(t) {
                this._applyMaterial(t)
            }
            _removeLoadingSpinner() {
                let t = document.querySelector(".spinner")
                  , e = document.querySelector(".spinner-wrapper")
                  , n = document.querySelector(".logo-wrapper");
                t && (t.style.visibility = "hidden",
                n.style.visibility = "visible"),
                e && this.widget.removeChild(e)
            }
        }
        class Sn {
            constructor(t) {
                this.widget = bn.getState().storage.widget,
                this.urlParams = new URLSearchParams,
                this.viewerUrl = "https://api.dev.zarbo.works/viewer",
                this.button = null,
                this.#t(),
                this.callback = t
            }
            loading() {}
            #t() {
                let t = document.createElement("button");
                this.widget.appendChild(t),
                this.button = t
            }
            addStyles(t) {
                this.button.classList.add(t)
            }
            set callback(t) {
                this._callback = t,
                this.callback && this.button.removeEventListener("click", this.callback),
                this.button.addEventListener("click", t)
            }
            get callback() {
                return this._callback
            }
        }
        class Cn {
            constructor(t, e) {
                this.nodeAnimations = t,
                this.idSvg = document.getElementById(e),
                this.pauseIconAnimation()
            }
            playIconAnimation() {
                let t = this.idSvg.querySelectorAll(this.nodeAnimations);
                this.idSvg.unpauseAnimations(),
                t.forEach((t=>{
                    t.beginElement()
                }
                ))
            }
            pauseIconAnimation() {
                this.idSvg.pauseAnimations()
            }
        }
        function Mn(t, e) {
            return function() {
                return t.apply(e, arguments)
            }
        }
        const {toString: In} = Object.prototype
          , {getPrototypeOf: Tn} = Object
          , Bn = (Rn = Object.create(null),
        t=>{
            const e = In.call(t);
            return Rn[e] || (Rn[e] = e.slice(8, -1).toLowerCase())
        }
        );
        var Rn;
        const Ln = t=>(t = t.toLowerCase(),
        e=>Bn(e) === t)
          , Dn = t=>e=>typeof e === t
          , {isArray: Pn} = Array
          , Un = Dn("undefined");
        const On = Ln("ArrayBuffer");
        const Nn = Dn("string")
          , Fn = Dn("function")
          , Qn = Dn("number")
          , kn = t=>null !== t && "object" == typeof t
          , Gn = t=>{
            if ("object" !== Bn(t))
                return !1;
            const e = Tn(t);
            return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || Symbol.toStringTag in t || Symbol.iterator in t)
        }
          , Hn = Ln("Date")
          , zn = Ln("File")
          , Vn = Ln("Blob")
          , Wn = Ln("FileList")
          , qn = Ln("URLSearchParams");
        function jn(t, e, {allOwnKeys: n=!1}={}) {
            if (null == t)
                return;
            let i, r;
            if ("object" != typeof t && (t = [t]),
            Pn(t))
                for (i = 0,
                r = t.length; i < r; i++)
                    e.call(null, t[i], i, t);
            else {
                const r = n ? Object.getOwnPropertyNames(t) : Object.keys(t)
                  , s = r.length;
                let o;
                for (i = 0; i < s; i++)
                    o = r[i],
                    e.call(null, t[o], o, t)
            }
        }
        function Xn(t, e) {
            e = e.toLowerCase();
            const n = Object.keys(t);
            let i, r = n.length;
            for (; r-- > 0; )
                if (i = n[r],
                e === i.toLowerCase())
                    return i;
            return null
        }
        const Yn = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
          , Kn = t=>!Un(t) && t !== Yn;
        const Jn = ($n = "undefined" != typeof Uint8Array && Tn(Uint8Array),
        t=>$n && t instanceof $n);
        var $n;
        const Zn = Ln("HTMLFormElement")
          , ti = (({hasOwnProperty: t})=>(e,n)=>t.call(e, n))(Object.prototype)
          , ei = Ln("RegExp")
          , ni = (t,e)=>{
            const n = Object.getOwnPropertyDescriptors(t)
              , i = {};
            jn(n, ((n,r)=>{
                let s;
                !1 !== (s = e(n, r, t)) && (i[r] = s || n)
            }
            )),
            Object.defineProperties(t, i)
        }
          , ii = "abcdefghijklmnopqrstuvwxyz"
          , ri = "0123456789"
          , si = {
            DIGIT: ri,
            ALPHA: ii,
            ALPHA_DIGIT: ii + ii.toUpperCase() + ri
        };
        const oi = Ln("AsyncFunction");
        var ai = {
            isArray: Pn,
            isArrayBuffer: On,
            isBuffer: function(t) {
                return null !== t && !Un(t) && null !== t.constructor && !Un(t.constructor) && Fn(t.constructor.isBuffer) && t.constructor.isBuffer(t)
            },
            isFormData: t=>{
                let e;
                return t && ("function" == typeof FormData && t instanceof FormData || Fn(t.append) && ("formdata" === (e = Bn(t)) || "object" === e && Fn(t.toString) && "[object FormData]" === t.toString()))
            }
            ,
            isArrayBufferView: function(t) {
                let e;
                return e = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && On(t.buffer),
                e
            },
            isString: Nn,
            isNumber: Qn,
            isBoolean: t=>!0 === t || !1 === t,
            isObject: kn,
            isPlainObject: Gn,
            isUndefined: Un,
            isDate: Hn,
            isFile: zn,
            isBlob: Vn,
            isRegExp: ei,
            isFunction: Fn,
            isStream: t=>kn(t) && Fn(t.pipe),
            isURLSearchParams: qn,
            isTypedArray: Jn,
            isFileList: Wn,
            forEach: jn,
            merge: function t() {
                const {caseless: e} = Kn(this) && this || {}
                  , n = {}
                  , i = (i,r)=>{
                    const s = e && Xn(n, r) || r;
                    Gn(n[s]) && Gn(i) ? n[s] = t(n[s], i) : Gn(i) ? n[s] = t({}, i) : Pn(i) ? n[s] = i.slice() : n[s] = i
                }
                ;
                for (let t = 0, e = arguments.length; t < e; t++)
                    arguments[t] && jn(arguments[t], i);
                return n
            },
            extend: (t,e,n,{allOwnKeys: i}={})=>(jn(e, ((e,i)=>{
                n && Fn(e) ? t[i] = Mn(e, n) : t[i] = e
            }
            ), {
                allOwnKeys: i
            }),
            t),
            trim: t=>t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
            stripBOM: t=>(65279 === t.charCodeAt(0) && (t = t.slice(1)),
            t),
            inherits: (t,e,n,i)=>{
                t.prototype = Object.create(e.prototype, i),
                t.prototype.constructor = t,
                Object.defineProperty(t, "super", {
                    value: e.prototype
                }),
                n && Object.assign(t.prototype, n)
            }
            ,
            toFlatObject: (t,e,n,i)=>{
                let r, s, o;
                const a = {};
                if (e = e || {},
                null == t)
                    return e;
                do {
                    for (r = Object.getOwnPropertyNames(t),
                    s = r.length; s-- > 0; )
                        o = r[s],
                        i && !i(o, t, e) || a[o] || (e[o] = t[o],
                        a[o] = !0);
                    t = !1 !== n && Tn(t)
                } while (t && (!n || n(t, e)) && t !== Object.prototype);
                return e
            }
            ,
            kindOf: Bn,
            kindOfTest: Ln,
            endsWith: (t,e,n)=>{
                t = String(t),
                (void 0 === n || n > t.length) && (n = t.length),
                n -= e.length;
                const i = t.indexOf(e, n);
                return -1 !== i && i === n
            }
            ,
            toArray: t=>{
                if (!t)
                    return null;
                if (Pn(t))
                    return t;
                let e = t.length;
                if (!Qn(e))
                    return null;
                const n = new Array(e);
                for (; e-- > 0; )
                    n[e] = t[e];
                return n
            }
            ,
            forEachEntry: (t,e)=>{
                const n = (t && t[Symbol.iterator]).call(t);
                let i;
                for (; (i = n.next()) && !i.done; ) {
                    const n = i.value;
                    e.call(t, n[0], n[1])
                }
            }
            ,
            matchAll: (t,e)=>{
                let n;
                const i = [];
                for (; null !== (n = t.exec(e)); )
                    i.push(n);
                return i
            }
            ,
            isHTMLForm: Zn,
            hasOwnProperty: ti,
            hasOwnProp: ti,
            reduceDescriptors: ni,
            freezeMethods: t=>{
                ni(t, ((e,n)=>{
                    if (Fn(t) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                        return !1;
                    const i = t[n];
                    Fn(i) && (e.enumerable = !1,
                    "writable"in e ? e.writable = !1 : e.set || (e.set = ()=>{
                        throw Error("Can not rewrite read-only method '" + n + "'")
                    }
                    ))
                }
                ))
            }
            ,
            toObjectSet: (t,e)=>{
                const n = {}
                  , i = t=>{
                    t.forEach((t=>{
                        n[t] = !0
                    }
                    ))
                }
                ;
                return Pn(t) ? i(t) : i(String(t).split(e)),
                n
            }
            ,
            toCamelCase: t=>t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(t, e, n) {
                return e.toUpperCase() + n
            }
            )),
            noop: ()=>{}
            ,
            toFiniteNumber: (t,e)=>(t = +t,
            Number.isFinite(t) ? t : e),
            findKey: Xn,
            global: Yn,
            isContextDefined: Kn,
            ALPHABET: si,
            generateString: (t=16,e=si.ALPHA_DIGIT)=>{
                let n = "";
                const {length: i} = e;
                for (; t--; )
                    n += e[Math.random() * i | 0];
                return n
            }
            ,
            isSpecCompliantForm: function(t) {
                return !!(t && Fn(t.append) && "FormData" === t[Symbol.toStringTag] && t[Symbol.iterator])
            },
            toJSONObject: t=>{
                const e = new Array(10)
                  , n = (t,i)=>{
                    if (kn(t)) {
                        if (e.indexOf(t) >= 0)
                            return;
                        if (!("toJSON"in t)) {
                            e[i] = t;
                            const r = Pn(t) ? [] : {};
                            return jn(t, ((t,e)=>{
                                const s = n(t, i + 1);
                                !Un(s) && (r[e] = s)
                            }
                            )),
                            e[i] = void 0,
                            r
                        }
                    }
                    return t
                }
                ;
                return n(t, 0)
            }
            ,
            isAsyncFn: oi,
            isThenable: t=>t && (kn(t) || Fn(t)) && Fn(t.then) && Fn(t.catch)
        };
        function li(t, e, n, i, r) {
            Error.call(this),
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
            this.message = t,
            this.name = "AxiosError",
            e && (this.code = e),
            n && (this.config = n),
            i && (this.request = i),
            r && (this.response = r)
        }
        ai.inherits(li, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: ai.toJSONObject(this.config),
                    code: this.code,
                    status: this.response && this.response.status ? this.response.status : null
                }
            }
        });
        const ci = li.prototype
          , ui = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t=>{
            ui[t] = {
                value: t
            }
        }
        )),
        Object.defineProperties(li, ui),
        Object.defineProperty(ci, "isAxiosError", {
            value: !0
        }),
        li.from = (t,e,n,i,r,s)=>{
            const o = Object.create(ci);
            return ai.toFlatObject(t, o, (function(t) {
                return t !== Error.prototype
            }
            ), (t=>"isAxiosError" !== t)),
            li.call(o, t.message, e, n, i, r),
            o.cause = t,
            o.name = t.name,
            s && Object.assign(o, s),
            o
        }
        ;
        var hi = li;
        function di(t) {
            return ai.isPlainObject(t) || ai.isArray(t)
        }
        function pi(t) {
            return ai.endsWith(t, "[]") ? t.slice(0, -2) : t
        }
        function fi(t, e, n) {
            return t ? t.concat(e).map((function(t, e) {
                return t = pi(t),
                !n && e ? "[" + t + "]" : t
            }
            )).join(n ? "." : "") : e
        }
        const Ai = ai.toFlatObject(ai, {}, null, (function(t) {
            return /^is[A-Z]/.test(t)
        }
        ));
        var gi = function(t, e, n) {
            if (!ai.isObject(t))
                throw new TypeError("target must be an object");
            e = e || new FormData;
            const i = (n = ai.toFlatObject(n, {
                metaTokens: !0,
                dots: !1,
                indexes: !1
            }, !1, (function(t, e) {
                return !ai.isUndefined(e[t])
            }
            ))).metaTokens
              , r = n.visitor || c
              , s = n.dots
              , o = n.indexes
              , a = (n.Blob || "undefined" != typeof Blob && Blob) && ai.isSpecCompliantForm(e);
            if (!ai.isFunction(r))
                throw new TypeError("visitor must be a function");
            function l(t) {
                if (null === t)
                    return "";
                if (ai.isDate(t))
                    return t.toISOString();
                if (!a && ai.isBlob(t))
                    throw new hi("Blob is not supported. Use a Buffer instead.");
                return ai.isArrayBuffer(t) || ai.isTypedArray(t) ? a && "function" == typeof Blob ? new Blob([t]) : Buffer.from(t) : t
            }
            function c(t, n, r) {
                let a = t;
                if (t && !r && "object" == typeof t)
                    if (ai.endsWith(n, "{}"))
                        n = i ? n : n.slice(0, -2),
                        t = JSON.stringify(t);
                    else if (ai.isArray(t) && function(t) {
                        return ai.isArray(t) && !t.some(di)
                    }(t) || (ai.isFileList(t) || ai.endsWith(n, "[]")) && (a = ai.toArray(t)))
                        return n = pi(n),
                        a.forEach((function(t, i) {
                            !ai.isUndefined(t) && null !== t && e.append(!0 === o ? fi([n], i, s) : null === o ? n : n + "[]", l(t))
                        }
                        )),
                        !1;
                return !!di(t) || (e.append(fi(r, n, s), l(t)),
                !1)
            }
            const u = []
              , h = Object.assign(Ai, {
                defaultVisitor: c,
                convertValue: l,
                isVisitable: di
            });
            if (!ai.isObject(t))
                throw new TypeError("data must be an object");
            return function t(n, i) {
                if (!ai.isUndefined(n)) {
                    if (-1 !== u.indexOf(n))
                        throw Error("Circular reference detected in " + i.join("."));
                    u.push(n),
                    ai.forEach(n, (function(n, s) {
                        !0 === (!(ai.isUndefined(n) || null === n) && r.call(e, n, ai.isString(s) ? s.trim() : s, i, h)) && t(n, i ? i.concat(s) : [s])
                    }
                    )),
                    u.pop()
                }
            }(t),
            e
        };
        function mi(t) {
            const e = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, (function(t) {
                return e[t]
            }
            ))
        }
        function vi(t, e) {
            this._pairs = [],
            t && gi(t, this, e)
        }
        const yi = vi.prototype;
        yi.append = function(t, e) {
            this._pairs.push([t, e])
        }
        ,
        yi.toString = function(t) {
            const e = t ? function(e) {
                return t.call(this, e, mi)
            }
            : mi;
            return this._pairs.map((function(t) {
                return e(t[0]) + "=" + e(t[1])
            }
            ), "").join("&")
        }
        ;
        var _i = vi;
        function Ei(t) {
            return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        function bi(t, e, n) {
            if (!e)
                return t;
            const i = n && n.encode || Ei
              , r = n && n.serialize;
            let s;
            if (s = r ? r(e, n) : ai.isURLSearchParams(e) ? e.toString() : new _i(e,n).toString(i),
            s) {
                const e = t.indexOf("#");
                -1 !== e && (t = t.slice(0, e)),
                t += (-1 === t.indexOf("?") ? "?" : "&") + s
            }
            return t
        }
        var xi = class {
            constructor() {
                this.handlers = []
            }
            use(t, e, n) {
                return this.handlers.push({
                    fulfilled: t,
                    rejected: e,
                    synchronous: !!n && n.synchronous,
                    runWhen: n ? n.runWhen : null
                }),
                this.handlers.length - 1
            }
            eject(t) {
                this.handlers[t] && (this.handlers[t] = null)
            }
            clear() {
                this.handlers && (this.handlers = [])
            }
            forEach(t) {
                ai.forEach(this.handlers, (function(e) {
                    null !== e && t(e)
                }
                ))
            }
        }
          , wi = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        };
        var Si = {
            isBrowser: !0,
            classes: {
                URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : _i,
                FormData: "undefined" != typeof FormData ? FormData : null,
                Blob: "undefined" != typeof Blob ? Blob : null
            },
            isStandardBrowserEnv: (()=>{
                let t;
                return ("undefined" == typeof navigator || "ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t) && ("undefined" != typeof window && "undefined" != typeof document)
            }
            )(),
            isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
            protocols: ["http", "https", "file", "blob", "url", "data"]
        };
        var Ci = function(t) {
            function e(t, n, i, r) {
                let s = t[r++];
                const o = Number.isFinite(+s)
                  , a = r >= t.length;
                if (s = !s && ai.isArray(i) ? i.length : s,
                a)
                    return ai.hasOwnProp(i, s) ? i[s] = [i[s], n] : i[s] = n,
                    !o;
                i[s] && ai.isObject(i[s]) || (i[s] = []);
                return e(t, n, i[s], r) && ai.isArray(i[s]) && (i[s] = function(t) {
                    const e = {}
                      , n = Object.keys(t);
                    let i;
                    const r = n.length;
                    let s;
                    for (i = 0; i < r; i++)
                        s = n[i],
                        e[s] = t[s];
                    return e
                }(i[s])),
                !o
            }
            if (ai.isFormData(t) && ai.isFunction(t.entries)) {
                const n = {};
                return ai.forEachEntry(t, ((t,i)=>{
                    e(function(t) {
                        return ai.matchAll(/\w+|\[(\w*)]/g, t).map((t=>"[]" === t[0] ? "" : t[1] || t[0]))
                    }(t), i, n, 0)
                }
                )),
                n
            }
            return null
        };
        const Mi = {
            transitional: wi,
            adapter: Si.isNode ? "http" : "xhr",
            transformRequest: [function(t, e) {
                const n = e.getContentType() || ""
                  , i = n.indexOf("application/json") > -1
                  , r = ai.isObject(t);
                r && ai.isHTMLForm(t) && (t = new FormData(t));
                if (ai.isFormData(t))
                    return i && i ? JSON.stringify(Ci(t)) : t;
                if (ai.isArrayBuffer(t) || ai.isBuffer(t) || ai.isStream(t) || ai.isFile(t) || ai.isBlob(t))
                    return t;
                if (ai.isArrayBufferView(t))
                    return t.buffer;
                if (ai.isURLSearchParams(t))
                    return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                    t.toString();
                let s;
                if (r) {
                    if (n.indexOf("application/x-www-form-urlencoded") > -1)
                        return function(t, e) {
                            return gi(t, new Si.classes.URLSearchParams, Object.assign({
                                visitor: function(t, e, n, i) {
                                    return Si.isNode && ai.isBuffer(t) ? (this.append(e, t.toString("base64")),
                                    !1) : i.defaultVisitor.apply(this, arguments)
                                }
                            }, e))
                        }(t, this.formSerializer).toString();
                    if ((s = ai.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
                        const e = this.env && this.env.FormData;
                        return gi(s ? {
                            "files[]": t
                        } : t, e && new e, this.formSerializer)
                    }
                }
                return r || i ? (e.setContentType("application/json", !1),
                function(t, e, n) {
                    if (ai.isString(t))
                        try {
                            return (e || JSON.parse)(t),
                            ai.trim(t)
                        } catch (t) {
                            if ("SyntaxError" !== t.name)
                                throw t
                        }
                    return (n || JSON.stringify)(t)
                }(t)) : t
            }
            ],
            transformResponse: [function(t) {
                const e = this.transitional || Mi.transitional
                  , n = e && e.forcedJSONParsing
                  , i = "json" === this.responseType;
                if (t && ai.isString(t) && (n && !this.responseType || i)) {
                    const n = !(e && e.silentJSONParsing) && i;
                    try {
                        return JSON.parse(t)
                    } catch (t) {
                        if (n) {
                            if ("SyntaxError" === t.name)
                                throw hi.from(t, hi.ERR_BAD_RESPONSE, this, null, this.response);
                            throw t
                        }
                    }
                }
                return t
            }
            ],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: Si.classes.FormData,
                Blob: Si.classes.Blob
            },
            validateStatus: function(t) {
                return t >= 200 && t < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*",
                    "Content-Type": void 0
                }
            }
        };
        ai.forEach(["delete", "get", "head", "post", "put", "patch"], (t=>{
            Mi.headers[t] = {}
        }
        ));
        var Ii = Mi;
        const Ti = ai.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
        const Bi = Symbol("internals");
        function Ri(t) {
            return t && String(t).trim().toLowerCase()
        }
        function Li(t) {
            return !1 === t || null == t ? t : ai.isArray(t) ? t.map(Li) : String(t)
        }
        function Di(t, e, n, i, r) {
            return ai.isFunction(i) ? i.call(this, e, n) : (r && (e = n),
            ai.isString(e) ? ai.isString(i) ? -1 !== e.indexOf(i) : ai.isRegExp(i) ? i.test(e) : void 0 : void 0)
        }
        class Pi {
            constructor(t) {
                t && this.set(t)
            }
            set(t, e, n) {
                const i = this;
                function r(t, e, n) {
                    const r = Ri(e);
                    if (!r)
                        throw new Error("header name must be a non-empty string");
                    const s = ai.findKey(i, r);
                    (!s || void 0 === i[s] || !0 === n || void 0 === n && !1 !== i[s]) && (i[s || e] = Li(t))
                }
                const s = (t,e)=>ai.forEach(t, ((t,n)=>r(t, n, e)));
                return ai.isPlainObject(t) || t instanceof this.constructor ? s(t, e) : ai.isString(t) && (t = t.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()) ? s((t=>{
                    const e = {};
                    let n, i, r;
                    return t && t.split("\n").forEach((function(t) {
                        r = t.indexOf(":"),
                        n = t.substring(0, r).trim().toLowerCase(),
                        i = t.substring(r + 1).trim(),
                        !n || e[n] && Ti[n] || ("set-cookie" === n ? e[n] ? e[n].push(i) : e[n] = [i] : e[n] = e[n] ? e[n] + ", " + i : i)
                    }
                    )),
                    e
                }
                )(t), e) : null != t && r(e, t, n),
                this
            }
            get(t, e) {
                if (t = Ri(t)) {
                    const n = ai.findKey(this, t);
                    if (n) {
                        const t = this[n];
                        if (!e)
                            return t;
                        if (!0 === e)
                            return function(t) {
                                const e = Object.create(null)
                                  , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                let i;
                                for (; i = n.exec(t); )
                                    e[i[1]] = i[2];
                                return e
                            }(t);
                        if (ai.isFunction(e))
                            return e.call(this, t, n);
                        if (ai.isRegExp(e))
                            return e.exec(t);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(t, e) {
                if (t = Ri(t)) {
                    const n = ai.findKey(this, t);
                    return !(!n || void 0 === this[n] || e && !Di(0, this[n], n, e))
                }
                return !1
            }
            delete(t, e) {
                const n = this;
                let i = !1;
                function r(t) {
                    if (t = Ri(t)) {
                        const r = ai.findKey(n, t);
                        !r || e && !Di(0, n[r], r, e) || (delete n[r],
                        i = !0)
                    }
                }
                return ai.isArray(t) ? t.forEach(r) : r(t),
                i
            }
            clear(t) {
                const e = Object.keys(this);
                let n = e.length
                  , i = !1;
                for (; n--; ) {
                    const r = e[n];
                    t && !Di(0, this[r], r, t, !0) || (delete this[r],
                    i = !0)
                }
                return i
            }
            normalize(t) {
                const e = this
                  , n = {};
                return ai.forEach(this, ((i,r)=>{
                    const s = ai.findKey(n, r);
                    if (s)
                        return e[s] = Li(i),
                        void delete e[r];
                    const o = t ? function(t) {
                        return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((t,e,n)=>e.toUpperCase() + n))
                    }(r) : String(r).trim();
                    o !== r && delete e[r],
                    e[o] = Li(i),
                    n[o] = !0
                }
                )),
                this
            }
            concat(...t) {
                return this.constructor.concat(this, ...t)
            }
            toJSON(t) {
                const e = Object.create(null);
                return ai.forEach(this, ((n,i)=>{
                    null != n && !1 !== n && (e[i] = t && ai.isArray(n) ? n.join(", ") : n)
                }
                )),
                e
            }
            [Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map((([t,e])=>t + ": " + e)).join("\n")
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(t) {
                return t instanceof this ? t : new this(t)
            }
            static concat(t, ...e) {
                const n = new this(t);
                return e.forEach((t=>n.set(t))),
                n
            }
            static accessor(t) {
                const e = (this[Bi] = this[Bi] = {
                    accessors: {}
                }).accessors
                  , n = this.prototype;
                function i(t) {
                    const i = Ri(t);
                    e[i] || (!function(t, e) {
                        const n = ai.toCamelCase(" " + e);
                        ["get", "set", "has"].forEach((i=>{
                            Object.defineProperty(t, i + n, {
                                value: function(t, n, r) {
                                    return this[i].call(this, e, t, n, r)
                                },
                                configurable: !0
                            })
                        }
                        ))
                    }(n, t),
                    e[i] = !0)
                }
                return ai.isArray(t) ? t.forEach(i) : i(t),
                this
            }
        }
        Pi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
        ai.reduceDescriptors(Pi.prototype, (({value: t},e)=>{
            let n = e[0].toUpperCase() + e.slice(1);
            return {
                get: ()=>t,
                set(t) {
                    this[n] = t
                }
            }
        }
        )),
        ai.freezeMethods(Pi);
        var Ui = Pi;
        function Oi(t, e) {
            const n = this || Ii
              , i = e || n
              , r = Ui.from(i.headers);
            let s = i.data;
            return ai.forEach(t, (function(t) {
                s = t.call(n, s, r.normalize(), e ? e.status : void 0)
            }
            )),
            r.normalize(),
            s
        }
        function Ni(t) {
            return !(!t || !t.__CANCEL__)
        }
        function Fi(t, e, n) {
            hi.call(this, null == t ? "canceled" : t, hi.ERR_CANCELED, e, n),
            this.name = "CanceledError"
        }
        ai.inherits(Fi, hi, {
            __CANCEL__: !0
        });
        var Qi = Fi;
        var ki = Si.isStandardBrowserEnv ? {
            write: function(t, e, n, i, r, s) {
                const o = [];
                o.push(t + "=" + encodeURIComponent(e)),
                ai.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()),
                ai.isString(i) && o.push("path=" + i),
                ai.isString(r) && o.push("domain=" + r),
                !0 === s && o.push("secure"),
                document.cookie = o.join("; ")
            },
            read: function(t) {
                const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
                return e ? decodeURIComponent(e[3]) : null
            },
            remove: function(t) {
                this.write(t, "", Date.now() - 864e5)
            }
        } : {
            write: function() {},
            read: function() {
                return null
            },
            remove: function() {}
        };
        function Gi(t, e) {
            return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) ? function(t, e) {
                return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
            }(t, e) : e
        }
        var Hi = Si.isStandardBrowserEnv ? function() {
            const t = /(msie|trident)/i.test(navigator.userAgent)
              , e = document.createElement("a");
            let n;
            function i(n) {
                let i = n;
                return t && (e.setAttribute("href", i),
                i = e.href),
                e.setAttribute("href", i),
                {
                    href: e.href,
                    protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                    host: e.host,
                    search: e.search ? e.search.replace(/^\?/, "") : "",
                    hash: e.hash ? e.hash.replace(/^#/, "") : "",
                    hostname: e.hostname,
                    port: e.port,
                    pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname
                }
            }
            return n = i(window.location.href),
            function(t) {
                const e = ai.isString(t) ? i(t) : t;
                return e.protocol === n.protocol && e.host === n.host
            }
        }() : function() {
            return !0
        }
        ;
        var zi = function(t, e) {
            t = t || 10;
            const n = new Array(t)
              , i = new Array(t);
            let r, s = 0, o = 0;
            return e = void 0 !== e ? e : 1e3,
            function(a) {
                const l = Date.now()
                  , c = i[o];
                r || (r = l),
                n[s] = a,
                i[s] = l;
                let u = o
                  , h = 0;
                for (; u !== s; )
                    h += n[u++],
                    u %= t;
                if (s = (s + 1) % t,
                s === o && (o = (o + 1) % t),
                l - r < e)
                    return;
                const d = c && l - c;
                return d ? Math.round(1e3 * h / d) : void 0
            }
        };
        function Vi(t, e) {
            let n = 0;
            const i = zi(50, 250);
            return r=>{
                const s = r.loaded
                  , o = r.lengthComputable ? r.total : void 0
                  , a = s - n
                  , l = i(a);
                n = s;
                const c = {
                    loaded: s,
                    total: o,
                    progress: o ? s / o : void 0,
                    bytes: a,
                    rate: l || void 0,
                    estimated: l && o && s <= o ? (o - s) / l : void 0,
                    event: r
                };
                c[e ? "download" : "upload"] = !0,
                t(c)
            }
        }
        const Wi = {
            http: null,
            xhr: "undefined" != typeof XMLHttpRequest && function(t) {
                return new Promise((function(e, n) {
                    let i = t.data;
                    const r = Ui.from(t.headers).normalize()
                      , s = t.responseType;
                    let o;
                    function a() {
                        t.cancelToken && t.cancelToken.unsubscribe(o),
                        t.signal && t.signal.removeEventListener("abort", o)
                    }
                    ai.isFormData(i) && (Si.isStandardBrowserEnv || Si.isStandardBrowserWebWorkerEnv ? r.setContentType(!1) : r.setContentType("multipart/form-data;", !1));
                    let l = new XMLHttpRequest;
                    if (t.auth) {
                        const e = t.auth.username || ""
                          , n = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
                        r.set("Authorization", "Basic " + btoa(e + ":" + n))
                    }
                    const c = Gi(t.baseURL, t.url);
                    function u() {
                        if (!l)
                            return;
                        const i = Ui.from("getAllResponseHeaders"in l && l.getAllResponseHeaders());
                        !function(t, e, n) {
                            const i = n.config.validateStatus;
                            n.status && i && !i(n.status) ? e(new hi("Request failed with status code " + n.status,[hi.ERR_BAD_REQUEST, hi.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : t(n)
                        }((function(t) {
                            e(t),
                            a()
                        }
                        ), (function(t) {
                            n(t),
                            a()
                        }
                        ), {
                            data: s && "text" !== s && "json" !== s ? l.response : l.responseText,
                            status: l.status,
                            statusText: l.statusText,
                            headers: i,
                            config: t,
                            request: l
                        }),
                        l = null
                    }
                    if (l.open(t.method.toUpperCase(), bi(c, t.params, t.paramsSerializer), !0),
                    l.timeout = t.timeout,
                    "onloadend"in l ? l.onloadend = u : l.onreadystatechange = function() {
                        l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(u)
                    }
                    ,
                    l.onabort = function() {
                        l && (n(new hi("Request aborted",hi.ECONNABORTED,t,l)),
                        l = null)
                    }
                    ,
                    l.onerror = function() {
                        n(new hi("Network Error",hi.ERR_NETWORK,t,l)),
                        l = null
                    }
                    ,
                    l.ontimeout = function() {
                        let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
                        const i = t.transitional || wi;
                        t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                        n(new hi(e,i.clarifyTimeoutError ? hi.ETIMEDOUT : hi.ECONNABORTED,t,l)),
                        l = null
                    }
                    ,
                    Si.isStandardBrowserEnv) {
                        const e = (t.withCredentials || Hi(c)) && t.xsrfCookieName && ki.read(t.xsrfCookieName);
                        e && r.set(t.xsrfHeaderName, e)
                    }
                    void 0 === i && r.setContentType(null),
                    "setRequestHeader"in l && ai.forEach(r.toJSON(), (function(t, e) {
                        l.setRequestHeader(e, t)
                    }
                    )),
                    ai.isUndefined(t.withCredentials) || (l.withCredentials = !!t.withCredentials),
                    s && "json" !== s && (l.responseType = t.responseType),
                    "function" == typeof t.onDownloadProgress && l.addEventListener("progress", Vi(t.onDownloadProgress, !0)),
                    "function" == typeof t.onUploadProgress && l.upload && l.upload.addEventListener("progress", Vi(t.onUploadProgress)),
                    (t.cancelToken || t.signal) && (o = e=>{
                        l && (n(!e || e.type ? new Qi(null,t,l) : e),
                        l.abort(),
                        l = null)
                    }
                    ,
                    t.cancelToken && t.cancelToken.subscribe(o),
                    t.signal && (t.signal.aborted ? o() : t.signal.addEventListener("abort", o)));
                    const h = function(t) {
                        const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                        return e && e[1] || ""
                    }(c);
                    h && -1 === Si.protocols.indexOf(h) ? n(new hi("Unsupported protocol " + h + ":",hi.ERR_BAD_REQUEST,t)) : l.send(i || null)
                }
                ))
            }
        };
        ai.forEach(Wi, ((t,e)=>{
            if (t) {
                try {
                    Object.defineProperty(t, "name", {
                        value: e
                    })
                } catch (t) {}
                Object.defineProperty(t, "adapterName", {
                    value: e
                })
            }
        }
        ));
        var qi = t=>{
            t = ai.isArray(t) ? t : [t];
            const {length: e} = t;
            let n, i;
            for (let r = 0; r < e && (n = t[r],
            !(i = ai.isString(n) ? Wi[n.toLowerCase()] : n)); r++)
                ;
            if (!i) {
                if (!1 === i)
                    throw new hi(`Adapter ${n} is not supported by the environment`,"ERR_NOT_SUPPORT");
                throw new Error(ai.hasOwnProp(Wi, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`)
            }
            if (!ai.isFunction(i))
                throw new TypeError("adapter is not a function");
            return i
        }
        ;
        function ji(t) {
            if (t.cancelToken && t.cancelToken.throwIfRequested(),
            t.signal && t.signal.aborted)
                throw new Qi(null,t)
        }
        function Xi(t) {
            ji(t),
            t.headers = Ui.from(t.headers),
            t.data = Oi.call(t, t.transformRequest),
            -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1);
            return qi(t.adapter || Ii.adapter)(t).then((function(e) {
                return ji(t),
                e.data = Oi.call(t, t.transformResponse, e),
                e.headers = Ui.from(e.headers),
                e
            }
            ), (function(e) {
                return Ni(e) || (ji(t),
                e && e.response && (e.response.data = Oi.call(t, t.transformResponse, e.response),
                e.response.headers = Ui.from(e.response.headers))),
                Promise.reject(e)
            }
            ))
        }
        const Yi = t=>t instanceof Ui ? t.toJSON() : t;
        function Ki(t, e) {
            e = e || {};
            const n = {};
            function i(t, e, n) {
                return ai.isPlainObject(t) && ai.isPlainObject(e) ? ai.merge.call({
                    caseless: n
                }, t, e) : ai.isPlainObject(e) ? ai.merge({}, e) : ai.isArray(e) ? e.slice() : e
            }
            function r(t, e, n) {
                return ai.isUndefined(e) ? ai.isUndefined(t) ? void 0 : i(void 0, t, n) : i(t, e, n)
            }
            function s(t, e) {
                if (!ai.isUndefined(e))
                    return i(void 0, e)
            }
            function o(t, e) {
                return ai.isUndefined(e) ? ai.isUndefined(t) ? void 0 : i(void 0, t) : i(void 0, e)
            }
            function a(n, r, s) {
                return s in e ? i(n, r) : s in t ? i(void 0, n) : void 0
            }
            const l = {
                url: s,
                method: s,
                data: s,
                baseURL: o,
                transformRequest: o,
                transformResponse: o,
                paramsSerializer: o,
                timeout: o,
                timeoutMessage: o,
                withCredentials: o,
                adapter: o,
                responseType: o,
                xsrfCookieName: o,
                xsrfHeaderName: o,
                onUploadProgress: o,
                onDownloadProgress: o,
                decompress: o,
                maxContentLength: o,
                maxBodyLength: o,
                beforeRedirect: o,
                transport: o,
                httpAgent: o,
                httpsAgent: o,
                cancelToken: o,
                socketPath: o,
                responseEncoding: o,
                validateStatus: a,
                headers: (t,e)=>r(Yi(t), Yi(e), !0)
            };
            return ai.forEach(Object.keys(Object.assign({}, t, e)), (function(i) {
                const s = l[i] || r
                  , o = s(t[i], e[i], i);
                ai.isUndefined(o) && s !== a || (n[i] = o)
            }
            )),
            n
        }
        const Ji = "1.5.0"
          , $i = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(((t,e)=>{
            $i[t] = function(n) {
                return typeof n === t || "a" + (e < 1 ? "n " : " ") + t
            }
        }
        ));
        const Zi = {};
        $i.transitional = function(t, e, n) {
            function i(t, e) {
                return "[Axios v1.5.0] Transitional option '" + t + "'" + e + (n ? ". " + n : "")
            }
            return (n,r,s)=>{
                if (!1 === t)
                    throw new hi(i(r, " has been removed" + (e ? " in " + e : "")),hi.ERR_DEPRECATED);
                return e && !Zi[r] && (Zi[r] = !0,
                console.warn(i(r, " has been deprecated since v" + e + " and will be removed in the near future"))),
                !t || t(n, r, s)
            }
        }
        ;
        var tr = {
            assertOptions: function(t, e, n) {
                if ("object" != typeof t)
                    throw new hi("options must be an object",hi.ERR_BAD_OPTION_VALUE);
                const i = Object.keys(t);
                let r = i.length;
                for (; r-- > 0; ) {
                    const s = i[r]
                      , o = e[s];
                    if (o) {
                        const e = t[s]
                          , n = void 0 === e || o(e, s, t);
                        if (!0 !== n)
                            throw new hi("option " + s + " must be " + n,hi.ERR_BAD_OPTION_VALUE)
                    } else if (!0 !== n)
                        throw new hi("Unknown option " + s,hi.ERR_BAD_OPTION)
                }
            },
            validators: $i
        };
        const er = tr.validators;
        class nr {
            constructor(t) {
                this.defaults = t,
                this.interceptors = {
                    request: new xi,
                    response: new xi
                }
            }
            request(t, e) {
                "string" == typeof t ? (e = e || {}).url = t : e = t || {},
                e = Ki(this.defaults, e);
                const {transitional: n, paramsSerializer: i, headers: r} = e;
                void 0 !== n && tr.assertOptions(n, {
                    silentJSONParsing: er.transitional(er.boolean),
                    forcedJSONParsing: er.transitional(er.boolean),
                    clarifyTimeoutError: er.transitional(er.boolean)
                }, !1),
                null != i && (ai.isFunction(i) ? e.paramsSerializer = {
                    serialize: i
                } : tr.assertOptions(i, {
                    encode: er.function,
                    serialize: er.function
                }, !0)),
                e.method = (e.method || this.defaults.method || "get").toLowerCase();
                let s = r && ai.merge(r.common, r[e.method]);
                r && ai.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (t=>{
                    delete r[t]
                }
                )),
                e.headers = Ui.concat(s, r);
                const o = [];
                let a = !0;
                this.interceptors.request.forEach((function(t) {
                    "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous,
                    o.unshift(t.fulfilled, t.rejected))
                }
                ));
                const l = [];
                let c;
                this.interceptors.response.forEach((function(t) {
                    l.push(t.fulfilled, t.rejected)
                }
                ));
                let u, h = 0;
                if (!a) {
                    const t = [Xi.bind(this), void 0];
                    for (t.unshift.apply(t, o),
                    t.push.apply(t, l),
                    u = t.length,
                    c = Promise.resolve(e); h < u; )
                        c = c.then(t[h++], t[h++]);
                    return c
                }
                u = o.length;
                let d = e;
                for (h = 0; h < u; ) {
                    const t = o[h++]
                      , e = o[h++];
                    try {
                        d = t(d)
                    } catch (t) {
                        e.call(this, t);
                        break
                    }
                }
                try {
                    c = Xi.call(this, d)
                } catch (t) {
                    return Promise.reject(t)
                }
                for (h = 0,
                u = l.length; h < u; )
                    c = c.then(l[h++], l[h++]);
                return c
            }
            getUri(t) {
                return bi(Gi((t = Ki(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer)
            }
        }
        ai.forEach(["delete", "get", "head", "options"], (function(t) {
            nr.prototype[t] = function(e, n) {
                return this.request(Ki(n || {}, {
                    method: t,
                    url: e,
                    data: (n || {}).data
                }))
            }
        }
        )),
        ai.forEach(["post", "put", "patch"], (function(t) {
            function e(e) {
                return function(n, i, r) {
                    return this.request(Ki(r || {}, {
                        method: t,
                        headers: e ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: n,
                        data: i
                    }))
                }
            }
            nr.prototype[t] = e(),
            nr.prototype[t + "Form"] = e(!0)
        }
        ));
        var ir = nr;
        class rr {
            constructor(t) {
                if ("function" != typeof t)
                    throw new TypeError("executor must be a function.");
                let e;
                this.promise = new Promise((function(t) {
                    e = t
                }
                ));
                const n = this;
                this.promise.then((t=>{
                    if (!n._listeners)
                        return;
                    let e = n._listeners.length;
                    for (; e-- > 0; )
                        n._listeners[e](t);
                    n._listeners = null
                }
                )),
                this.promise.then = t=>{
                    let e;
                    const i = new Promise((t=>{
                        n.subscribe(t),
                        e = t
                    }
                    )).then(t);
                    return i.cancel = function() {
                        n.unsubscribe(e)
                    }
                    ,
                    i
                }
                ,
                t((function(t, i, r) {
                    n.reason || (n.reason = new Qi(t,i,r),
                    e(n.reason))
                }
                ))
            }
            throwIfRequested() {
                if (this.reason)
                    throw this.reason
            }
            subscribe(t) {
                this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t]
            }
            unsubscribe(t) {
                if (!this._listeners)
                    return;
                const e = this._listeners.indexOf(t);
                -1 !== e && this._listeners.splice(e, 1)
            }
            static source() {
                let t;
                const e = new rr((function(e) {
                    t = e
                }
                ));
                return {
                    token: e,
                    cancel: t
                }
            }
        }
        var sr = rr;
        const or = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(or).forEach((([t,e])=>{
            or[e] = t
        }
        ));
        var ar = or;
        const lr = function t(e) {
            const n = new ir(e)
              , i = Mn(ir.prototype.request, n);
            return ai.extend(i, ir.prototype, n, {
                allOwnKeys: !0
            }),
            ai.extend(i, n, null, {
                allOwnKeys: !0
            }),
            i.create = function(n) {
                return t(Ki(e, n))
            }
            ,
            i
        }(Ii);
        lr.Axios = ir,
        lr.CanceledError = Qi,
        lr.CancelToken = sr,
        lr.isCancel = Ni,
        lr.VERSION = Ji,
        lr.toFormData = gi,
        lr.AxiosError = hi,
        lr.Cancel = lr.CanceledError,
        lr.all = function(t) {
            return Promise.all(t)
        }
        ,
        lr.spread = function(t) {
            return function(e) {
                return t.apply(null, e)
            }
        }
        ,
        lr.isAxiosError = function(t) {
            return ai.isObject(t) && !0 === t.isAxiosError
        }
        ,
        lr.mergeConfig = Ki,
        lr.AxiosHeaders = Ui,
        lr.formToJSON = t=>Ci(ai.isHTMLForm(t) ? new FormData(t) : t),
        lr.getAdapter = qi,
        lr.HttpStatusCode = ar,
        lr.default = lr;
        var cr = lr;
        class ur {
            constructor(t) {
                this.icon = n(6118)(`./${t}`)
            }
            async getIcon() {
                return (await this.#e()).data
            }
            #e() {
                return cr.get(this.icon)
            }
        }
        class hr extends Sn {
            constructor(t) {
                super(),
                this.icon;
                new ur("ar-icon-btn.svg").getIcon().then((t=>{
                    this.icon = t,
                    this.#n(),
                    this.animation = new Cn("animateTransform, animate","arIconAnimated"),
                    this.button.addEventListener("mouseenter", (()=>{
                        this.animation.playIconAnimation()
                    }
                    ))
                }
                ))
            }
            #n() {
                const t = document.createElement("div");
                t.setAttribute("slot", "ar-button"),
                t.style.visibility = "hidden",
                bn.getState().storage.widget.appendChild(t);
                const e = document.createElement("div")
                  , n = document.createElement("div")
                  , i = document.createElement("span");
                this.title = i;
                const r = document.createElement("span");
                this.subtitle = r,
                e.innerHTML = this.icon,
                e.classList.add("ar-button__img"),
                n.classList.add("ar-button__wrapper"),
                i.classList.add("ar-button__title"),
                i.textContent = bn.getState().storage.arbtnTitle,
                r.classList.add("ar-button__subtitle"),
                r.textContent = bn.getState().storage.arbtnSubtitle,
                this.button.appendChild(n),
                n.appendChild(i),
                bn.getState().storage.arbtnSubtitle.toString().trim().length || (r.style.display = "none"),
                n.appendChild(r),
                this.button.appendChild(e),
                (void 0 === bn.getState().storage.arbtnTitle && void 0 === bn.getState().storage.arbtnsubtitle || "" === bn.getState().storage.arbtnTitle && "" === bn.getState().storage.arbtnsubtitle) && (this.button.style.width = "61px",
                this.button.style.boxSizing = "border-box"),
                this.button.id = "ar-button",
                this.position = function() {
                    let t;
                    return bn.getState().storage.arbtnPosition && bn.getState().storage.position.forEach((e=>{
                        bn.getState().storage.arbtnPosition === e && (t = e)
                    }
                    )),
                    t
                }(),
                this.button.classList.add(`button-position__${this.position}`)
            }
            setTitle(t) {
                this.title.textContent = t
            }
            setSubtitle(t) {
                this.subtitle.textContent = t,
                t.toString().trim().length ? this.subtitle.style.display = "block" : this.subtitle.style.display = "none"
            }
            setPosition(t) {
                this.button.classList.remove(this.#i()),
                this.position = t,
                this.button.classList.add(this.#r(t))
            }
            #r(t) {
                return `button-position__${t}`
            }
            #i() {
                return `button-position__${this.position}`
            }
        }
        class dr {
            constructor() {
                this.popup,
                this.popupClose,
                this.createPopup(),
                this.listener()
            }
            togglePopup(t) {
                this.popup.style.display = t ? "block" : "none"
            }
            createPopup() {
                const t = document.createElement("div")
                  , e = document.createElement("div")
                  , i = document.createElement("div")
                  , r = document.createElement("img");
                t.classList.add("popup"),
                e.classList.add("popup__wrapper"),
                i.classList.add("popup__content"),
                r.classList.add("popup__close"),
                r.src = n(4472),
                this.popupClose = r,
                this.popup = t,
                t.appendChild(e),
                e.appendChild(r),
                e.appendChild(i),
                bn.getState().storage.widget.appendChild(t)
            }
            closePopup() {
                const t = document.querySelector(".popup__content")
                  , e = document.querySelector(".popup__wrapper")
                  , n = document.getElementById("qr")
                  , i = document.getElementById("help-text")
                  , r = document.getElementById("help-text-wrapper").querySelector("img")
                  , s = document.querySelector(".popup__close");
                e.classList.add("close__backUpIn", "opacity"),
                n.classList.add("close__scaleOutIn"),
                s.classList.add("opacity"),
                t.classList.add("opacity"),
                i.classList.add("opacity"),
                r.classList.add("opacity"),
                setTimeout((()=>{
                    this.popup.style.display = "none",
                    e.classList.remove("close__backUpIn", "opacity"),
                    n.classList.remove("close__scaleOutIn"),
                    i.classList.remove("opacity"),
                    r.classList.remove("opacity"),
                    s.classList.remove("opacity"),
                    t.classList.remove("opacity"),
                    t.children.length > 0 && t.replaceChildren()
                }
                ), 200)
            }
            listener() {
                this.popupClose.addEventListener("click", this.closePopup.bind(this))
            }
        }
        class pr extends dr {
            constructor() {
                super()
            }
            createInstPopup() {
                document.querySelector(".popup").style.display = "block";
                const t = document.querySelector(".popup__content")
                  , e = document.createElement("button");
                let n = document.createElement("p");
                n.classList.add("popup__error-text"),
                n.innerText = "Для корректной работы функции дополненной реальности нажмите на значок «...» в правом верхнем углу и выберите пункт «Открыть в браузере системы» (Open in system browser).";
                let i = "«Открыть в браузере системы» ";
                n.innerHTML = n.innerHTML.replace(i, '<span style="font-weight: 700;">' + i + "</span>"),
                e.textContent = "Закрыть",
                e.classList.add("popup__button-inst"),
                e.addEventListener("click", (()=>[this.popup.style.display = "none"])),
                t.appendChild(n),
                t.appendChild(e)
            }
        }
        var fr = n(1915)
          , Ar = n.n(fr);
        class gr extends dr {
            constructor() {
                super()
            }
            createQRPopup() {
                if (document.querySelector(".popup__qr-code"))
                    return;
                const t = document.querySelector(".popup__content")
                  , e = document.createElement("div");
                let i;
                e.classList.add("popup__qr-code"),
                i = "embed" === window.location.hostname.split(".")[0] ? bn.getState().storage.baseApiUrl.replace("api", "embed") + "/" + encodeURIComponent(bn.getState().storage.data.product.uuid) + "/" + encodeURIComponent(bn.getState().storage.data.id) + "/" : bn.getState().storage.baseApiUrl + "/" + encodeURIComponent(bn.getState().storage.data.product.uuid) + "/" + encodeURIComponent(bn.getState().storage.data.id) + "/";
                let r = bn.getState().storage.urlParams;
                "" !== r && null !== r && (i += `?materialCode=${encodeURIComponent(r)}/`);
                let s = {
                    data: i,
                    width: 256,
                    height: 256,
                    errorCorrectionLevel: "H",
                    image: null !== bn.getState().storage.qrImage ? bn.getState().storage.qrImage.image : null,
                    dotsOptions: {
                        color: bn.getState().storage.qrColor,
                        type: "rounded"
                    },
                    imageOptions: {
                        crossOrigin: "anonymous"
                    },
                    cornersSquareOptions: {
                        type: bn.getState().storage.qrRounded || void 0 === bn.getState().storage.qrRounded ? "extra-rounded" : "square"
                    },
                    cornersDotOptions: {
                        type: bn.getState().storage.qrRounded || void 0 === bn.getState().storage.qrRounded ? "dot" : "square"
                    }
                };
                new (Ar())(s).append(t);
                let o = t.querySelector("canvas");
                o && (o.id = "qr"),
                t.title = i;
                let a = document.createElement("div");
                a.id = "help-text-wrapper";
                let l = document.createElement("img");
                l.src = n(2382),
                l.height = "54",
                l.width = "42";
                let c = document.createElement("div");
                c.id = "help-text",
                c.innerText = "Наведите камеру телефона",
                t.appendChild(e),
                t.appendChild(a),
                a.appendChild(c),
                a.appendChild(l),
                document.querySelector(".popup").style.display = "block"
            }
        }
        function mr() {
            return document.querySelector(bn.getState().storage.blockSelector + " zarbo-widget").canActivateAR && de() ? -1 !== navigator.userAgent.toLocaleLowerCase().indexOf("instagram") ? "inst" : "AR" === bn.getState().storage.toggleAR ? "openImmediately" : "ar" : "3D" === bn.getState().storage.toggleAR ? "3D" : "qr"
        }
        class vr {
            constructor(t) {
                this.classMaterial = t,
                this.svgIcon = "",
                this.isShowSwiper = !0
            }
            init() {
                this.createSwiper();
                new ur("open-icon-swiper.svg").getIcon().then((t=>{
                    this.svgIcon = t,
                    this.createToggleButton();
                    const e = new Cn("animateTransform, animate","materialIconAnimated");
                    document.querySelector(".toggle-swiper").addEventListener("mouseenter", (()=>{
                        e.playIconAnimation()
                    }
                    ))
                }
                )),
                this.findSelectMaterial()
            }
            createToggleButton() {
                const t = document.createElement("button");
                t.classList.add("toggle-swiper");
                const e = document.createElement("div");
                e.classList.add("progress-bar");
                const n = document.createElement("div");
                n.classList.add("matherials-icon"),
                n.innerHTML = this.svgIcon,
                n.style.height = "22px",
                n.style.width = "22px";
                const i = document.createElement("span");
                Object.assign(i.style, {
                    fontSize: "14px",
                    fontWeight: "700",
                    color: "#675D8B",
                    display: "none",
                    "z-index": 1
                }),
                t.appendChild(n),
                t.appendChild(i),
                bn.getState().storage.widget.appendChild(t),
                bn.getState().storage.widget.appendChild(e);
                t.addEventListener("click", (()=>{
                    this.updateSwiperVisibility()
                }
                ))
            }
            async updateSwiperVisibility() {
                const t = document.querySelector(".toggle-swiper")
                  , e = t.querySelector(".matherials-icon")
                  , i = document.querySelector(".mySwiper")
                  , r = document.querySelectorAll(".mySwiper-slide")
                  , s = document.querySelector(".progress-bar")
                  , o = "mySwiper__animate-open"
                  , a = "mySwiper__animate-close"
                  , l = "#DDDCFF"
                  , c = "#DDDCFF";
                if (!(t && e && i && s))
                    return;
                const u = t=>{
                    for (; t.firstChild; )
                        t.removeChild(t.firstChild)
                }
                  , h = (t,e)=>{
                    t.style.backgroundColor = e
                }
                ;
                if (this.isShowSwiper) {
                    u(e),
                    A = "active",
                    r.forEach((t=>t.classList.add(A))),
                    i.classList.remove(a),
                    i.classList.add(o);
                    const c = document.createElement("img");
                    p = c,
                    f = n(5293),
                    p.src = f,
                    e.appendChild(c),
                    h(t, l),
                    h(s, l),
                    d = "none",
                    s.style.backgroundImage = d
                } else
                    ((t,e)=>{
                        t.forEach((t=>t.classList.remove(e)))
                    }
                    )(r, "active"),
                    i.classList.remove(o),
                    i.classList.add(a),
                    await setTimeout((()=>{
                        u(e),
                        h(t, c),
                        h(s, c),
                        e.innerHTML = this.svgIcon
                    }
                    ), 300);
                var d, p, f, A;
                this.isShowSwiper = !this.isShowSwiper
            }
            closeMaterial() {
                this.updateSwiperVisibility()
            }
            createSwiperSlide(t) {
                const e = document.createElement("button");
                e.classList.add("mySwiper-slide"),
                e.setAttribute("default", t.is_default),
                e.setAttribute("codename", t.codename),
                e.onclick = n=>{
                    n.stopPropagation(),
                    this.clickMaterial(t, e)
                }
                ;
                const n = document.createElement("div");
                n.classList.add("mySwiper-slide__img");
                const i = new Image;
                i.style.opacity = 0,
                i.classList.add("material-preview"),
                i.addEventListener("load", (()=>{
                    i.style.opacity = 1
                }
                )),
                i.src = t.image_src,
                n.appendChild(i),
                e.appendChild(n);
                const r = document.createElement("div");
                return r.classList.add("mySwiper-slide__wrap"),
                r.appendChild(this.createSpanElement("span", t.name)),
                r.appendChild(this.createSpanElement("span", t.codename)),
                e.appendChild(r),
                e
            }
            createSpanElement(t, e) {
                const n = document.createElement(t);
                return n.innerHTML = e,
                n
            }
            createSwiper() {
                const t = document.createElement("div");
                t.classList.add("mySwiper");
                const e = document.createElement("div");
                if (e.classList.add("mySwiper-wrapper"),
                !bn.getState().storage.materials || !bn.getState().storage.materials.length)
                    return;
                const n = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
                  , i = Number(bn.getState().storage.materials.length)
                  , r = n - 69 - 20;
                let s = 110 * i;
                i <= 1 ? s < r ? (t.style.height = s + 24 + "px",
                t.style.maxHeight = s + 24 + "px") : (t.style.height = r + "px",
                t.style.maxHeight = r + "px") : i > 1 && (s < r ? (t.style.height = s + 24 + 8 + "px",
                t.style.maxHeight = s + 24 + 8 + "px") : (t.style.height = r + "px",
                t.style.maxHeight = r + "px")),
                bn.getState().storage.materials.forEach((t=>{
                    if (null !== t.parent_id)
                        return;
                    const n = this.createSwiperSlide(t);
                    e.appendChild(n)
                }
                ));
                const o = document.createElement("div");
                o.classList.add("connect-block"),
                t.appendChild(o),
                t.appendChild(e),
                bn.getState().storage.widget.appendChild(t)
            }
            async clickMaterial(t, e, n) {
                document.querySelectorAll(".mySwiper-slide").forEach((t=>{
                    t.classList.remove("selected")
                }
                )),
                e && e.classList.add("selected"),
                n || this.closeMaterial(),
                bn.dispatch(Ie(t));
                let i = {
                    baseColorTexture: null,
                    metallicRoughnessTexture: null,
                    normalTexture: null,
                    occlusionTexture: null,
                    emissiveTexture: null
                };
                await this.classMaterial._prepareMaterial(t).then((t=>{
                    i = t;
                    const e = bn.getState().storage.widget?.model?.materials[0];
                    e ? this.classMaterial._applyMaterial(i) : this.callbackAfterLoad = this.classMaterial._applyPreparedMaterial()
                }
                ))
            }
            findSelectMaterial() {
                const t = Array.from(document.querySelectorAll(".mySwiper-slide"))
                  , e = window.location.search.replace(/\/$/, "")
                  , n = new URLSearchParams(e)
                  , i = decodeURIComponent(n.get("materialCode"));
                let r = !1;
                if (i && (t && t.length && t.forEach((t=>{
                    if (t.getAttribute("codename") === i) {
                        const e = this.findMaterialByButton(t);
                        this.clickMaterial(e, null, !0),
                        t.classList.add("selected"),
                        r = !0
                    }
                }
                )),
                r))
                    return;
                let s = !1;
                if (t && t.length) {
                    if (s)
                        return;
                    t.forEach((t=>{
                        if ("true" === t.getAttribute("default") || !0 === t.getAttribute("default")) {
                            const e = this.findMaterialByButton(t);
                            this.clickMaterial(e, null, !0),
                            t.classList.add("selected"),
                            s = !0
                        }
                    }
                    ))
                }
                !s && t && t[0] && (t[0].click(),
                t[0].classList.add("selected"));
                document.querySelector(".mySwiper")
            }
            findMaterialByButton(t) {
                const e = bn.getState().storage.materials
                  , n = t.getAttribute("codename");
                return e.find((t=>t.codename === n && null === t.parent_id))
            }
        }
        class yr {
            constructor(t, e) {
                this.widgetId = null,
                this.widgetParentDomain = "",
                this.actionParams = {},
                this.isMetricActive = !1,
                this.ym = null;
                this.options = e || {
                    clickmap: !0,
                    trackLinks: !0,
                    accurateTrackBounce: !0,
                    ecommerce: "dataLayer"
                },
                this.counterId = t
            }
            _initMetric(t) {
                window.ym && t && (this.ym = window.ym,
                this.ym(t, "init", this.options),
                this.isMetricActive = !0)
            }
            addParam(t, e) {
                t && e ? this.actionParams[t] = e : console.warn('параметр не добавлен. Ключ или параметр не валидны. \nkey: "' + t + '"\nvalue: ' + e)
            }
            commitAction(t) {
                this.isMetricActive ? this.ym(this.counterId, "reachGoal", t, this._getActionOptions()) : console.warn("Metric is disabled")
            }
            addEcom(t) {
                window.dataLayer = window.dataLayer || [];
                let e = {
                    ecommerce: {
                        detail: {
                            products: [t]
                        }
                    }
                };
                window.dataLayer.push(e)
            }
            _getActionOptions() {
                let t = {};
                for (let e in this.actionParams) {
                    let n = this.actionParams[e];
                    n && (t[e] = n)
                }
                return t
            }
            set counterId(t) {
                this._counterId = t,
                t ? this._initMetric(t) : this.isMetricActive = !1
            }
            get counterId() {
                return this._counterId
            }
        }
        class _r {
            constructor(t, e) {
                this.blockSelector = t,
                this.options = e,
                this.startTime = null,
                this.endTime = null,
                this.speed = null,
                this.modelSize = 0,
                bn.dispatch(xe(t)),
                this.isStartSessionBefore = !1,
                this.callbackAfterLoad = null,
                this.firstLoad = !0;
                let n = "";
                if (window.location != window.parent.location) {
                    let t = document.createElement("a");
                    t.href = document.referrer,
                    n = t.hostname
                } else
                    n = document.location.hostname;
                const i = ~window.location.origin.indexOf("dev") ? 89930704 : 92478509;
                this.ourMetric = new yr(i),
                this.ourMetric.addParam("widget_id", e.id),
                this.ourMetric.addParam("widget_parent_domain", n),
                this.ourMetric.commitAction("widget_init"),
                this.customMetric = new yr,
                this.customMetric.addParam("widget_id", e.id),
                this.customMetric.addParam("widget_parent_domain", n),
                bn.dispatch(cn(this.ourMetric)),
                bn.dispatch(un(this.customMetricMetric)),
                this.isWidgetInteract = !1,
                this.classMaterial = new wn(e.product.materials),
                bn.dispatch(hn(this.classMaterial)),
                this.init(e),
                t || console.warn("Селектор не указан. Используется по умолчанию блок с классом 'zarbo-viewer'"),
                this.countProgress = 0
            }
            async init() {
                this.#s(),
                this.#o(),
                bn.getState().storage.widget.addEventListener("progress", (t=>this.#a(t))),
                bn.getState().storage.widget.addEventListener("load", (()=>this.#l())),
                this.#c(),
                this.#u(),
                bn.getState().storage.widget.addEventListener("click", (()=>{
                    this.isWidgetInteract || (this.isWidgetInteract = !0,
                    this.ourMetric.commitAction("widget_interact"),
                    this.customMetric.commitAction("widget_interact"))
                }
                ));
                let t = document.querySelector(".browser-warning__close-button");
                t?.addEventListener("click", (()=>this.#h()));
                let e = document.querySelector(".browser-warning__content-close-button");
                e?.addEventListener("click", (()=>this.#h()));
                let n = document.querySelector(`${bn.getState().storage.blockSelector} zarbo-widget`);
                n.addEventListener("error", (t=>{
                    console.error(t),
                    this.#d(t)
                }
                )),
                n.addEventListener("ar-status", (t=>{
                    "session-started" === t.detail.status && (this.isStartSessionBefore = !0),
                    "not-presenting" !== t.detail.status || this.isStartSessionBefore || this.#h(),
                    "failed" !== t.detail.status || this.isStartSessionBefore || this.#p()
                }
                ));
                let i = document.querySelector(".spinner")
                  , r = document.querySelector(".spinner-wrapper")
                  , s = document.querySelector(".logo-wrapper");
                if (i && (i.style.visibility = "hidden",
                s.style.visibility = "visible"),
                r) {
                    document.querySelector(`${bn.getState().storage.blockSelector} zarbo-widget`).removeChild(r)
                }
            }
            #o() {
                const t = document.querySelector("zarbo-widget").shadowRoot
                  , e = t.querySelector("#default-poster");
                e.style.zIndex = 2,
                e.style.backgroundColor = "#FFF";
                const n = document.createElement("style");
                n.textContent = "\n      @keyframes load {\n        from {\n          left: -150px;\n        } to {\n          left: 100%;\n        }\n      }\n\n      .flashing-poster::after {\n        content: '';\n        display: block;\n        position: absolute;\n        left: 0;\n        top: 0;\n        height: 100%;\n        width: 100%;\n        background-color: #FFF;\n        opacity: .6;\n      }\n\n      .flashing-poster::before {\n        content: '';\n        display: block;\n        position: absolute;\n        left: -90px;\n        top: 0;\n        height: 100%;\n        width: 90px;\n        background: rgba(255, 255, 255, 0.80);;\n        animation: load 5s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;\n        filter: blur(15px);\n      }\n    ",
                t.appendChild(n),
                e.classList.add("flashing-poster");
                const i = document.createElement("div");
                i.classList.add("progress__main"),
                i.slot = "progress-bar",
                i.style.backgroundColor = bn.getState().storage.backgroundColor;
                const r = document.createElement("div");
                r.classList.add("progress__wrap");
                const s = document.createElement("div");
                s.classList.add("progress__text");
                const o = document.createElement("div");
                o.classList.add("progress__block");
                const a = document.createElement("div");
                a.classList.add("progress__loaded"),
                o.appendChild(a),
                r.appendChild(s),
                r.appendChild(o);
                const l = document.createElement("div");
                l.classList.add("progress__text"),
                l.innerHTML = "Виджет загружается...",
                i.appendChild(r),
                i.appendChild(l),
                bn.getState().storage.widget.appendChild(i)
            }
            #p() {
                const t = document.createElement("div");
                t.id = "popup-error",
                t.classList.add("popup-error__hide"),
                t.textContent = 'Ваше устройство не поддерживает AR. Для использования продукта необходимо установить "Сервис Google Play для AR"',
                bn.getState().storage.widget.appendChild(t);
                const e = document.createElement("div");
                e.textContent = "x",
                e.classList.add("popup-error__btn-close"),
                t.appendChild(e);
                const i = document.createElement("a");
                i.href = "https://play.google.com/store/apps/details?id=com.google.ar.core&hl=ru&gl=US&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1",
                t.appendChild(i);
                const r = document.createElement("img");
                r.src = n(1886),
                r.alt = "Доступно в Google Play",
                i.appendChild(r),
                t.classList.remove("popup-error__hide"),
                e.onclick = function() {
                    t.classList.add("popup-error__hide")
                }
                ,
                r.onerror = function() {
                    r.remove(),
                    i.style.textDecoration = "none",
                    i.style.color = "white";
                    const t = document.createElement("span");
                    t.innerHTML = "Доступно в Google Play",
                    t.style.backgroundColor = "grey",
                    t.style.padding = "15px",
                    t.style.margin = "30px",
                    t.style.borderRadius = "10px",
                    i.appendChild(t)
                }
            }
            #d(t) {
                let e = document.createElement("div");
                e.id = "error-popup";
                let i = document.createElement("div");
                i.classList.add("content");
                let r = document.createElement("img");
                r.src = n(4695);
                let s = document.createElement("p");
                s.classList.add("error-text"),
                s.innerText = "Произошли какие-то неполадки, мы уже занимаемся этой проблемой. \n Как бы там ни было, вы всегда можете попробовать еще раз";
                let o = document.createElement("p");
                o.innerText = "Пробуем еще раз",
                o.classList.add("error-retry-button");
                let a = document.querySelector(this.blockSelector + "zarbo-widget");
                o.addEventListener("click", (()=>{
                    document.querySelector(this.blockSelector).removeChild(e),
                    document.querySelector(this.blockSelector).removeChild(a),
                    this.init()
                }
                )),
                i.appendChild(r),
                i.appendChild(s),
                i.appendChild(o),
                e.appendChild(i),
                document.querySelector(this.blockSelector).appendChild(e)
            }
            #h() {
                let t = document.getElementById("browser-warning")
                  , e = "flex" === window.getComputedStyle(t, null).getPropertyValue("display");
                t.style.display = e ? "none" : "flex"
            }
            #u() {
                let t = document.createElement("div");
                t.classList.add("main-logo-wrapper"),
                bn.getState().storage.data.icons.find((t=>"eyebrow" === t.type && t.id)) ? t.style.visibility = "visible" : t.style.visibility = "hidden",
                t.addEventListener("click", (()=>{
                    window.open("https://zarbo.tech", "_blank"),
                    this.ourMetric.commitAction("widget_click_eyebrow"),
                    this.customMetric.commitAction("widget_click_eyebrow")
                }
                ));
                let e = document.createElement("div");
                e.classList.add("main-logo");
                let n = bn.getState().storage.data.icons.find((t=>"eyebrow" === t.type && t.id));
                e.style.background = n ? `url(${n.image})` : null,
                e.style.backgroundPosition = "center center",
                e.style.backgroundSize = "80% 80%",
                e.style.backgroundRepeat = "no-repeat",
                t.appendChild(e),
                bn.getState().storage.widget.appendChild(t)
            }
            #c() {
                let t = document.createElement("div");
                t.classList.add("logo-wrapper"),
                bn.getState().storage.data.icons.find((t=>"action" === t.type && t.id)) ? t.style.visibility = "visible" : t.style.visibility = "hidden",
                t.addEventListener("click", (()=>{
                    bn.getState().storage.urlIcon ? window.open(bn.getState().storage.urlIcon, "_blank") : window.open("https://zarbo.tech", "_blank"),
                    this.ourMetric.commitAction("widget_click_link"),
                    this.customMetric.commitAction("widget_click_link")
                }
                ));
                let e = document.createElement("img");
                bn.getState().storage.data.icons.find((t=>"action" === t.type && t.id)) && (e.src = bn.getState().storage.data.icons.find((t=>"action" === t.type && t.id)).image),
                e.style.maxWidth = "50px",
                e.style.maxHeight = "50px";
                let n = document.createElement("div");
                n.classList.add("spinner-wrapper");
                let i = document.createElement("div");
                i.classList.add("spinner"),
                t.appendChild(e),
                n.appendChild(i),
                bn.getState().storage.widget.appendChild(t)
            }
            #s() {
                const t = document.querySelector(this.blockSelector);
                if (t) {
                    let e = document.createElement("zarbo-widget");
                    t.appendChild(e);
                    let n = e.shadowRoot.querySelector("#default-ar-button");
                    return n && (n.style.visibility = "hidden"),
                    bn.dispatch(we(e)),
                    this.classMaterial.widget = e,
                    this.#f(this.options, e),
                    e
                }
                throw new Error("can't find block to create Zarbo widget")
            }
            #a(t) {
                const e = t.target
                  , n = document.querySelector(".progress__main")
                  , i = n.querySelector(".progress__text")
                  , r = n.querySelector(".progress__loaded")
                  , s = Math.floor(100 * t.detail.totalProgress);
                let o = s;
                bn.dispatch(mn(s));
                const a = document.querySelector(".main-logo-wrapper");
                if (bn.getState().storage.data.icons.find((t=>"eyebrow" === t.type && !t.id)) && (a.style.visibility = "hidden"),
                bn.getState().storage.data.hdri && (1 === this.countProgress && (o = Math.floor(o / 2)),
                2 === this.countProgress && (o = Math.floor(o / 2 + 50))),
                i.innerHTML = o + "%",
                r.style.width = o + "%",
                100 === s) {
                    if (n.style.visibility = "hidden",
                    this.countProgress) {
                        if (!("click" === bn.getState().storage.data.loading_type)) {
                            this.startTime = (new Date).getTime();
                            let t = e?.querySelector(".spinner")
                              , n = e?.querySelector(".logo-wrapper")
                              , i = e?.querySelector(".spinner-wrapper");
                            t && (t.style.visibility = "visible",
                            n.style.visibility = "hidden"),
                            i && setTimeout((()=>{
                                i.style.visibility = "visible",
                                i.style.opacity = "1",
                                i.style.background = "#FFFFFF"
                            }
                            ), 500)
                        }
                    }
                    this.countProgress++
                } else
                    n.style.visibility = "visible"
            }
            #l() {
                this.endTime = (new Date).getTime();
                var t = (this.endTime - this.startTime) / 1e3;
                if (this.speed = this.modelSize / t,
                this.firstLoad) {
                    if (this.firstLoad = !1,
                    bn.getState().storage.materials.find((t=>t.is_default))) {
                        let t = ()=>{
                            bn.getState().storage.widget.showPoster(),
                            bn.getState().storage.widget.removeEventListener("poster-dismissed", t)
                        }
                        ;
                        bn.getState().storage.widget.addEventListener("poster-dismissed", t)
                    } else
                        this.classMaterial._removeLoadingSpinner()
                }
                this.callbackAfterLoad && this.callbackAfterLoad(),
                this.#A()
            }
            async #A() {
                if (bn.getState().storage.widget.model) {
                    switch (mr()) {
                    case "ar":
                        let t = new hr;
                        t.callback = this.openAR,
                        bn.dispatch(Xe(t));
                        break;
                    case "qr":
                        let e = new hr;
                        e.callback = (new gr).createQRPopup,
                        e.addStyles("ar-button"),
                        bn.dispatch(Xe(e));
                        break;
                    case "inst":
                        let n = new hr((new pr).createInstPopup);
                        n.callback = (new pr).createInstPopup,
                        bn.dispatch(Xe(n));
                        break;
                    case "openImmediately":
                        let i = document.querySelector(".spinner")
                          , r = document.querySelector(".spinner-wrapper")
                          , s = document.querySelector(".logo-wrapper");
                        if (i && (i.style.visibility = "hidden",
                        s.style.visibility = "visible"),
                        r) {
                            document.querySelector(`${state.blockSelector} zarbo-widget`).removeChild(r)
                        }
                    }
                    if (setTimeout((()=>{
                        bn.dispatch(Me(this.options.change_material))
                    }
                    ), 0),
                    0 !== this.options.product.materials.length && this.options.change_material) {
                        new vr(this.classMaterial).init()
                    }
                    if (!this.options.change_material) {
                        let t = this.classMaterial._getStartMaterial();
                        if (t) {
                            bn.dispatch(Ie(t));
                            let e = {
                                baseColorTexture: null,
                                metallicRoughnessTexture: null,
                                normalTexture: null,
                                occlusionTexture: null,
                                emissiveTexture: null
                            };
                            this.classMaterial._prepareMaterial(t).then((t=>{
                                e = t;
                                const n = bn.getState().storage.widget?.model?.materials[0];
                                n ? this.classMaterial._applyMaterial(e) : this.callbackAfterLoad = this.classMaterial._applyPreparedMaterial()
                            }
                            ))
                        }
                    }
                }
            }
            #g(t, e) {
                return t.models.find((t=>(t.additional_data ? t.additional_data.split(" ") : []).includes(e)))
            }
            async #f(t, e) {
                this.customMetric.counterId = t.ym_id ? t.ym_id : null,
                this.customMetric.commitAction("widget_init"),
                bn.data = t,
                bn.dispatch(Ue(t));
                let n = t.product.materials;
                bn.dispatch(Ce(n));
                let i = this.classMaterial._getStartMaterial();
                bn.dispatch(_e(i && i.image_src ? i.image_src : t.product.preview)),
                bn.dispatch(ge(t.product.ar_placement)),
                bn.dispatch(me(t.ar_scale ?? !0)),
                bn.dispatch(ve(t.camera_controls ?? !0)),
                bn.dispatch(ye(t.disable_zoom ?? !1)),
                bn.dispatch(Fe(t.ar_mode)),
                bn.dispatch(ke(t.url)),
                bn.dispatch(ln(t.icons.find((t=>"action" === t.type)))),
                bn.dispatch(Ge(t.eyebrow_icon_id)),
                bn.dispatch(fn(t.hdri_as_background ?? !1)),
                bn.dispatch(An(t.hdri)),
                "AR" === t.toggleAR ? bn.dispatch(Te("click")) : bn.dispatch(Te(t.loading_type)),
                bn.dispatch(je(t.toggleAR)),
                bn.dispatch(Ye(null !== t.arbtn_position ? t.arbtn_position : "bottom")),
                bn.dispatch(Ke(void 0 === t.arbtn_title ? "ПРИМЕРИТЬ" : t.arbtn_title)),
                bn.dispatch(Je(void 0 === t.arbtn_subtitle ? "" : t.arbtn_subtitle));
                let r = this.#g(t.product, "3d")
                  , s = this.#g(t.product, "ar_ios")
                  , o = this.#g(t.product, "ar_android");
                bn.dispatch(He(t.background_color)),
                bn.dispatch($e(t.qr_color)),
                bn.dispatch(Ze(t.qr_rounded ?? !1));
                let a = t.icons.find((t=>"qr" === t.type && null !== t.id));
                if (bn.dispatch(tn(void 0 !== a ? a : null)),
                bn.dispatch(ze(void 0 === t.max_camera_orbit ? "auto 180deg 150%" : t.max_camera_orbit)),
                bn.dispatch(Ve(void 0 === t.min_camera_orbit ? "auto 0deg 50%" : t.max_camera_orbit)),
                bn.dispatch(We(void 0 === t.camera_orbit ? "0deg 75deg 105%" : t.camera_orbit)),
                r)
                    if (bn.dispatch(en(r.file)),
                    r) {
                        if (bn.getState().storage.widget.getAttribute("src") === r)
                            return;
                        bn.getState().storage.widget.getAttribute("src") ? this._getModelBlob(val).then((t=>{
                            let e = new Blob([t],{});
                            this.widget.setAttribute("src", window.URL.createObjectURL(e))
                        }
                        )) : bn.getState().storage.widget.setAttribute("src", r.file)
                    } else
                        this.widget.removeAttribute("src");
                s && bn.dispatch(Ee(s.file)),
                o && bn.dispatch(nn(o.file));
                let l = {
                    id: bn.getState().storage.widgetId,
                    name: bn.getState().storage.data.product.name
                };
                this.ourMetric.addEcom(l)
            }
            openAR() {
                try {
                    bn.getState().storage.widget.activateAR()
                } catch (t) {
                    console.log("ERRRRRRRR", t)
                }
                if (bn.getState().storage.ourMetric.commitAction("widget_ar"),
                bn.getState().storage.customMetric) {
                    bn.getState().storage.customMetric.commitAction("widget_ar")
                }
                let t = document.createElement("div");
                t.id = "ar-prompt";
                let e = document.createElement("img");
                e.src = n(7626),
                t.appendChild(e),
                bn.getState().storage.widget.appendChild(t)
            }
        }
        class Er {
            constructor(t, e) {
                this.baseApiUrl = t,
                this.widgetId = e
            }
            async getDataWidget() {
                let t = `${this.baseApiUrl}/api/v1/widgets/${this.widgetId}/`;
                return (await this.#e(t)).data
            }
            #e(t) {
                return -1 === t.indexOf("https") && -1 === t.indexOf("http") && (t = "https://" + t),
                cr.get(t)
            }
        }
        class br {
            constructor(t) {
                this.baseApiUrl = t
            }
            async getGeneralIcon() {
                let t = `${this.baseApiUrl}/api/v1/icons/`;
                return (await this.#e(t)).data
            }
            #e(t) {
                return -1 === t.indexOf("https") && -1 === t.indexOf("http") && (t = "https://" + t),
                cr.get(t)
            }
        }
        window.ZarboViewer = class {
            constructor(t, e, n) {
                this.widget = null,
                this.widgetId = e,
                this.baseApiUrl = n,
                this.blockSelector = t
            }
            async init() {
                let t, e, n, i;
                n = this.widgetId,
                i = this.baseApiUrl,
                bn.dispatch(sn(i)),
                bn.dispatch(on(i + "/viewer")),
                bn.dispatch(an(n));
                const r = new Er(i,n);
                if (t = await r.getDataWidget(),
                !t.product.is_active) {
                    const n = await this.#m("/assets/widget_default_settings.json")
                      , r = new br(i);
                    e = await r.getGeneralIcon();
                    t = {
                        ...{
                            ...t,
                            icons: e.results
                        },
                        ...n
                    },
                    t.product.materials.forEach((t=>{
                        t.is_default = !1
                    }
                    ))
                }
                this.zarbo = new _r(this.blockSelector || ".zarbo-viewer",t),
                this.widget = bn.getState().storage.widget
            }
            changeParametr(e, n) {
                !function(e, n) {
                    const i = "update" + e[0].toUpperCase() + e.slice(1);
                    bn.dispatch(t[i](n))
                }(e, n)
            }
            updateMaterial(t) {
                let e = this.zarbo.classMaterial._getMaterialByCodename(t);
                this.zarbo.classMaterial._prepareMaterial(e).then((t=>{
                    this.zarbo.classMaterial._applyMaterial(t)
                }
                ))
            }
            async #m(t) {
                let e = this.baseApiUrl + "/viewer" + t;
                return (await cr.get(e)).data
            }
        }
    }(),
    function() {
        "use strict";
        const t = (t,e)=>"method" === e.kind && e.descriptor && !("value"in e.descriptor) ? {
            ...e,
            finisher(n) {
                n.createProperty(e.key, t)
            }
        } : {
            kind: "field",
            key: Symbol(),
            placement: "own",
            descriptor: {},
            originalKey: e.key,
            initializer() {
                "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this))
            },
            finisher(n) {
                n.createProperty(e.key, t)
            }
        };
        function e(e) {
            return (n,i)=>void 0 !== i ? ((t,e,n)=>{
                e.constructor.createProperty(n, t)
            }
            )(e, n, i) : t(e, n)
        }
        var i;
        null === (i = window.HTMLSlotElement) || void 0 === i || i.prototype.assignedElements;
        const r = "157"
          , s = 1
          , o = 2
          , a = 3
          , l = 100
          , c = 0
          , u = 1
          , h = 2
          , d = 0
          , p = 1
          , f = 2
          , A = 3
          , g = 4
          , m = 5
          , v = 301
          , y = 302
          , _ = 303
          , E = 306
          , b = 1e3
          , x = 1001
          , w = 1002
          , S = 1003
          , C = 1004
          , M = 1005
          , I = 1006
          , T = 1007
          , B = 1008
          , R = 1009
          , L = 1012
          , D = 1014
          , P = 1015
          , U = 1016
          , O = 1020
          , N = 1023
          , F = 1026
          , Q = 1027
          , k = 1028
          , G = 1030
          , H = 33776
          , z = 33777
          , V = 33778
          , W = 33779
          , q = 35840
          , j = 35842
          , X = 37492
          , Y = 37496
          , K = 37808
          , J = 37812
          , $ = 36492
          , Z = 2202
          , tt = 2300
          , et = 2301
          , nt = 2302
          , it = 2400
          , rt = 2401
          , st = 2402
          , ot = 3001
          , at = ""
          , lt = "srgb"
          , ct = "srgb-linear"
          , ut = "display-p3"
          , ht = "display-p3-linear"
          , dt = "linear"
          , pt = "srgb"
          , ft = "rec709"
          , At = "p3"
          , gt = 7680
          , mt = 35044
          , vt = "300 es"
          , yt = 1035
          , _t = 2e3
          , Et = 2001;
        class bt {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++)
                        n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const xt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let wt = 1234567;
        const St = Math.PI / 180
          , Ct = 180 / Math.PI;
        function Mt() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (xt[255 & t] + xt[t >> 8 & 255] + xt[t >> 16 & 255] + xt[t >> 24 & 255] + "-" + xt[255 & e] + xt[e >> 8 & 255] + "-" + xt[e >> 16 & 15 | 64] + xt[e >> 24 & 255] + "-" + xt[63 & n | 128] + xt[n >> 8 & 255] + "-" + xt[n >> 16 & 255] + xt[n >> 24 & 255] + xt[255 & i] + xt[i >> 8 & 255] + xt[i >> 16 & 255] + xt[i >> 24 & 255]).toLowerCase()
        }
        function It(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function Tt(t, e) {
            return (t % e + e) % e
        }
        function Bt(t, e, n) {
            return (1 - n) * t + n * e
        }
        function Rt(t) {
            return 0 == (t & t - 1) && 0 !== t
        }
        function Lt(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function Dt(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        function Pt(t, e) {
            switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return t / 4294967295;
            case Uint16Array:
                return t / 65535;
            case Uint8Array:
                return t / 255;
            case Int32Array:
                return Math.max(t / 2147483647, -1);
            case Int16Array:
                return Math.max(t / 32767, -1);
            case Int8Array:
                return Math.max(t / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function Ut(t, e) {
            switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return Math.round(4294967295 * t);
            case Uint16Array:
                return Math.round(65535 * t);
            case Uint8Array:
                return Math.round(255 * t);
            case Int32Array:
                return Math.round(2147483647 * t);
            case Int16Array:
                return Math.round(32767 * t);
            case Int8Array:
                return Math.round(127 * t);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const Ot = {
            DEG2RAD: St,
            RAD2DEG: Ct,
            generateUUID: Mt,
            clamp: It,
            euclideanModulo: Tt,
            mapLinear: function(t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            inverseLerp: function(t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: Bt,
            damp: function(t, e, n, i) {
                return Bt(t, e, 1 - Math.exp(-n * i))
            },
            pingpong: function(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return e - Math.abs(Tt(t, 2 * e) - e)
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function(t) {
                void 0 !== t && (wt = t);
                let e = wt += 1831565813;
                return e = Math.imul(e ^ e >>> 15, 1 | e),
                e ^= e + Math.imul(e ^ e >>> 7, 61 | e),
                ((e ^ e >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(t) {
                return t * St
            },
            radToDeg: function(t) {
                return t * Ct
            },
            isPowerOfTwo: Rt,
            ceilPowerOfTwo: Lt,
            floorPowerOfTwo: Dt,
            setQuaternionFromProperEuler: function(t, e, n, i, r) {
                const s = Math.cos
                  , o = Math.sin
                  , a = s(n / 2)
                  , l = o(n / 2)
                  , c = s((e + i) / 2)
                  , u = o((e + i) / 2)
                  , h = s((e - i) / 2)
                  , d = o((e - i) / 2)
                  , p = s((i - e) / 2)
                  , f = o((i - e) / 2);
                switch (r) {
                case "XYX":
                    t.set(a * u, l * h, l * d, a * c);
                    break;
                case "YZY":
                    t.set(l * d, a * u, l * h, a * c);
                    break;
                case "ZXZ":
                    t.set(l * h, l * d, a * u, a * c);
                    break;
                case "XZX":
                    t.set(a * u, l * f, l * p, a * c);
                    break;
                case "YXY":
                    t.set(l * p, a * u, l * f, a * c);
                    break;
                case "ZYZ":
                    t.set(l * f, l * p, a * u, a * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: Ut,
            denormalize: Pt
        };
        class Nt {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                Nt.prototype.isVector2 = !0,
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6],
                this.y = i[1] * e + i[4] * n + i[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(It(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = this.x - t.x
                  , s = this.y - t.y;
                return this.x = r * n - s * i + t.x,
                this.y = r * i + s * n + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class Ft {
            constructor(t, e, n, i, r, s, o, a, l) {
                Ft.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== t && this.set(t, e, n, i, r, s, o, a, l)
            }
            set(t, e, n, i, r, s, o, a, l) {
                const c = this.elements;
                return c[0] = t,
                c[1] = i,
                c[2] = o,
                c[3] = e,
                c[4] = r,
                c[5] = a,
                c[6] = n,
                c[7] = s,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , o = n[3]
                  , a = n[6]
                  , l = n[1]
                  , c = n[4]
                  , u = n[7]
                  , h = n[2]
                  , d = n[5]
                  , p = n[8]
                  , f = i[0]
                  , A = i[3]
                  , g = i[6]
                  , m = i[1]
                  , v = i[4]
                  , y = i[7]
                  , _ = i[2]
                  , E = i[5]
                  , b = i[8];
                return r[0] = s * f + o * m + a * _,
                r[3] = s * A + o * v + a * E,
                r[6] = s * g + o * y + a * b,
                r[1] = l * f + c * m + u * _,
                r[4] = l * A + c * v + u * E,
                r[7] = l * g + c * y + u * b,
                r[2] = h * f + d * m + p * _,
                r[5] = h * A + d * v + p * E,
                r[8] = h * g + d * y + p * b,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8];
                return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = c * s - o * l
                  , h = o * a - c * r
                  , d = l * r - s * a
                  , p = e * u + n * h + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f,
                t[1] = (i * l - c * n) * f,
                t[2] = (o * n - i * s) * f,
                t[3] = h * f,
                t[4] = (c * e - i * a) * f,
                t[5] = (i * r - o * e) * f,
                t[6] = d * f,
                t[7] = (n * a - l * e) * f,
                t[8] = (s * e - n * r) * f,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, n, i, r, s, o) {
                const a = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                return this.premultiply(Qt.makeScale(t, e)),
                this
            }
            rotate(t) {
                return this.premultiply(Qt.makeRotation(-t)),
                this
            }
            translate(t, e) {
                return this.premultiply(Qt.makeTranslation(t, e)),
                this
            }
            makeTranslation(t, e) {
                return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
                this
            }
            makeRotation(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, n, e, 0, 0, 0, 1),
                this
            }
            makeScale(t, e) {
                return this.set(t, 0, 0, 0, e, 0, 0, 0, 1),
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Qt = new Ft;
        function kt(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] >= 65535)
                    return !0;
            return !1
        }
        function Gt(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }
        function Ht() {
            const t = Gt("canvas");
            return t.style.display = "block",
            t
        }
        const zt = {};
        function Vt(t) {
            t in zt || (zt[t] = !0,
            console.warn(t))
        }
        const Wt = (new Ft).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , qt = (new Ft).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , jt = {
            [ct]: {
                transfer: dt,
                primaries: ft,
                toReference: t=>t,
                fromReference: t=>t
            },
            [lt]: {
                transfer: pt,
                primaries: ft,
                toReference: t=>t.convertSRGBToLinear(),
                fromReference: t=>t.convertLinearToSRGB()
            },
            [ht]: {
                transfer: dt,
                primaries: At,
                toReference: t=>t.applyMatrix3(qt),
                fromReference: t=>t.applyMatrix3(Wt)
            },
            [ut]: {
                transfer: pt,
                primaries: At,
                toReference: t=>t.convertSRGBToLinear().applyMatrix3(qt),
                fromReference: t=>t.applyMatrix3(Wt).convertLinearToSRGB()
            }
        }
          , Xt = new Set([ct, ht])
          , Yt = {
            enabled: !0,
            _workingColorSpace: ct,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                !this.enabled
            },
            set legacyMode(t) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                this.enabled = !t
            },
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(t) {
                if (!Xt.has(t))
                    throw new Error(`Unsupported working color space, "${t}".`);
                this._workingColorSpace = t
            },
            convert: function(t, e, n) {
                if (!1 === this.enabled || e === n || !e || !n)
                    return t;
                const i = jt[e].toReference;
                return (0,
                jt[n].fromReference)(i(t))
            },
            fromWorkingColorSpace: function(t, e) {
                return this.convert(t, this._workingColorSpace, e)
            },
            toWorkingColorSpace: function(t, e) {
                return this.convert(t, e, this._workingColorSpace)
            },
            getPrimaries: function(t) {
                return jt[t].primaries
            },
            getTransfer: function(t) {
                return t === at ? dt : jt[t].transfer
            }
        };
        function Kt(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function Jt(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        let $t;
        class Zt {
            static getDataURL(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === $t && ($t = Gt("canvas")),
                    $t.width = t.width,
                    $t.height = t.height;
                    const n = $t.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                    e = $t
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = Gt("canvas");
                    e.width = t.width,
                    e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height)
                      , r = i.data;
                    for (let t = 0; t < r.length; t++)
                        r[t] = 255 * Kt(r[t] / 255);
                    return n.putImageData(i, 0, 0),
                    e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++)
                        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Kt(e[t] / 255)) : e[t] = Kt(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                t
            }
        }
        let te = 0;
        class ee {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: te++
                }),
                this.uuid = Mt(),
                this.data = t,
                this.version = 0
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.images[this.uuid])
                    return t.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , i = this.data;
                if (null !== i) {
                    let t;
                    if (Array.isArray(i)) {
                        t = [];
                        for (let e = 0, n = i.length; e < n; e++)
                            i[e].isDataTexture ? t.push(ne(i[e].image)) : t.push(ne(i[e]))
                    } else
                        t = ne(i);
                    n.url = t
                }
                return e || (t.images[this.uuid] = n),
                n
            }
        }
        function ne(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? Zt.getDataURL(t) : t.data ? {
                data: Array.from(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let ie = 0;
        class re extends bt {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : re.DEFAULT_IMAGE
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : re.DEFAULT_MAPPING
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1001
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1001
                  , r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1006
                  , s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1008
                  , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1023
                  , a = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 1009
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : re.DEFAULT_ANISOTROPY
                  , c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : at;
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: ie++
                }),
                this.uuid = Mt(),
                this.name = "",
                this.source = new ee(t),
                this.mipmaps = [],
                this.mapping = e,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = s,
                this.anisotropy = l,
                this.format = o,
                this.internalFormat = null,
                this.type = a,
                this.offset = new Nt(0,0),
                this.repeat = new Nt(1,1),
                this.center = new Nt(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Ft,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                "string" == typeof c ? this.colorSpace = c : (Vt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = c === ot ? lt : at),
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(t) {
                void 0 === t && (t = null),
                this.source.data = t
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.source = t.source,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.channel = t.channel,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.colorSpace = t.colorSpace,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(t).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                e || (t.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case b:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case x:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case w:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case b:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case x:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case w:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && (this.version++,
                this.source.needsUpdate = !0)
            }
            get encoding() {
                return Vt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace === lt ? ot : 3e3
            }
            set encoding(t) {
                Vt("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = t === ot ? lt : at
            }
        }
        re.DEFAULT_IMAGE = null,
        re.DEFAULT_MAPPING = 300,
        re.DEFAULT_ANISOTROPY = 1;
        class se {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                se.prototype.isVector4 = !0,
                this.x = t,
                this.y = e,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t,
                this.y = e,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r,
                this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r,
                this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r,
                this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = .01
                  , o = .1
                  , a = t.elements
                  , l = a[0]
                  , c = a[4]
                  , u = a[8]
                  , h = a[1]
                  , d = a[5]
                  , p = a[9]
                  , f = a[2]
                  , A = a[6]
                  , g = a[10];
                if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - A) < s) {
                    if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + A) < o && Math.abs(l + d + g - 3) < o)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (l + 1) / 2
                      , a = (d + 1) / 2
                      , m = (g + 1) / 2
                      , v = (c + h) / 4
                      , y = (u + f) / 4
                      , _ = (p + A) / 4;
                    return t > a && t > m ? t < s ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(t),
                    i = v / n,
                    r = y / n) : a > m ? a < s ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(a),
                    n = v / i,
                    r = _ / i) : m < s ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(m),
                    n = y / r,
                    i = _ / r),
                    this.set(n, i, r, e),
                    this
                }
                let m = Math.sqrt((A - p) * (A - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(m) < .001 && (m = 1),
                this.x = (A - p) / m,
                this.y = (u - f) / m,
                this.z = (h - c) / m,
                this.w = Math.acos((l + d + g - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this.w = t.w + (e.w - t.w) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class oe extends bt {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                super(),
                this.isRenderTarget = !0,
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new se(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new se(0,0,t,e);
                const i = {
                    width: t,
                    height: e,
                    depth: 1
                };
                void 0 !== n.encoding && (Vt("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
                n.colorSpace = n.encoding === ot ? lt : at),
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: I,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, n),
                this.texture = new re(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = n.generateMipmaps,
                this.texture.internalFormat = n.internalFormat,
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            setSize(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                this.width === t && this.height === e && this.depth === n || (this.width = t,
                this.height = e,
                this.depth = n,
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.scissor.copy(t.scissor),
                this.scissorTest = t.scissorTest,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const e = Object.assign({}, t.texture.image);
                return this.texture.source = new ee(e),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
                this.samples = t.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class ae extends oe {
            constructor() {
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}),
                this.isWebGLRenderTarget = !0
            }
        }
        class le extends re {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = S,
                this.minFilter = S,
                this.wrapR = x,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class ce extends re {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = S,
                this.minFilter = S,
                this.wrapR = x,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class ue {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                this.isQuaternion = !0,
                this._x = t,
                this._y = e,
                this._z = n,
                this._w = i
            }
            static slerpFlat(t, e, n, i, r, s, o) {
                let a = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , u = n[i + 3];
                const h = r[s + 0]
                  , d = r[s + 1]
                  , p = r[s + 2]
                  , f = r[s + 3];
                if (0 === o)
                    return t[e + 0] = a,
                    t[e + 1] = l,
                    t[e + 2] = c,
                    void (t[e + 3] = u);
                if (1 === o)
                    return t[e + 0] = h,
                    t[e + 1] = d,
                    t[e + 2] = p,
                    void (t[e + 3] = f);
                if (u !== f || a !== h || l !== d || c !== p) {
                    let t = 1 - o;
                    const e = a * h + l * d + c * p + u * f
                      , n = e >= 0 ? 1 : -1
                      , i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r,
                        o = Math.sin(o * s) / r
                    }
                    const r = o * n;
                    if (a = a * t + h * r,
                    l = l * t + d * r,
                    c = c * t + p * r,
                    u = u * t + f * r,
                    t === 1 - o) {
                        const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                        a *= t,
                        l *= t,
                        c *= t,
                        u *= t
                    }
                }
                t[e] = a,
                t[e + 1] = l,
                t[e + 2] = c,
                t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const o = n[i]
                  , a = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , u = r[s]
                  , h = r[s + 1]
                  , d = r[s + 2]
                  , p = r[s + 3];
                return t[e] = o * p + c * u + a * d - l * h,
                t[e + 1] = a * p + c * h + l * u - o * d,
                t[e + 2] = l * p + c * d + o * h - a * u,
                t[e + 3] = c * p - o * u - a * h - l * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._order
                  , o = Math.cos
                  , a = Math.sin
                  , l = o(n / 2)
                  , c = o(i / 2)
                  , u = o(r / 2)
                  , h = a(n / 2)
                  , d = a(i / 2)
                  , p = a(r / 2);
                switch (s) {
                case "XYZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "YXZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "ZXY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "ZYX":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "YZX":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "XZY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                  , i = Math.sin(n);
                return this._x = t.x * i,
                this._y = t.y * i,
                this._z = t.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , n = e[0]
                  , i = e[4]
                  , r = e[8]
                  , s = e[1]
                  , o = e[5]
                  , a = e[9]
                  , l = e[2]
                  , c = e[6]
                  , u = e[10]
                  , h = n + o + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t,
                    this._x = (c - a) * t,
                    this._y = (r - l) * t,
                    this._z = (s - i) * t
                } else if (n > o && n > u) {
                    const t = 2 * Math.sqrt(1 + n - o - u);
                    this._w = (c - a) / t,
                    this._x = .25 * t,
                    this._y = (i + s) / t,
                    this._z = (r + l) / t
                } else if (o > u) {
                    const t = 2 * Math.sqrt(1 + o - n - u);
                    this._w = (r - l) / t,
                    this._x = (i + s) / t,
                    this._y = .25 * t,
                    this._z = (a + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - o);
                    this._w = (s - i) / t,
                    this._x = (r + l) / t,
                    this._y = (a + c) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = n),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(It(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t) {
                return this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._w
                  , o = e._x
                  , a = e._y
                  , l = e._z
                  , c = e._w;
                return this._x = n * c + s * o + i * l - r * a,
                this._y = i * c + s * a + r * o - n * l,
                this._z = r * c + s * l + n * a - i * o,
                this._w = s * c - n * o - i * a - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , s = this._w;
                let o = s * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                o = -o) : this.copy(t),
                o >= 1)
                    return this._w = s,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const a = 1 - o * o;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w,
                    this._x = t * n + e * this._x,
                    this._y = t * i + e * this._y,
                    this._z = t * r + e * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const l = Math.sqrt(a)
                  , c = Math.atan2(l, o)
                  , u = Math.sin((1 - e) * c) / l
                  , h = Math.sin(e * c) / l;
                return this._w = s * u + this._w * h,
                this._x = n * u + this._x * h,
                this._y = i * u + this._y * h,
                this._z = r * u + this._z * h,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random()
                  , e = Math.sqrt(1 - t)
                  , n = Math.sqrt(t)
                  , i = 2 * Math.PI * Math.random()
                  , r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class he {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                he.prototype.isVector3 = !0,
                this.x = t,
                this.y = e,
                this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                this.x = t,
                this.y = e,
                this.z = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t) {
                return this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return this.applyQuaternion(pe.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(pe.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i,
                this.y = r[1] * e + r[4] * n + r[7] * i,
                this.z = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements
                  , s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s,
                this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s,
                this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.x
                  , s = t.y
                  , o = t.z
                  , a = t.w
                  , l = a * e + s * i - o * n
                  , c = a * n + o * e - r * i
                  , u = a * i + r * n - s * e
                  , h = -r * e - s * n - o * i;
                return this.x = l * a + h * -r + c * -o - u * -s,
                this.y = c * a + h * -s + u * -r - l * -o,
                this.z = u * a + h * -o + l * -s - c * -r,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i,
                this.y = r[1] * e + r[5] * n + r[9] * i,
                this.z = r[2] * e + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this
            }
            cross(t) {
                return this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = e.x
                  , o = e.y
                  , a = e.z;
                return this.x = i * a - r * o,
                this.y = r * s - n * a,
                this.z = n * o - i * s,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return de.copy(this).projectOnVector(t),
                this.sub(de)
            }
            reflect(t) {
                return this.sub(de.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(It(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y
                  , i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(e) * t,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                this.y = n,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , n = this.setFromMatrixColumn(t, 1).length()
                  , i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            setFromEuler(t) {
                return this.x = t._x,
                this.y = t._y,
                this.z = t._z,
                this
            }
            setFromColor(t) {
                return this.x = t.r,
                this.y = t.g,
                this.z = t.b,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e) {
                return this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5)
                  , e = Math.random() * Math.PI * 2
                  , n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e),
                this.y = n * Math.sin(e),
                this.z = t,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const de = new he
          , pe = new ue;
        class fe {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new he(1 / 0,1 / 0,1 / 0)
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new he(-1 / 0,-1 / 0,-1 / 0);
                this.isBox3 = !0,
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e += 3)
                    this.expandByPoint(ge.fromArray(t, e));
                return this
            }
            setFromBufferAttribute(t) {
                this.makeEmpty();
                for (let e = 0, n = t.count; e < n; e++)
                    this.expandByPoint(ge.fromBufferAttribute(t, e));
                return this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = ge.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            setFromObject(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                return this.makeEmpty(),
                this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (t.updateWorldMatrix(!1, !1),
                void 0 !== t.boundingBox)
                    null === t.boundingBox && t.computeBoundingBox(),
                    me.copy(t.boundingBox),
                    me.applyMatrix4(t.matrixWorld),
                    this.union(me);
                else {
                    const n = t.geometry;
                    if (void 0 !== n)
                        if (e && void 0 !== n.attributes && void 0 !== n.attributes.position) {
                            const e = n.attributes.position;
                            for (let n = 0, i = e.count; n < i; n++)
                                ge.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                                this.expandByPoint(ge)
                        } else
                            null === n.boundingBox && n.computeBoundingBox(),
                            me.copy(n.boundingBox),
                            me.applyMatrix4(t.matrixWorld),
                            this.union(me)
                }
                const n = t.children;
                for (let t = 0, i = n.length; t < i; t++)
                    this.expandByObject(n[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, ge),
                ge.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(we),
                Se.subVectors(this.max, we),
                ve.subVectors(t.a, we),
                ye.subVectors(t.b, we),
                _e.subVectors(t.c, we),
                Ee.subVectors(ye, ve),
                be.subVectors(_e, ye),
                xe.subVectors(ve, _e);
                let e = [0, -Ee.z, Ee.y, 0, -be.z, be.y, 0, -xe.z, xe.y, Ee.z, 0, -Ee.x, be.z, 0, -be.x, xe.z, 0, -xe.x, -Ee.y, Ee.x, 0, -be.y, be.x, 0, -xe.y, xe.x, 0];
                return !!Ie(e, ve, ye, _e, Se) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Ie(e, ve, ye, _e, Se) && (Ce.crossVectors(Ee, be),
                e = [Ce.x, Ce.y, Ce.z],
                Ie(e, ve, ye, _e, Se)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return this.clampPoint(t, ge).distanceTo(t)
            }
            getBoundingSphere(t) {
                return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center),
                t.radius = .5 * this.getSize(ge).length()),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (Ae[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                Ae[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                Ae[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                Ae[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                Ae[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                Ae[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                Ae[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                Ae[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(Ae)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        const Ae = [new he, new he, new he, new he, new he, new he, new he, new he]
          , ge = new he
          , me = new fe
          , ve = new he
          , ye = new he
          , _e = new he
          , Ee = new he
          , be = new he
          , xe = new he
          , we = new he
          , Se = new he
          , Ce = new he
          , Me = new he;
        function Ie(t, e, n, i, r) {
            for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                Me.fromArray(t, s);
                const o = r.x * Math.abs(Me.x) + r.y * Math.abs(Me.y) + r.z * Math.abs(Me.z)
                  , a = e.dot(Me)
                  , l = n.dot(Me)
                  , c = i.dot(Me);
                if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o)
                    return !1
            }
            return !0
        }
        const Te = new fe
          , Be = new he
          , Re = new he;
        class Le {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new he
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : Te.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++)
                    i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            expandByPoint(t) {
                if (this.isEmpty())
                    return this.center.copy(t),
                    this.radius = 0,
                    this;
                Be.subVectors(t, this.center);
                const e = Be.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                      , n = .5 * (t - this.radius);
                    this.center.addScaledVector(Be, n / t),
                    this.radius += n
                }
                return this
            }
            union(t) {
                return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t),
                this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (Re.subVectors(t.center, this.center).setLength(t.radius),
                this.expandByPoint(Be.copy(t.center).add(Re)),
                this.expandByPoint(Be.copy(t.center).sub(Re))),
                this)
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const De = new he
          , Pe = new he
          , Ue = new he
          , Oe = new he
          , Ne = new he
          , Fe = new he
          , Qe = new he;
        class ke {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new he
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new he(0,0,-1);
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return e.copy(this.origin).addScaledVector(this.direction, t)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, De)),
                this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = De.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (De.copy(this.origin).addScaledVector(this.direction, e),
                De.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Pe.copy(t).add(e).multiplyScalar(.5),
                Ue.copy(e).sub(t).normalize(),
                Oe.copy(this.origin).sub(Pe);
                const r = .5 * t.distanceTo(e)
                  , s = -this.direction.dot(Ue)
                  , o = Oe.dot(this.direction)
                  , a = -Oe.dot(Ue)
                  , l = Oe.lengthSq()
                  , c = Math.abs(1 - s * s);
                let u, h, d, p;
                if (c > 0)
                    if (u = s * a - o,
                    h = s * o - a,
                    p = r * c,
                    u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const t = 1 / c;
                                u *= t,
                                h *= t,
                                d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l
                            } else
                                h = r,
                                u = Math.max(0, -(s * h + o)),
                                d = -u * u + h * (h + 2 * a) + l;
                        else
                            h = -r,
                            u = Math.max(0, -(s * h + o)),
                            d = -u * u + h * (h + 2 * a) + l;
                    else
                        h <= -p ? (u = Math.max(0, -(-s * r + o)),
                        h = u > 0 ? -r : Math.min(Math.max(-r, -a), r),
                        d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0,
                        h = Math.min(Math.max(-r, -a), r),
                        d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * r + o)),
                        h = u > 0 ? r : Math.min(Math.max(-r, -a), r),
                        d = -u * u + h * (h + 2 * a) + l);
                else
                    h = s > 0 ? -r : r,
                    u = Math.max(0, -(s * h + o)),
                    d = -u * u + h * (h + 2 * a) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u),
                i && i.copy(Pe).addScaledVector(Ue, h),
                d
            }
            intersectSphere(t, e) {
                De.subVectors(t.center, this.origin);
                const n = De.dot(this.direction)
                  , i = De.dot(De) - n * n
                  , r = t.radius * t.radius;
                if (i > r)
                    return null;
                const s = Math.sqrt(r - i)
                  , o = n - s
                  , a = n + s;
                return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, o, a;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l,
                i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l,
                i = (t.min.x - h.x) * l),
                c >= 0 ? (r = (t.min.y - h.y) * c,
                s = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c,
                s = (t.min.y - h.y) * c),
                n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                (s < i || isNaN(i)) && (i = s),
                u >= 0 ? (o = (t.min.z - h.z) * u,
                a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u,
                a = (t.min.z - h.z) * u),
                n > a || o > i ? null : ((o > n || n != n) && (n = o),
                (a < i || i != i) && (i = a),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, De)
            }
            intersectTriangle(t, e, n, i, r) {
                Ne.subVectors(e, t),
                Fe.subVectors(n, t),
                Qe.crossVectors(Ne, Fe);
                let s, o = this.direction.dot(Qe);
                if (o > 0) {
                    if (i)
                        return null;
                    s = 1
                } else {
                    if (!(o < 0))
                        return null;
                    s = -1,
                    o = -o
                }
                Oe.subVectors(this.origin, t);
                const a = s * this.direction.dot(Fe.crossVectors(Oe, Fe));
                if (a < 0)
                    return null;
                const l = s * this.direction.dot(Ne.cross(Oe));
                if (l < 0)
                    return null;
                if (a + l > o)
                    return null;
                const c = -s * Oe.dot(Qe);
                return c < 0 ? null : this.at(c / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ge {
            constructor(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, A) {
                Ge.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== t && this.set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, A)
            }
            set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, A) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = s,
                g[9] = o,
                g[13] = a,
                g[2] = l,
                g[6] = c,
                g[10] = u,
                g[14] = h,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = A,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Ge).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , n = t.elements
                  , i = 1 / He.setFromMatrixColumn(t, 0).length()
                  , r = 1 / He.setFromMatrixColumn(t, 1).length()
                  , s = 1 / He.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i,
                e[1] = n[1] * i,
                e[2] = n[2] * i,
                e[3] = 0,
                e[4] = n[4] * r,
                e[5] = n[5] * r,
                e[6] = n[6] * r,
                e[7] = 0,
                e[8] = n[8] * s,
                e[9] = n[9] * s,
                e[10] = n[10] * s,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z
                  , s = Math.cos(n)
                  , o = Math.sin(n)
                  , a = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * c
                      , n = s * u
                      , i = o * c
                      , r = o * u;
                    e[0] = a * c,
                    e[4] = -a * u,
                    e[8] = l,
                    e[1] = n + i * l,
                    e[5] = t - r * l,
                    e[9] = -o * a,
                    e[2] = r - t * l,
                    e[6] = i + n * l,
                    e[10] = s * a
                } else if ("YXZ" === t.order) {
                    const t = a * c
                      , n = a * u
                      , i = l * c
                      , r = l * u;
                    e[0] = t + r * o,
                    e[4] = i * o - n,
                    e[8] = s * l,
                    e[1] = s * u,
                    e[5] = s * c,
                    e[9] = -o,
                    e[2] = n * o - i,
                    e[6] = r + t * o,
                    e[10] = s * a
                } else if ("ZXY" === t.order) {
                    const t = a * c
                      , n = a * u
                      , i = l * c
                      , r = l * u;
                    e[0] = t - r * o,
                    e[4] = -s * u,
                    e[8] = i + n * o,
                    e[1] = n + i * o,
                    e[5] = s * c,
                    e[9] = r - t * o,
                    e[2] = -s * l,
                    e[6] = o,
                    e[10] = s * a
                } else if ("ZYX" === t.order) {
                    const t = s * c
                      , n = s * u
                      , i = o * c
                      , r = o * u;
                    e[0] = a * c,
                    e[4] = i * l - n,
                    e[8] = t * l + r,
                    e[1] = a * u,
                    e[5] = r * l + t,
                    e[9] = n * l - i,
                    e[2] = -l,
                    e[6] = o * a,
                    e[10] = s * a
                } else if ("YZX" === t.order) {
                    const t = s * a
                      , n = s * l
                      , i = o * a
                      , r = o * l;
                    e[0] = a * c,
                    e[4] = r - t * u,
                    e[8] = i * u + n,
                    e[1] = u,
                    e[5] = s * c,
                    e[9] = -o * c,
                    e[2] = -l * c,
                    e[6] = n * u + i,
                    e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = s * a
                      , n = s * l
                      , i = o * a
                      , r = o * l;
                    e[0] = a * c,
                    e[4] = -u,
                    e[8] = l * c,
                    e[1] = t * u + r,
                    e[5] = s * c,
                    e[9] = n * u - i,
                    e[2] = i * u - n,
                    e[6] = o * c,
                    e[10] = r * u + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Ve, t, We)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return Xe.subVectors(t, e),
                0 === Xe.lengthSq() && (Xe.z = 1),
                Xe.normalize(),
                qe.crossVectors(n, Xe),
                0 === qe.lengthSq() && (1 === Math.abs(n.z) ? Xe.x += 1e-4 : Xe.z += 1e-4,
                Xe.normalize(),
                qe.crossVectors(n, Xe)),
                qe.normalize(),
                je.crossVectors(Xe, qe),
                i[0] = qe.x,
                i[4] = je.x,
                i[8] = Xe.x,
                i[1] = qe.y,
                i[5] = je.y,
                i[9] = Xe.y,
                i[2] = qe.z,
                i[6] = je.z,
                i[10] = Xe.z,
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , o = n[4]
                  , a = n[8]
                  , l = n[12]
                  , c = n[1]
                  , u = n[5]
                  , h = n[9]
                  , d = n[13]
                  , p = n[2]
                  , f = n[6]
                  , A = n[10]
                  , g = n[14]
                  , m = n[3]
                  , v = n[7]
                  , y = n[11]
                  , _ = n[15]
                  , E = i[0]
                  , b = i[4]
                  , x = i[8]
                  , w = i[12]
                  , S = i[1]
                  , C = i[5]
                  , M = i[9]
                  , I = i[13]
                  , T = i[2]
                  , B = i[6]
                  , R = i[10]
                  , L = i[14]
                  , D = i[3]
                  , P = i[7]
                  , U = i[11]
                  , O = i[15];
                return r[0] = s * E + o * S + a * T + l * D,
                r[4] = s * b + o * C + a * B + l * P,
                r[8] = s * x + o * M + a * R + l * U,
                r[12] = s * w + o * I + a * L + l * O,
                r[1] = c * E + u * S + h * T + d * D,
                r[5] = c * b + u * C + h * B + d * P,
                r[9] = c * x + u * M + h * R + d * U,
                r[13] = c * w + u * I + h * L + d * O,
                r[2] = p * E + f * S + A * T + g * D,
                r[6] = p * b + f * C + A * B + g * P,
                r[10] = p * x + f * M + A * R + g * U,
                r[14] = p * w + f * I + A * L + g * O,
                r[3] = m * E + v * S + y * T + _ * D,
                r[7] = m * b + v * C + y * B + _ * P,
                r[11] = m * x + v * M + y * R + _ * U,
                r[15] = m * w + v * I + y * L + _ * O,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[4]
                  , i = t[8]
                  , r = t[12]
                  , s = t[1]
                  , o = t[5]
                  , a = t[9]
                  , l = t[13]
                  , c = t[2]
                  , u = t[6]
                  , h = t[10]
                  , d = t[14];
                return t[3] * (+r * a * u - i * l * u - r * o * h + n * l * h + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * s * h - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * o * d - r * s * u + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * u + e * o * h + i * s * u - n * s * h + n * a * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z) : (i[12] = t,
                i[13] = e,
                i[14] = n),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = t[9]
                  , h = t[10]
                  , d = t[11]
                  , p = t[12]
                  , f = t[13]
                  , A = t[14]
                  , g = t[15]
                  , m = u * A * l - f * h * l + f * a * d - o * A * d - u * a * g + o * h * g
                  , v = p * h * l - c * A * l - p * a * d + s * A * d + c * a * g - s * h * g
                  , y = c * f * l - p * u * l + p * o * d - s * f * d - c * o * g + s * u * g
                  , _ = p * u * a - c * f * a - p * o * h + s * f * h + c * o * A - s * u * A
                  , E = e * m + n * v + i * y + r * _;
                if (0 === E)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const b = 1 / E;
                return t[0] = m * b,
                t[1] = (f * h * r - u * A * r - f * i * d + n * A * d + u * i * g - n * h * g) * b,
                t[2] = (o * A * r - f * a * r + f * i * l - n * A * l - o * i * g + n * a * g) * b,
                t[3] = (u * a * r - o * h * r - u * i * l + n * h * l + o * i * d - n * a * d) * b,
                t[4] = v * b,
                t[5] = (c * A * r - p * h * r + p * i * d - e * A * d - c * i * g + e * h * g) * b,
                t[6] = (p * a * r - s * A * r - p * i * l + e * A * l + s * i * g - e * a * g) * b,
                t[7] = (s * h * r - c * a * r + c * i * l - e * h * l - s * i * d + e * a * d) * b,
                t[8] = y * b,
                t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * g - e * u * g) * b,
                t[10] = (s * f * r - p * o * r + p * n * l - e * f * l - s * n * g + e * o * g) * b,
                t[11] = (c * o * r - s * u * r - c * n * l + e * u * l + s * n * d - e * o * d) * b,
                t[12] = _ * b,
                t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * A + e * u * A) * b,
                t[14] = (p * o * i - s * f * i - p * n * a + e * f * a + s * n * A - e * o * A) * b,
                t[15] = (s * u * i - c * o * i + c * n * a - e * u * a - s * n * h + e * o * h) * b,
                this
            }
            scale(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z;
                return e[0] *= n,
                e[4] *= i,
                e[8] *= r,
                e[1] *= n,
                e[5] *= i,
                e[9] *= r,
                e[2] *= n,
                e[6] *= i,
                e[10] *= r,
                e[3] *= n,
                e[7] *= i,
                e[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = 1 - n
                  , s = t.x
                  , o = t.y
                  , a = t.z
                  , l = r * s
                  , c = r * o;
                return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, n, i, r, s) {
                return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, n) {
                const i = this.elements
                  , r = e._x
                  , s = e._y
                  , o = e._z
                  , a = e._w
                  , l = r + r
                  , c = s + s
                  , u = o + o
                  , h = r * l
                  , d = r * c
                  , p = r * u
                  , f = s * c
                  , A = s * u
                  , g = o * u
                  , m = a * l
                  , v = a * c
                  , y = a * u
                  , _ = n.x
                  , E = n.y
                  , b = n.z;
                return i[0] = (1 - (f + g)) * _,
                i[1] = (d + y) * _,
                i[2] = (p - v) * _,
                i[3] = 0,
                i[4] = (d - y) * E,
                i[5] = (1 - (h + g)) * E,
                i[6] = (A + m) * E,
                i[7] = 0,
                i[8] = (p + v) * b,
                i[9] = (A - m) * b,
                i[10] = (1 - (h + f)) * b,
                i[11] = 0,
                i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z,
                i[15] = 1,
                this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = He.set(i[0], i[1], i[2]).length();
                const s = He.set(i[4], i[5], i[6]).length()
                  , o = He.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                t.x = i[12],
                t.y = i[13],
                t.z = i[14],
                ze.copy(this);
                const a = 1 / r
                  , l = 1 / s
                  , c = 1 / o;
                return ze.elements[0] *= a,
                ze.elements[1] *= a,
                ze.elements[2] *= a,
                ze.elements[4] *= l,
                ze.elements[5] *= l,
                ze.elements[6] *= l,
                ze.elements[8] *= c,
                ze.elements[9] *= c,
                ze.elements[10] *= c,
                e.setFromRotationMatrix(ze),
                n.x = r,
                n.y = s,
                n.z = o,
                this
            }
            makePerspective(t, e, n, i, r, s) {
                let o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 2e3;
                const a = this.elements
                  , l = 2 * r / (e - t)
                  , c = 2 * r / (n - i)
                  , u = (e + t) / (e - t)
                  , h = (n + i) / (n - i);
                let d, p;
                if (o === _t)
                    d = -(s + r) / (s - r),
                    p = -2 * s * r / (s - r);
                else {
                    if (o !== Et)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
                    d = -s / (s - r),
                    p = -s * r / (s - r)
                }
                return a[0] = l,
                a[4] = 0,
                a[8] = u,
                a[12] = 0,
                a[1] = 0,
                a[5] = c,
                a[9] = h,
                a[13] = 0,
                a[2] = 0,
                a[6] = 0,
                a[10] = d,
                a[14] = p,
                a[3] = 0,
                a[7] = 0,
                a[11] = -1,
                a[15] = 0,
                this
            }
            makeOrthographic(t, e, n, i, r, s) {
                let o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 2e3;
                const a = this.elements
                  , l = 1 / (e - t)
                  , c = 1 / (n - i)
                  , u = 1 / (s - r)
                  , h = (e + t) * l
                  , d = (n + i) * c;
                let p, f;
                if (o === _t)
                    p = (s + r) * u,
                    f = -2 * u;
                else {
                    if (o !== Et)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
                    p = r * u,
                    f = -1 * u
                }
                return a[0] = 2 * l,
                a[4] = 0,
                a[8] = 0,
                a[12] = -h,
                a[1] = 0,
                a[5] = 2 * c,
                a[9] = 0,
                a[13] = -d,
                a[2] = 0,
                a[6] = 0,
                a[10] = f,
                a[14] = -p,
                a[3] = 0,
                a[7] = 0,
                a[11] = 0,
                a[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        }
        const He = new he
          , ze = new Ge
          , Ve = new he(0,0,0)
          , We = new he(1,1,1)
          , qe = new he
          , je = new he
          , Xe = new he
          , Ye = new Ge
          , Ke = new ue;
        class Je {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Je.DEFAULT_ORDER;
                this.isEuler = !0,
                this._x = t,
                this._y = e,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order
                  , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                const i = t.elements
                  , r = i[0]
                  , s = i[4]
                  , o = i[8]
                  , a = i[1]
                  , l = i[5]
                  , c = i[9]
                  , u = i[2]
                  , h = i[6]
                  , d = i[10];
                switch (e) {
                case "XYZ":
                    this._y = Math.asin(It(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d),
                    this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-It(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d),
                    this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(It(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(a, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-It(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d),
                    this._z = Math.atan2(a, r)) : (this._x = 0,
                    this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(It(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-u, r)) : (this._x = 0,
                    this._y = Math.atan2(o, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-It(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l),
                    this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, n) {
                return Ye.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(Ye, e, n)
            }
            setFromVector3(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Ke.setFromEuler(this),
                this.setFromQuaternion(Ke, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        Je.DEFAULT_ORDER = "XYZ";
        class $e {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let Ze = 0;
        const tn = new he
          , en = new ue
          , nn = new Ge
          , rn = new he
          , sn = new he
          , on = new he
          , an = new ue
          , ln = new he(1,0,0)
          , cn = new he(0,1,0)
          , un = new he(0,0,1)
          , hn = {
            type: "added"
        }
          , dn = {
            type: "removed"
        };
        class pn extends bt {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: Ze++
                }),
                this.uuid = Mt(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = pn.DEFAULT_UP.clone();
                const t = new he
                  , e = new Je
                  , n = new ue
                  , i = new he(1,1,1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                }
                )),
                n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ge
                    },
                    normalMatrix: {
                        value: new Ft
                    }
                }),
                this.matrix = new Ge,
                this.matrixWorld = new Ge,
                this.matrixAutoUpdate = pn.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.matrixWorldAutoUpdate = pn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.layers = new $e,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t),
                this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return en.setFromAxisAngle(t, e),
                this.quaternion.multiply(en),
                this
            }
            rotateOnWorldAxis(t, e) {
                return en.setFromAxisAngle(t, e),
                this.quaternion.premultiply(en),
                this
            }
            rotateX(t) {
                return this.rotateOnAxis(ln, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(cn, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(un, t)
            }
            translateOnAxis(t, e) {
                return tn.copy(t).applyQuaternion(this.quaternion),
                this.position.add(tn.multiplyScalar(e)),
                this
            }
            translateX(t) {
                return this.translateOnAxis(ln, t)
            }
            translateY(t) {
                return this.translateOnAxis(cn, t)
            }
            translateZ(t) {
                return this.translateOnAxis(un, t)
            }
            localToWorld(t) {
                return this.updateWorldMatrix(!0, !1),
                t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return this.updateWorldMatrix(!0, !1),
                t.applyMatrix4(nn.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? rn.copy(t) : rn.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                sn.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? nn.lookAt(sn, rn, this.up) : nn.lookAt(rn, sn, this.up),
                this.quaternion.setFromRotationMatrix(nn),
                i && (nn.extractRotation(i.matrixWorld),
                en.setFromRotationMatrix(nn),
                this.quaternion.premultiply(en.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent(hn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(dn)),
                this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1),
                nn.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                nn.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(nn),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i)
                        return i
                }
            }
            getObjectsByProperty(t, e) {
                let n = [];
                this[t] === e && n.push(this);
                for (let i = 0, r = this.children.length; i < r; i++) {
                    const r = this.children[i].getObjectsByProperty(t, e);
                    r.length > 0 && (n = n.concat(r))
                }
                return n
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(sn, t, on),
                t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(sn, an, t),
                t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
                }
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t
                  , n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                i.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            }
                        else
                            r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else
                        i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries)
                      , i = s(t.materials)
                      , r = s(t.textures)
                      , o = s(t.images)
                      , a = s(t.shapes)
                      , l = s(t.skeletons)
                      , c = s(t.animations)
                      , u = s(t.nodes);
                    e.length > 0 && (n.geometries = e),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    o.length > 0 && (n.images = o),
                    a.length > 0 && (n.shapes = a),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c),
                    u.length > 0 && (n.nodes = u)
                }
                return n.object = i,
                n;
                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t) {
                let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.animations = t.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        pn.DEFAULT_UP = new he(0,1,0),
        pn.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        pn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const fn = new he
          , An = new he
          , gn = new he
          , mn = new he
          , vn = new he
          , yn = new he
          , _n = new he
          , En = new he
          , bn = new he
          , xn = new he;
        let wn = !1;
        class Sn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new he
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new he
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new he;
                this.a = t,
                this.b = e,
                this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e),
                fn.subVectors(t, e),
                i.cross(fn);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                fn.subVectors(i, e),
                An.subVectors(n, e),
                gn.subVectors(t, e);
                const s = fn.dot(fn)
                  , o = fn.dot(An)
                  , a = fn.dot(gn)
                  , l = An.dot(An)
                  , c = An.dot(gn)
                  , u = s * l - o * o;
                if (0 === u)
                    return r.set(-2, -1, -1);
                const h = 1 / u
                  , d = (l * a - o * c) * h
                  , p = (s * c - o * a) * h;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, mn),
                mn.x >= 0 && mn.y >= 0 && mn.x + mn.y <= 1
            }
            static getUV(t, e, n, i, r, s, o, a) {
                return !1 === wn && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                wn = !0),
                this.getInterpolation(t, e, n, i, r, s, o, a)
            }
            static getInterpolation(t, e, n, i, r, s, o, a) {
                return this.getBarycoord(t, e, n, i, mn),
                a.setScalar(0),
                a.addScaledVector(r, mn.x),
                a.addScaledVector(s, mn.y),
                a.addScaledVector(o, mn.z),
                a
            }
            static isFrontFacing(t, e, n, i) {
                return fn.subVectors(n, e),
                An.subVectors(t, e),
                fn.cross(An).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[i]),
                this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e),
                this.b.fromBufferAttribute(t, n),
                this.c.fromBufferAttribute(t, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return fn.subVectors(this.c, this.b),
                An.subVectors(this.a, this.b),
                .5 * fn.cross(An).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return Sn.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return Sn.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return !1 === wn && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                wn = !0),
                Sn.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            getInterpolation(t, e, n, i, r) {
                return Sn.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return Sn.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return Sn.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let s, o;
                vn.subVectors(i, n),
                yn.subVectors(r, n),
                En.subVectors(t, n);
                const a = vn.dot(En)
                  , l = yn.dot(En);
                if (a <= 0 && l <= 0)
                    return e.copy(n);
                bn.subVectors(t, i);
                const c = vn.dot(bn)
                  , u = yn.dot(bn);
                if (c >= 0 && u <= c)
                    return e.copy(i);
                const h = a * u - c * l;
                if (h <= 0 && a >= 0 && c <= 0)
                    return s = a / (a - c),
                    e.copy(n).addScaledVector(vn, s);
                xn.subVectors(t, r);
                const d = vn.dot(xn)
                  , p = yn.dot(xn);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * l - a * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return o = l / (l - p),
                    e.copy(n).addScaledVector(yn, o);
                const A = c * p - d * u;
                if (A <= 0 && u - c >= 0 && d - p >= 0)
                    return _n.subVectors(r, i),
                    o = (u - c) / (u - c + (d - p)),
                    e.copy(i).addScaledVector(_n, o);
                const g = 1 / (A + f + h);
                return s = f * g,
                o = h * g,
                e.copy(n).addScaledVector(vn, s).addScaledVector(yn, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let Cn = 0;
        class Mn extends bt {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: Cn++
                }),
                this.uuid = Mt(),
                this.name = "",
                this.type = "Material",
                this.blending = 1,
                this.side = 0,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = 204,
                this.blendDst = 205,
                this.blendEquation = l,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = 3,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = 519,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = gt,
                this.stencilZFail = gt,
                this.stencilZPass = gt,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++,
                this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                0 !== this.side && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                n.depthFunc = this.depthFunc,
                n.depthTest = this.depthTest,
                n.depthWrite = this.depthWrite,
                n.colorWrite = this.colorWrite,
                n.stencilWrite = this.stencilWrite,
                n.stencilWriteMask = this.stencilWriteMask,
                n.stencilFunc = this.stencilFunc,
                n.stencilRef = this.stencilRef,
                n.stencilFuncMask = this.stencilFuncMask,
                n.stencilFail = this.stencilFail,
                n.stencilZFail = this.stencilZFail,
                n.stencilZPass = this.stencilZPass,
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                e) {
                    const e = i(t.textures)
                      , r = i(t.images);
                    e.length > 0 && (n.textures = e),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.alphaHash = t.alphaHash,
                this.alphaToCoverage = t.alphaToCoverage,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.forceSinglePass = t.forceSinglePass,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        const In = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Tn = {
            h: 0,
            s: 0,
            l: 0
        }
          , Bn = {
            h: 0,
            s: 0,
            l: 0
        };
        function Rn(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        class Ln {
            constructor(t, e, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(t, e, n)
            }
            set(t, e, n) {
                if (void 0 === e && void 0 === n) {
                    const e = t;
                    e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
                } else
                    this.setRGB(t, e, n);
                return this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lt;
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                Yt.toWorkingColorSpace(this, e),
                this
            }
            setRGB(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Yt.workingColorSpace;
                return this.r = t,
                this.g = e,
                this.b = n,
                Yt.toWorkingColorSpace(this, i),
                this
            }
            setHSL(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Yt.workingColorSpace;
                if (t = Tt(t, 1),
                e = It(e, 0, 1),
                n = It(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e
                      , r = 2 * n - i;
                    this.r = Rn(r, i, t + 1 / 3),
                    this.g = Rn(r, i, t),
                    this.b = Rn(r, i, t - 1 / 3)
                }
                return Yt.toWorkingColorSpace(this, i),
                this
            }
            setStyle(t) {
                let e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lt;
                function i(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                if (e = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                    let r;
                    const s = e[1]
                      , o = e[2];
                    switch (s) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return i(r[4]),
                            this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, n);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return i(r[4]),
                            this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, n);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
                            return i(r[4]),
                            this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, n);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + t)
                    }
                } else if (e = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const i = e[1]
                      , r = i.length;
                    if (3 === r)
                        return this.setRGB(parseInt(i.charAt(0), 16) / 15, parseInt(i.charAt(1), 16) / 15, parseInt(i.charAt(2), 16) / 15, n);
                    if (6 === r)
                        return this.setHex(parseInt(i, 16), n);
                    console.warn("THREE.Color: Invalid hex color " + t)
                } else if (t && t.length > 0)
                    return this.setColorName(t, n);
                return this
            }
            setColorName(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : lt;
                const n = In[t.toLowerCase()];
                return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copySRGBToLinear(t) {
                return this.r = Kt(t.r),
                this.g = Kt(t.g),
                this.b = Kt(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = Jt(t.r),
                this.g = Jt(t.g),
                this.b = Jt(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt;
                return Yt.fromWorkingColorSpace(Dn.copy(this), t),
                65536 * Math.round(It(255 * Dn.r, 0, 255)) + 256 * Math.round(It(255 * Dn.g, 0, 255)) + Math.round(It(255 * Dn.b, 0, 255))
            }
            getHexString() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt;
                return ("000000" + this.getHex(t).toString(16)).slice(-6)
            }
            getHSL(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Yt.workingColorSpace;
                Yt.fromWorkingColorSpace(Dn.copy(this), e);
                const n = Dn.r
                  , i = Dn.g
                  , r = Dn.b
                  , s = Math.max(n, i, r)
                  , o = Math.min(n, i, r);
                let a, l;
                const c = (o + s) / 2;
                if (o === s)
                    a = 0,
                    l = 0;
                else {
                    const t = s - o;
                    switch (l = c <= .5 ? t / (s + o) : t / (2 - s - o),
                    s) {
                    case n:
                        a = (i - r) / t + (i < r ? 6 : 0);
                        break;
                    case i:
                        a = (r - n) / t + 2;
                        break;
                    case r:
                        a = (n - i) / t + 4
                    }
                    a /= 6
                }
                return t.h = a,
                t.s = l,
                t.l = c,
                t
            }
            getRGB(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Yt.workingColorSpace;
                return Yt.fromWorkingColorSpace(Dn.copy(this), e),
                t.r = Dn.r,
                t.g = Dn.g,
                t.b = Dn.b,
                t
            }
            getStyle() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : lt;
                Yt.fromWorkingColorSpace(Dn.copy(this), t);
                const e = Dn.r
                  , n = Dn.g
                  , i = Dn.b;
                return t !== lt ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`
            }
            offsetHSL(t, e, n) {
                return this.getHSL(Tn),
                this.setHSL(Tn.h + t, Tn.s + e, Tn.l + n)
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                this.g = t.g + (e.g - t.g) * n,
                this.b = t.b + (e.b - t.b) * n,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(Tn),
                t.getHSL(Bn);
                const n = Bt(Tn.h, Bn.h, e)
                  , i = Bt(Tn.s, Bn.s, e)
                  , r = Bt(Tn.l, Bn.l, e);
                return this.setHSL(n, i, r),
                this
            }
            setFromVector3(t) {
                return this.r = t.x,
                this.g = t.y,
                this.b = t.z,
                this
            }
            applyMatrix3(t) {
                const e = this.r
                  , n = this.g
                  , i = this.b
                  , r = t.elements;
                return this.r = r[0] * e + r[3] * n + r[6] * i,
                this.g = r[1] * e + r[4] * n + r[7] * i,
                this.b = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const Dn = new Ln;
        Ln.NAMES = In;
        class Pn extends Mn {
            constructor(t) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new Ln(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = c,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.fog = t.fog,
                this
            }
        }
        const Un = function() {
            const t = new ArrayBuffer(4)
              , e = new Float32Array(t)
              , n = new Uint32Array(t)
              , i = new Uint32Array(512)
              , r = new Uint32Array(512);
            for (let t = 0; t < 256; ++t) {
                const e = t - 127;
                e < -27 ? (i[t] = 0,
                i[256 | t] = 32768,
                r[t] = 24,
                r[256 | t] = 24) : e < -14 ? (i[t] = 1024 >> -e - 14,
                i[256 | t] = 1024 >> -e - 14 | 32768,
                r[t] = -e - 1,
                r[256 | t] = -e - 1) : e <= 15 ? (i[t] = e + 15 << 10,
                i[256 | t] = e + 15 << 10 | 32768,
                r[t] = 13,
                r[256 | t] = 13) : e < 128 ? (i[t] = 31744,
                i[256 | t] = 64512,
                r[t] = 24,
                r[256 | t] = 24) : (i[t] = 31744,
                i[256 | t] = 64512,
                r[t] = 13,
                r[256 | t] = 13)
            }
            const s = new Uint32Array(2048)
              , o = new Uint32Array(64)
              , a = new Uint32Array(64);
            for (let t = 1; t < 1024; ++t) {
                let e = t << 13
                  , n = 0;
                for (; 0 == (8388608 & e); )
                    e <<= 1,
                    n -= 8388608;
                e &= -8388609,
                n += 947912704,
                s[t] = e | n
            }
            for (let t = 1024; t < 2048; ++t)
                s[t] = 939524096 + (t - 1024 << 13);
            for (let t = 1; t < 31; ++t)
                o[t] = t << 23;
            o[31] = 1199570944,
            o[32] = 2147483648;
            for (let t = 33; t < 63; ++t)
                o[t] = 2147483648 + (t - 32 << 23);
            o[63] = 3347054592;
            for (let t = 1; t < 64; ++t)
                32 !== t && (a[t] = 1024);
            return {
                floatView: e,
                uint32View: n,
                baseTable: i,
                shiftTable: r,
                mantissaTable: s,
                exponentTable: o,
                offsetTable: a
            }
        }();
        const On = function(t) {
            Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            t = It(t, -65504, 65504),
            Un.floatView[0] = t;
            const e = Un.uint32View[0]
              , n = e >> 23 & 511;
            return Un.baseTable[n] + ((8388607 & e) >> Un.shiftTable[n])
        }
          , Nn = new he
          , Fn = new Nt;
        class Qn {
            constructor(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (Array.isArray(t))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = n,
                this.usage = mt,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.gpuType = P,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this.gpuType = t.gpuType,
                this
            }
            copyAt(t, e, n) {
                t *= this.itemSize,
                n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t),
                this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        Fn.fromBufferAttribute(this, e),
                        Fn.applyMatrix3(t),
                        this.setXY(e, Fn.x, Fn.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        Nn.fromBufferAttribute(this, e),
                        Nn.applyMatrix3(t),
                        this.setXYZ(e, Nn.x, Nn.y, Nn.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Nn.fromBufferAttribute(this, e),
                    Nn.applyMatrix4(t),
                    this.setXYZ(e, Nn.x, Nn.y, Nn.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Nn.fromBufferAttribute(this, e),
                    Nn.applyNormalMatrix(t),
                    this.setXYZ(e, Nn.x, Nn.y, Nn.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    Nn.fromBufferAttribute(this, e),
                    Nn.transformDirection(t),
                    this.setXYZ(e, Nn.x, Nn.y, Nn.z);
                return this
            }
            set(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(t, e),
                this
            }
            getComponent(t, e) {
                let n = this.array[t * this.itemSize + e];
                return this.normalized && (n = Pt(n, this.array)),
                n
            }
            setComponent(t, e, n) {
                return this.normalized && (n = Ut(n, this.array)),
                this.array[t * this.itemSize + e] = n,
                this
            }
            getX(t) {
                let e = this.array[t * this.itemSize];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            setX(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.array[t * this.itemSize] = e,
                this
            }
            getY(t) {
                let e = this.array[t * this.itemSize + 1];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            setY(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.array[t * this.itemSize + 1] = e,
                this
            }
            getZ(t) {
                let e = this.array[t * this.itemSize + 2];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            setZ(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.array[t * this.itemSize + 2] = e,
                this
            }
            getW(t) {
                let e = this.array[t * this.itemSize + 3];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            setW(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.array[t * this.itemSize + 3] = e,
                this
            }
            setXY(t, e, n) {
                return t *= this.itemSize,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array),
                i = Ut(i, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array),
                i = Ut(i, this.array),
                r = Ut(r, this.array)),
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this.array[t + 3] = r,
                this
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name),
                this.usage !== mt && (t.usage = this.usage),
                0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
                t
            }
        }
        class kn extends Qn {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class Gn extends Qn {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        class Hn extends Qn {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let zn = 0;
        const Vn = new Ge
          , Wn = new pn
          , qn = new he
          , jn = new fe
          , Xn = new fe
          , Yn = new he;
        class Kn extends bt {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: zn++
                }),
                this.uuid = Mt(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new (kt(t) ? Gn : kn)(t,1) : this.index = t,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e,
                this
            }
            deleteAttribute(t) {
                return delete this.attributes[t],
                this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new Ft).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(t) {
                return Vn.makeRotationFromQuaternion(t),
                this.applyMatrix4(Vn),
                this
            }
            rotateX(t) {
                return Vn.makeRotationX(t),
                this.applyMatrix4(Vn),
                this
            }
            rotateY(t) {
                return Vn.makeRotationY(t),
                this.applyMatrix4(Vn),
                this
            }
            rotateZ(t) {
                return Vn.makeRotationZ(t),
                this.applyMatrix4(Vn),
                this
            }
            translate(t, e, n) {
                return Vn.makeTranslation(t, e, n),
                this.applyMatrix4(Vn),
                this
            }
            scale(t, e, n) {
                return Vn.makeScale(t, e, n),
                this.applyMatrix4(Vn),
                this
            }
            lookAt(t) {
                return Wn.lookAt(t),
                Wn.updateMatrix(),
                this.applyMatrix4(Wn.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(qn).negate(),
                this.translate(qn.x, qn.y, qn.z),
                this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Hn(e,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new fe);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new he(-1 / 0,-1 / 0,-1 / 0), new he(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            jn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Yn.addVectors(this.boundingBox.min, jn.min),
                            this.boundingBox.expandByPoint(Yn),
                            Yn.addVectors(this.boundingBox.max, jn.max),
                            this.boundingBox.expandByPoint(Yn)) : (this.boundingBox.expandByPoint(jn.min),
                            this.boundingBox.expandByPoint(jn.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Le);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new he, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (jn.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Xn.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Yn.addVectors(jn.min, Xn.min),
                            jn.expandByPoint(Yn),
                            Yn.addVectors(jn.max, Xn.max),
                            jn.expandByPoint(Yn)) : (jn.expandByPoint(Xn.min),
                            jn.expandByPoint(Xn.max))
                        }
                    jn.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        Yn.fromBufferAttribute(t, e),
                        i = Math.max(i, n.distanceToSquared(Yn));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r]
                              , o = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++)
                                Yn.fromBufferAttribute(s, e),
                                o && (qn.fromBufferAttribute(t, e),
                                Yn.add(qn)),
                                i = Math.max(i, n.distanceToSquared(Yn))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array
                  , i = e.position.array
                  , r = e.normal.array
                  , s = e.uv.array
                  , o = i.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Qn(new Float32Array(4 * o),4));
                const a = this.getAttribute("tangent").array
                  , l = []
                  , c = [];
                for (let t = 0; t < o; t++)
                    l[t] = new he,
                    c[t] = new he;
                const u = new he
                  , h = new he
                  , d = new he
                  , p = new Nt
                  , f = new Nt
                  , A = new Nt
                  , g = new he
                  , m = new he;
                function v(t, e, n) {
                    u.fromArray(i, 3 * t),
                    h.fromArray(i, 3 * e),
                    d.fromArray(i, 3 * n),
                    p.fromArray(s, 2 * t),
                    f.fromArray(s, 2 * e),
                    A.fromArray(s, 2 * n),
                    h.sub(u),
                    d.sub(u),
                    f.sub(p),
                    A.sub(p);
                    const r = 1 / (f.x * A.y - A.x * f.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(A.y).addScaledVector(d, -f.y).multiplyScalar(r),
                    m.copy(d).multiplyScalar(f.x).addScaledVector(h, -A.x).multiplyScalar(r),
                    l[t].add(g),
                    l[e].add(g),
                    l[n].add(g),
                    c[t].add(m),
                    c[e].add(m),
                    c[n].add(m))
                }
                let y = this.groups;
                0 === y.length && (y = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        v(n[t + 0], n[t + 1], n[t + 2])
                }
                const _ = new he
                  , E = new he
                  , b = new he
                  , x = new he;
                function w(t) {
                    b.fromArray(r, 3 * t),
                    x.copy(b);
                    const e = l[t];
                    _.copy(e),
                    _.sub(b.multiplyScalar(b.dot(e))).normalize(),
                    E.crossVectors(x, e);
                    const n = E.dot(c[t]) < 0 ? -1 : 1;
                    a[4 * t] = _.x,
                    a[4 * t + 1] = _.y,
                    a[4 * t + 2] = _.z,
                    a[4 * t + 3] = n
                }
                for (let t = 0, e = y.length; t < e; ++t) {
                    const e = y[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        w(n[t + 0]),
                        w(n[t + 1]),
                        w(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Qn(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new he
                      , r = new he
                      , s = new he
                      , o = new he
                      , a = new he
                      , l = new he
                      , c = new he
                      , u = new he;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0)
                              , p = t.getX(h + 1)
                              , f = t.getX(h + 2);
                            i.fromBufferAttribute(e, d),
                            r.fromBufferAttribute(e, p),
                            s.fromBufferAttribute(e, f),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            o.fromBufferAttribute(n, d),
                            a.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            o.add(c),
                            a.add(c),
                            l.add(c),
                            n.setXYZ(d, o.x, o.y, o.z),
                            n.setXYZ(p, a.x, a.y, a.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let t = 0, o = e.count; t < o; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                            r.fromBufferAttribute(e, t + 1),
                            s.fromBufferAttribute(e, t + 2),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            n.setXYZ(t + 0, c.x, c.y, c.z),
                            n.setXYZ(t + 1, c.x, c.y, c.z),
                            n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    Yn.fromBufferAttribute(t, e),
                    Yn.normalize(),
                    t.setXYZ(e, Yn.x, Yn.y, Yn.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array
                      , i = t.itemSize
                      , r = t.normalized
                      , s = new n.constructor(e.length * i);
                    let o = 0
                      , a = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++)
                            s[a++] = n[o++]
                    }
                    return new Qn(s,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new Kn
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = []
                      , o = r[i];
                    for (let e = 0, i = o.length; e < i; e++) {
                        const i = t(o[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e]
                      , s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s.push(i.toJSON(t.data))
                    }
                    s.length > 0 && (i[e] = s,
                    r = !0)
                }
                r && (t.data.morphAttributes = i,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }),
                t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = []
                      , i = r[t];
                    for (let t = 0, r = i.length; t < r; t++)
                        n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Jn = new Ge
          , $n = new ke
          , Zn = new Le
          , ti = new he
          , ei = new he
          , ni = new he
          , ii = new he
          , ri = new he
          , si = new he
          , oi = new Nt
          , ai = new Nt
          , li = new Nt
          , ci = new he
          , ui = new he
          , hi = new he
          , di = new he
          , pi = new he;
        class fi extends pn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Kn
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pn;
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes
                  , e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
            getVertexPosition(t, e) {
                const n = this.geometry
                  , i = n.attributes.position
                  , r = n.morphAttributes.position
                  , s = n.morphTargetsRelative;
                e.fromBufferAttribute(i, t);
                const o = this.morphTargetInfluences;
                if (r && o) {
                    si.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = o[n]
                          , a = r[n];
                        0 !== i && (ri.fromBufferAttribute(a, t),
                        s ? si.addScaledVector(ri, i) : si.addScaledVector(ri.sub(e), i))
                    }
                    e.add(si)
                }
                return e
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Zn.copy(n.boundingSphere),
                    Zn.applyMatrix4(r),
                    $n.copy(t.ray).recast(t.near),
                    !1 === Zn.containsPoint($n.origin)) {
                        if (null === $n.intersectSphere(Zn, ti))
                            return;
                        if ($n.origin.distanceToSquared(ti) > (t.far - t.near) ** 2)
                            return
                    }
                    Jn.copy(r).invert(),
                    $n.copy(t.ray).applyMatrix4(Jn),
                    null !== n.boundingBox && !1 === $n.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, $n)
                }
            }
            _computeIntersections(t, e, n) {
                let i;
                const r = this.geometry
                  , s = this.material
                  , o = r.index
                  , a = r.attributes.position
                  , l = r.attributes.uv
                  , c = r.attributes.uv1
                  , u = r.attributes.normal
                  , h = r.groups
                  , d = r.drawRange;
                if (null !== o)
                    if (Array.isArray(s))
                        for (let r = 0, a = h.length; r < a; r++) {
                            const a = h[r]
                              , p = s[a.materialIndex];
                            for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3)
                                i = Ai(this, p, t, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = a.materialIndex,
                                e.push(i))
                        }
                    else
                        for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3)
                            i = Ai(this, s, t, n, l, c, u, o.getX(r), o.getX(r + 1), o.getX(r + 2)),
                            i && (i.faceIndex = Math.floor(r / 3),
                            e.push(i));
                else if (void 0 !== a)
                    if (Array.isArray(s))
                        for (let r = 0, o = h.length; r < o; r++) {
                            const o = h[r]
                              , p = s[o.materialIndex];
                            for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3)
                                i = Ai(this, p, t, n, l, c, u, r, r + 1, r + 2),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = o.materialIndex,
                                e.push(i))
                        }
                    else
                        for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3)
                            i = Ai(this, s, t, n, l, c, u, r, r + 1, r + 2),
                            i && (i.faceIndex = Math.floor(r / 3),
                            e.push(i))
            }
        }
        function Ai(t, e, n, i, r, s, o, a, l, c) {
            t.getVertexPosition(a, ei),
            t.getVertexPosition(l, ni),
            t.getVertexPosition(c, ii);
            const u = function(t, e, n, i, r, s, o, a) {
                let l;
                if (l = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 0 === e.side, a),
                null === l)
                    return null;
                pi.copy(a),
                pi.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(pi);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: pi.clone(),
                    object: t
                }
            }(t, e, n, i, ei, ni, ii, di);
            if (u) {
                r && (oi.fromBufferAttribute(r, a),
                ai.fromBufferAttribute(r, l),
                li.fromBufferAttribute(r, c),
                u.uv = Sn.getInterpolation(di, ei, ni, ii, oi, ai, li, new Nt)),
                s && (oi.fromBufferAttribute(s, a),
                ai.fromBufferAttribute(s, l),
                li.fromBufferAttribute(s, c),
                u.uv1 = Sn.getInterpolation(di, ei, ni, ii, oi, ai, li, new Nt),
                u.uv2 = u.uv1),
                o && (ci.fromBufferAttribute(o, a),
                ui.fromBufferAttribute(o, l),
                hi.fromBufferAttribute(o, c),
                u.normal = Sn.getInterpolation(di, ei, ni, ii, ci, ui, hi, new he),
                u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
                const t = {
                    a: a,
                    b: l,
                    c: c,
                    normal: new he,
                    materialIndex: 0
                };
                Sn.getNormal(ei, ni, ii, t.normal),
                u.face = t
            }
            return u
        }
        class gi extends Kn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
                  , r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1
                  , s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i),
                r = Math.floor(r),
                s = Math.floor(s);
                const a = []
                  , l = []
                  , c = []
                  , u = [];
                let h = 0
                  , d = 0;
                function p(t, e, n, i, r, s, p, f, A, g, m) {
                    const v = s / A
                      , y = p / g
                      , _ = s / 2
                      , E = p / 2
                      , b = f / 2
                      , x = A + 1
                      , w = g + 1;
                    let S = 0
                      , C = 0;
                    const M = new he;
                    for (let s = 0; s < w; s++) {
                        const o = s * y - E;
                        for (let a = 0; a < x; a++) {
                            const h = a * v - _;
                            M[t] = h * i,
                            M[e] = o * r,
                            M[n] = b,
                            l.push(M.x, M.y, M.z),
                            M[t] = 0,
                            M[e] = 0,
                            M[n] = f > 0 ? 1 : -1,
                            c.push(M.x, M.y, M.z),
                            u.push(a / A),
                            u.push(1 - s / g),
                            S += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < A; e++) {
                            const n = h + e + x * t
                              , i = h + e + x * (t + 1)
                              , r = h + (e + 1) + x * (t + 1)
                              , s = h + (e + 1) + x * t;
                            a.push(n, i, s),
                            a.push(i, r, s),
                            C += 6
                        }
                    o.addGroup(d, C, m),
                    d += C,
                    h += S
                }
                p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
                p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
                p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
                p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
                p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                this.setIndex(a),
                this.setAttribute("position", new Hn(l,3)),
                this.setAttribute("normal", new Hn(c,3)),
                this.setAttribute("uv", new Hn(u,2))
            }
            copy(t) {
                return super.copy(t),
                this.parameters = Object.assign({}, t.parameters),
                this
            }
            static fromJSON(t) {
                return new gi(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
            }
        }
        function mi(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
        function vi(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = mi(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        function yi(t) {
            return null === t.getRenderTarget() ? t.outputColorSpace : Yt.workingColorSpace
        }
        const _i = {
            clone: mi,
            merge: vi
        };
        class Ei extends Mn {
            constructor(t) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== t && this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.fragmentShader = t.fragmentShader,
                this.vertexShader = t.vertexShader,
                this.uniforms = mi(t.uniforms),
                this.uniformsGroups = function(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++)
                        e.push(t[n].clone());
                    return e
                }(t.uniformsGroups),
                this.defines = Object.assign({}, t.defines),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.fog = t.fog,
                this.lights = t.lights,
                this.clipping = t.clipping,
                this.extensions = Object.assign({}, t.extensions),
                this.glslVersion = t.glslVersion,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion,
                e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader,
                e.lights = this.lights,
                e.clipping = this.clipping;
                const n = {};
                for (const t in this.extensions)
                    !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                e
            }
        }
        class bi extends pn {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Ge,
                this.projectionMatrix = new Ge,
                this.projectionMatrixInverse = new Ge,
                this.coordinateSystem = _t
            }
            copy(t, e) {
                return super.copy(t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this.coordinateSystem = t.coordinateSystem,
                this
            }
            getWorldDirection(t) {
                return super.getWorldDirection(t).negate()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class xi extends bi {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Ct * Math.atan(e),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * St * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * Ct * Math.atan(Math.tan(.5 * St * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, s) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * St * this.fov) / this.zoom
                  , n = 2 * e
                  , i = this.aspect * n
                  , r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth
                      , o = s.fullHeight;
                    r += s.offsetX * i / t,
                    e -= s.offsetY * n / o,
                    i *= s.width / t,
                    n *= s.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        }
        const wi = -90;
        class Si extends pn {
            constructor(t, e, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const i = new xi(wi,1,t,e);
                i.layers = this.layers,
                this.add(i);
                const r = new xi(wi,1,t,e);
                r.layers = this.layers,
                this.add(r);
                const s = new xi(wi,1,t,e);
                s.layers = this.layers,
                this.add(s);
                const o = new xi(wi,1,t,e);
                o.layers = this.layers,
                this.add(o);
                const a = new xi(wi,1,t,e);
                a.layers = this.layers,
                this.add(a);
                const l = new xi(wi,1,t,e);
                l.layers = this.layers,
                this.add(l)
            }
            updateCoordinateSystem() {
                const t = this.coordinateSystem
                  , e = this.children.concat()
                  , [n,i,r,s,o,a] = e;
                for (const t of e)
                    this.remove(t);
                if (t === _t)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    i.up.set(0, 1, 0),
                    i.lookAt(-1, 0, 0),
                    r.up.set(0, 0, -1),
                    r.lookAt(0, 1, 0),
                    s.up.set(0, 0, 1),
                    s.lookAt(0, -1, 0),
                    o.up.set(0, 1, 0),
                    o.lookAt(0, 0, 1),
                    a.up.set(0, 1, 0),
                    a.lookAt(0, 0, -1);
                else {
                    if (t !== Et)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    i.up.set(0, -1, 0),
                    i.lookAt(1, 0, 0),
                    r.up.set(0, 0, 1),
                    r.lookAt(0, 1, 0),
                    s.up.set(0, 0, -1),
                    s.lookAt(0, -1, 0),
                    o.up.set(0, -1, 0),
                    o.lookAt(0, 0, 1),
                    a.up.set(0, -1, 0),
                    a.lookAt(0, 0, -1)
                }
                for (const t of e)
                    this.add(t),
                    t.updateMatrixWorld()
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: i} = this;
                this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem,
                this.updateCoordinateSystem());
                const [r,s,o,a,l,c] = this.children
                  , u = t.getRenderTarget()
                  , h = t.getActiveCubeFace()
                  , d = t.getActiveMipmapLevel()
                  , p = t.xr.enabled;
                t.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                t.setRenderTarget(n, 0, i),
                t.render(e, r),
                t.setRenderTarget(n, 1, i),
                t.render(e, s),
                t.setRenderTarget(n, 2, i),
                t.render(e, o),
                t.setRenderTarget(n, 3, i),
                t.render(e, a),
                t.setRenderTarget(n, 4, i),
                t.render(e, l),
                n.texture.generateMipmaps = f,
                t.setRenderTarget(n, 5, i),
                t.render(e, c),
                t.setRenderTarget(u, h, d),
                t.xr.enabled = p,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class Ci extends re {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : v, n, i, r, s, o, a, l, c),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        class Mi extends ae {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(t, t, e),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: t,
                    height: t,
                    depth: 1
                }
                  , i = [n, n, n, n, n, n];
                void 0 !== e.encoding && (Vt("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
                e.colorSpace = e.encoding === ot ? lt : at),
                this.texture = new Ci(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : I
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.colorSpace = e.colorSpace,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const n = {
                    tEquirect: {
                        value: null
                    }
                }
                  , i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
                  , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                  , s = new gi(5,5,5)
                  , o = new Ei({
                    name: "CubemapFromEquirect",
                    uniforms: mi(n),
                    vertexShader: i,
                    fragmentShader: r,
                    side: 1,
                    blending: 0
                });
                o.uniforms.tEquirect.value = e;
                const a = new fi(s,o)
                  , l = e.minFilter;
                return e.minFilter === B && (e.minFilter = I),
                new Si(1,10,this).update(t, a),
                e.minFilter = l,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    t.setRenderTarget(this, r),
                    t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        const Ii = new he
          , Ti = new he
          , Bi = new Ft;
        class Ri {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new he(1,0,0)
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.isPlane = !0,
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = Ii.subVectors(n, e).cross(Ti.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
            }
            intersectLine(t, e) {
                const n = t.delta(Ii)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || Bi.getNormalMatrix(t)
                  , i = this.coplanarPoint(Ii).applyMatrix4(t)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Li = new Le
          , Di = new he;
        class Pi {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Ri
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ri
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Ri
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Ri
                  , r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new Ri
                  , s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new Ri;
                this.planes = [t, e, n, i, r, s]
            }
            set(t, e, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(t),
                o[1].copy(e),
                o[2].copy(n),
                o[3].copy(i),
                o[4].copy(r),
                o[5].copy(s),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2e3;
                const n = this.planes
                  , i = t.elements
                  , r = i[0]
                  , s = i[1]
                  , o = i[2]
                  , a = i[3]
                  , l = i[4]
                  , c = i[5]
                  , u = i[6]
                  , h = i[7]
                  , d = i[8]
                  , p = i[9]
                  , f = i[10]
                  , A = i[11]
                  , g = i[12]
                  , m = i[13]
                  , v = i[14]
                  , y = i[15];
                if (n[0].setComponents(a - r, h - l, A - d, y - g).normalize(),
                n[1].setComponents(a + r, h + l, A + d, y + g).normalize(),
                n[2].setComponents(a + s, h + c, A + p, y + m).normalize(),
                n[3].setComponents(a - s, h - c, A - p, y - m).normalize(),
                n[4].setComponents(a - o, h - u, A - f, y - v).normalize(),
                e === _t)
                    n[5].setComponents(a + o, h + u, A + f, y + v).normalize();
                else {
                    if (e !== Et)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                    n[5].setComponents(o, u, f, v).normalize()
                }
                return this
            }
            intersectsObject(t) {
                if (void 0 !== t.boundingSphere)
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Li.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
                else {
                    const e = t.geometry;
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Li.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
                }
                return this.intersectsSphere(Li)
            }
            intersectsSprite(t) {
                return Li.center.set(0, 0, 0),
                Li.radius = .7071067811865476,
                Li.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(Li)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , n = t.center
                  , i = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(n) < i)
                        return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (Di.x = i.normal.x > 0 ? t.max.x : t.min.x,
                    Di.y = i.normal.y > 0 ? t.max.y : t.min.y,
                    Di.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint(Di) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function Ui() {
            let t = null
              , e = !1
              , n = null
              , i = null;
            function r(e, s) {
                n(e, s),
                i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function Oi(t, e) {
            const n = e.isWebGL2
              , i = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data),
                    i.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer),
                    i.delete(e))
                },
                update: function(e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void ((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    void 0 === s ? i.set(e, function(e, i) {
                        const r = e.array
                          , s = e.usage
                          , o = t.createBuffer();
                        let a;
                        if (t.bindBuffer(i, o),
                        t.bufferData(i, r, s),
                        e.onUploadCallback(),
                        r instanceof Float32Array)
                            a = t.FLOAT;
                        else if (r instanceof Uint16Array)
                            if (e.isFloat16BufferAttribute) {
                                if (!n)
                                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                a = t.HALF_FLOAT
                            } else
                                a = t.UNSIGNED_SHORT;
                        else if (r instanceof Int16Array)
                            a = t.SHORT;
                        else if (r instanceof Uint32Array)
                            a = t.UNSIGNED_INT;
                        else if (r instanceof Int32Array)
                            a = t.INT;
                        else if (r instanceof Int8Array)
                            a = t.BYTE;
                        else if (r instanceof Uint8Array)
                            a = t.UNSIGNED_BYTE;
                        else {
                            if (!(r instanceof Uint8ClampedArray))
                                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                            a = t.UNSIGNED_BYTE
                        }
                        return {
                            buffer: o,
                            type: a,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (function(e, i, r) {
                        const s = i.array
                          , o = i.updateRange;
                        t.bindBuffer(r, e),
                        -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)),
                        o.count = -1),
                        i.onUploadCallback()
                    }(s.buffer, e, r),
                    s.version = e.version)
                }
            }
        }
        class Ni extends Kn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2
                  , s = e / 2
                  , o = Math.floor(n)
                  , a = Math.floor(i)
                  , l = o + 1
                  , c = a + 1
                  , u = t / o
                  , h = e / a
                  , d = []
                  , p = []
                  , f = []
                  , A = [];
                for (let t = 0; t < c; t++) {
                    const e = t * h - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * u - r;
                        p.push(i, -e, 0),
                        f.push(0, 0, 1),
                        A.push(n / o),
                        A.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + l * t
                          , i = e + l * (t + 1)
                          , r = e + 1 + l * (t + 1)
                          , s = e + 1 + l * t;
                        d.push(n, i, s),
                        d.push(i, r, s)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Hn(p,3)),
                this.setAttribute("normal", new Hn(f,3)),
                this.setAttribute("uv", new Hn(A,2))
            }
            copy(t) {
                return super.copy(t),
                this.parameters = Object.assign({}, t.parameters),
                this
            }
            static fromJSON(t) {
                return new Ni(t.width,t.height,t.widthSegments,t.heightSegments)
            }
        }
        const Fi = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal;\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }
          , Qi = {
            common: {
                diffuse: {
                    value: new Ln(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Ft
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Ft
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new Ft
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new Ft
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new Ft
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new Ft
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new Ft
                },
                normalScale: {
                    value: new Nt(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new Ft
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new Ft
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new Ft
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new Ft
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Ln(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Ln(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Ft
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Ft
                }
            },
            sprite: {
                diffuse: {
                    value: new Ln(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Nt(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Ft
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Ft
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , ki = {
            basic: {
                uniforms: vi([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.fog]),
                vertexShader: Fi.meshbasic_vert,
                fragmentShader: Fi.meshbasic_frag
            },
            lambert: {
                uniforms: vi([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.emissivemap, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.fog, Qi.lights, {
                    emissive: {
                        value: new Ln(0)
                    }
                }]),
                vertexShader: Fi.meshlambert_vert,
                fragmentShader: Fi.meshlambert_frag
            },
            phong: {
                uniforms: vi([Qi.common, Qi.specularmap, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.emissivemap, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.fog, Qi.lights, {
                    emissive: {
                        value: new Ln(0)
                    },
                    specular: {
                        value: new Ln(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Fi.meshphong_vert,
                fragmentShader: Fi.meshphong_frag
            },
            standard: {
                uniforms: vi([Qi.common, Qi.envmap, Qi.aomap, Qi.lightmap, Qi.emissivemap, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.roughnessmap, Qi.metalnessmap, Qi.fog, Qi.lights, {
                    emissive: {
                        value: new Ln(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Fi.meshphysical_vert,
                fragmentShader: Fi.meshphysical_frag
            },
            toon: {
                uniforms: vi([Qi.common, Qi.aomap, Qi.lightmap, Qi.emissivemap, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.gradientmap, Qi.fog, Qi.lights, {
                    emissive: {
                        value: new Ln(0)
                    }
                }]),
                vertexShader: Fi.meshtoon_vert,
                fragmentShader: Fi.meshtoon_frag
            },
            matcap: {
                uniforms: vi([Qi.common, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, Qi.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Fi.meshmatcap_vert,
                fragmentShader: Fi.meshmatcap_frag
            },
            points: {
                uniforms: vi([Qi.points, Qi.fog]),
                vertexShader: Fi.points_vert,
                fragmentShader: Fi.points_frag
            },
            dashed: {
                uniforms: vi([Qi.common, Qi.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Fi.linedashed_vert,
                fragmentShader: Fi.linedashed_frag
            },
            depth: {
                uniforms: vi([Qi.common, Qi.displacementmap]),
                vertexShader: Fi.depth_vert,
                fragmentShader: Fi.depth_frag
            },
            normal: {
                uniforms: vi([Qi.common, Qi.bumpmap, Qi.normalmap, Qi.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Fi.meshnormal_vert,
                fragmentShader: Fi.meshnormal_frag
            },
            sprite: {
                uniforms: vi([Qi.sprite, Qi.fog]),
                vertexShader: Fi.sprite_vert,
                fragmentShader: Fi.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Ft
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: Fi.background_vert,
                fragmentShader: Fi.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: Fi.backgroundCube_vert,
                fragmentShader: Fi.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Fi.cube_vert,
                fragmentShader: Fi.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Fi.equirect_vert,
                fragmentShader: Fi.equirect_frag
            },
            distanceRGBA: {
                uniforms: vi([Qi.common, Qi.displacementmap, {
                    referencePosition: {
                        value: new he
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Fi.distanceRGBA_vert,
                fragmentShader: Fi.distanceRGBA_frag
            },
            shadow: {
                uniforms: vi([Qi.lights, Qi.fog, {
                    color: {
                        value: new Ln(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Fi.shadow_vert,
                fragmentShader: Fi.shadow_frag
            }
        };
        ki.physical = {
            uniforms: vi([ki.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Ft
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Ft
                },
                clearcoatNormalScale: {
                    value: new Nt(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Ft
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Ft
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Ft
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Ln(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Ft
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Ft
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Ft
                },
                transmissionSamplerSize: {
                    value: new Nt
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Ft
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Ln(0)
                },
                specularColor: {
                    value: new Ln(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Ft
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Ft
                },
                anisotropyVector: {
                    value: new Nt
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Ft
                }
            }]),
            vertexShader: Fi.meshphysical_vert,
            fragmentShader: Fi.meshphysical_frag
        };
        const Gi = {
            r: 0,
            b: 0,
            g: 0
        };
        function Hi(t, e, n, i, r, s, o) {
            const a = new Ln(0);
            let l, c, u = !0 === s ? 0 : 1, h = null, d = 0, p = null;
            function f(e, n) {
                e.getRGB(Gi, yi(t)),
                i.buffers.color.setClear(Gi.r, Gi.g, Gi.b, n, o)
            }
            return {
                getClearColor: function() {
                    return a
                },
                setClearColor: function(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    a.set(t),
                    u = e,
                    f(a, u)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(t) {
                    u = t,
                    f(a, u)
                },
                render: function(s, A) {
                    let g = !1
                      , m = !0 === A.isScene ? A.background : null;
                    m && m.isTexture && (m = (A.backgroundBlurriness > 0 ? n : e).get(m)),
                    null === m ? f(a, u) : m && m.isColor && (f(m, 1),
                    g = !0);
                    const v = t.xr.getEnvironmentBlendMode();
                    "additive" === v ? i.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === v && i.buffers.color.setClear(0, 0, 0, 0, o),
                    (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    m && (m.isCubeTexture || m.mapping === E) ? (void 0 === c && (c = new fi(new gi(1,1,1),new Ei({
                        name: "BackgroundCubeMaterial",
                        uniforms: mi(ki.backgroundCube.uniforms),
                        vertexShader: ki.backgroundCube.vertexShader,
                        fragmentShader: ki.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    c.geometry.deleteAttribute("normal"),
                    c.geometry.deleteAttribute("uv"),
                    c.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    r.update(c)),
                    c.material.uniforms.envMap.value = m,
                    c.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1,
                    c.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness,
                    c.material.uniforms.backgroundIntensity.value = A.backgroundIntensity,
                    c.material.toneMapped = Yt.getTransfer(m.colorSpace) !== pt,
                    h === m && d === m.version && p === t.toneMapping || (c.material.needsUpdate = !0,
                    h = m,
                    d = m.version,
                    p = t.toneMapping),
                    c.layers.enableAll(),
                    s.unshift(c, c.geometry, c.material, 0, 0, null)) : m && m.isTexture && (void 0 === l && (l = new fi(new Ni(2,2),new Ei({
                        name: "BackgroundMaterial",
                        uniforms: mi(ki.background.uniforms),
                        vertexShader: ki.background.vertexShader,
                        fragmentShader: ki.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    r.update(l)),
                    l.material.uniforms.t2D.value = m,
                    l.material.uniforms.backgroundIntensity.value = A.backgroundIntensity,
                    l.material.toneMapped = Yt.getTransfer(m.colorSpace) !== pt,
                    !0 === m.matrixAutoUpdate && m.updateMatrix(),
                    l.material.uniforms.uvTransform.value.copy(m.matrix),
                    h === m && d === m.version && p === t.toneMapping || (l.material.needsUpdate = !0,
                    h = m,
                    d = m.version,
                    p = t.toneMapping),
                    l.layers.enableAll(),
                    s.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }
        function zi(t, e, n, i) {
            const r = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , o = i.isWebGL2 || null !== s
              , a = {}
              , l = p(null);
            let c = l
              , u = !1;
            function h(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }
            function d(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }
            function p(t) {
                const e = []
                  , n = []
                  , i = [];
                for (let t = 0; t < r; t++)
                    e[t] = 0,
                    n[t] = 0,
                    i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function f() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function A(t) {
                g(t, 0)
            }
            function g(n, r) {
                const s = c.newAttributes
                  , o = c.enabledAttributes
                  , a = c.attributeDivisors;
                s[n] = 1,
                0 === o[n] && (t.enableVertexAttribArray(n),
                o[n] = 1),
                a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                a[n] = r)
            }
            function m() {
                const e = c.newAttributes
                  , n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== e[i] && (t.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function v(e, n, i, r, s, o, a) {
                !0 === a ? t.vertexAttribIPointer(e, n, i, s, o) : t.vertexAttribPointer(e, n, i, r, s, o)
            }
            function y() {
                _(),
                u = !0,
                c !== l && (c = l,
                h(c.object))
            }
            function _() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(r, l, d, y, _) {
                    let E = !1;
                    if (o) {
                        const e = function(e, n, r) {
                            const o = !0 === r.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {},
                            a[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let u = c[o];
                            return void 0 === u && (u = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                            c[o] = u),
                            u
                        }(y, d, l);
                        c !== e && (c = e,
                        h(c.object)),
                        E = function(t, e, n, i) {
                            const r = c.attributes
                              , s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a)
                                if (a[e].location >= 0) {
                                    const n = r[e];
                                    let i = s[e];
                                    if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix),
                                    "instanceColor" === e && t.instanceColor && (i = t.instanceColor)),
                                    void 0 === n)
                                        return !0;
                                    if (n.attribute !== i)
                                        return !0;
                                    if (i && n.data !== i.data)
                                        return !0;
                                    o++
                                }
                            return c.attributesNum !== o || c.index !== i
                        }(r, y, d, _),
                        E && function(t, e, n, i) {
                            const r = {}
                              , s = e.attributes;
                            let o = 0;
                            const a = n.getAttributes();
                            for (const e in a)
                                if (a[e].location >= 0) {
                                    let n = s[e];
                                    void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix),
                                    "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                    const i = {};
                                    i.attribute = n,
                                    n && n.data && (i.data = n.data),
                                    r[e] = i,
                                    o++
                                }
                            c.attributes = r,
                            c.attributesNum = o,
                            c.index = i
                        }(r, y, d, _)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === y.id && c.program === d.id && c.wireframe === t || (c.geometry = y.id,
                        c.program = d.id,
                        c.wireframe = t,
                        E = !0)
                    }
                    null !== _ && n.update(_, t.ELEMENT_ARRAY_BUFFER),
                    (E || u) && (u = !1,
                    function(r, s, o, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                            return;
                        f();
                        const l = a.attributes
                          , c = o.getAttributes()
                          , u = s.defaultAttributeValues;
                        for (const e in c) {
                            const s = c[e];
                            if (s.location >= 0) {
                                let o = l[e];
                                if (void 0 === o && ("instanceMatrix" === e && r.instanceMatrix && (o = r.instanceMatrix),
                                "instanceColor" === e && r.instanceColor && (o = r.instanceColor)),
                                void 0 !== o) {
                                    const e = o.normalized
                                      , l = o.itemSize
                                      , c = n.get(o);
                                    if (void 0 === c)
                                        continue;
                                    const u = c.buffer
                                      , h = c.type
                                      , d = c.bytesPerElement
                                      , p = !0 === i.isWebGL2 && (h === t.INT || h === t.UNSIGNED_INT || 1013 === o.gpuType);
                                    if (o.isInterleavedBufferAttribute) {
                                        const n = o.data
                                          , i = n.stride
                                          , c = o.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < s.locationSize; t++)
                                                g(s.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < s.locationSize; t++)
                                                A(s.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < s.locationSize; t++)
                                            v(s.location + t, l / s.locationSize, h, e, i * d, (c + l / s.locationSize * t) * d, p)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let t = 0; t < s.locationSize; t++)
                                                g(s.location + t, o.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else
                                            for (let t = 0; t < s.locationSize; t++)
                                                A(s.location + t);
                                        t.bindBuffer(t.ARRAY_BUFFER, u);
                                        for (let t = 0; t < s.locationSize; t++)
                                            v(s.location + t, l / s.locationSize, h, e, l * d, l / s.locationSize * t * d, p)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(s.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(s.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(s.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(s.location, n)
                                        }
                                }
                            }
                        }
                        m()
                    }(r, l, d, y),
                    null !== _ && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(_).buffer))
                },
                reset: y,
                resetDefaultState: _,
                dispose: function() {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n)
                                d(n[t].object),
                                delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === a[t.id])
                        return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            d(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id])
                            continue;
                        const i = n[t.id];
                        for (const t in i)
                            d(i[t].object),
                            delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: f,
                enableAttribute: A,
                disableUnusedAttributes: m
            }
        }
        function Vi(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.render = function(e, i) {
                t.drawArrays(s, e, i),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, o, a) {
                if (0 === a)
                    return;
                let l, c;
                if (r)
                    l = t,
                    c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](s, i, o, a),
                n.update(o, s, a)
            }
        }
        function Wi(t, e, n) {
            let i;
            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
            let o = void 0 !== n.precision ? n.precision : "highp";
            const a = r(o);
            a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."),
            o = a);
            const l = s || e.has("WEBGL_draw_buffers")
              , c = !0 === n.logarithmicDepthBuffer
              , u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
              , h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , d = t.getParameter(t.MAX_TEXTURE_SIZE)
              , p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
              , f = t.getParameter(t.MAX_VERTEX_ATTRIBS)
              , A = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
              , g = t.getParameter(t.MAX_VARYING_VECTORS)
              , m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
              , v = h > 0
              , y = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== i)
                        return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: A,
                maxVaryings: g,
                maxFragmentUniforms: m,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: v && y,
                maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
            }
        }
        function qi(t) {
            const e = this;
            let n = null
              , i = 0
              , r = !1
              , s = !1;
            const o = new Ri
              , a = new Ft
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const e = i + 4 * s
                          , r = n.matrixWorldInverse;
                        a.getNormalMatrix(r),
                        (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e,
                        n += 4)
                            o.copy(t[e]).applyMatrix4(r, a),
                            o.normal.toArray(c, n),
                            c[n + 3] = o.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return e.numPlanes = s,
                e.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e) {
                const n = 0 !== t.length || e || 0 !== i || r;
                return r = e,
                i = t.length,
                n
            }
            ,
            this.beginShadows = function() {
                s = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                s = !1
            }
            ,
            this.setGlobalState = function(t, e) {
                n = c(t, e, 0)
            }
            ,
            this.setState = function(o, a, u) {
                const h = o.clippingPlanes
                  , d = o.clipIntersection
                  , p = o.clipShadows
                  , f = t.get(o);
                if (!r || null === h || 0 === h.length || s && !p)
                    s ? c(null) : (l.value !== n && (l.value = n,
                    l.needsUpdate = i > 0),
                    e.numPlanes = i,
                    e.numIntersection = 0);
                else {
                    const t = s ? 0 : i
                      , e = 4 * t;
                    let r = f.clippingState || null;
                    l.value = r,
                    r = c(h, a, e, u);
                    for (let t = 0; t !== e; ++t)
                        r[t] = n[t];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        function ji(t) {
            let e = new WeakMap;
            function n(t, e) {
                return e === _ ? t.mapping = v : 304 === e && (t.mapping = y),
                t
            }
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const s = r.mapping;
                        if (s === _ || 304 === s) {
                            if (e.has(r))
                                return n(e.get(r).texture, r.mapping);
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const o = new Mi(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r),
                                    e.set(r, o),
                                    r.addEventListener("dispose", i),
                                    n(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        class Xi extends bi {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1
                  , r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1
                  , s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - t
                  , s = n + t
                  , o = i + e
                  , a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                    s = r + t * this.view.width,
                    o -= e * this.view.offsetY,
                    a = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        const Yi = [.125, .215, .35, .446, .526, .582]
          , Ki = new Xi
          , Ji = new Ln;
        let $i = null;
        const Zi = (1 + Math.sqrt(5)) / 2
          , tr = 1 / Zi
          , er = [new he(1,1,1), new he(-1,1,1), new he(1,1,-1), new he(-1,1,-1), new he(0,Zi,tr), new he(0,Zi,-tr), new he(tr,0,Zi), new he(-tr,0,Zi), new he(Zi,tr,0), new he(-Zi,tr,0)];
        class nr {
            constructor(t) {
                this._renderer = t,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                $i = this._renderer.getRenderTarget(),
                this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0,
                this._sceneToCubeUV(t, n, i, r),
                e > 0 && this._blur(r, 0, 0, e),
                this._applyPMREM(r),
                this._cleanup(r),
                r
            }
            fromEquirectangular(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(t, e)
            }
            fromCubemap(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = or(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = sr(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(t) {
                this._lodMax = Math.floor(Math.log2(t)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let t = 0; t < this._lodPlanes.length; t++)
                    this._lodPlanes[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget($i),
                t.scissorTest = !1,
                rr(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                t.mapping === v || t.mapping === y ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4),
                $i = this._renderer.getRenderTarget();
                const n = e || this._allocateTargets();
                return this._textureToCubeUV(t, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const t = 3 * Math.max(this._cubeSize, 112)
                  , e = 4 * this._cubeSize
                  , n = {
                    magFilter: I,
                    minFilter: I,
                    generateMipmaps: !1,
                    type: U,
                    format: N,
                    colorSpace: ct,
                    depthBuffer: !1
                }
                  , i = ir(t, e, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = ir(t, e, n);
                    const {_lodMax: i} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(t) {
                        const e = []
                          , n = []
                          , i = [];
                        let r = t;
                        const s = t - 4 + 1 + Yi.length;
                        for (let o = 0; o < s; o++) {
                            const s = Math.pow(2, r);
                            n.push(s);
                            let a = 1 / s;
                            o > t - 4 ? a = Yi[o - t + 4 - 1] : 0 === o && (a = 0),
                            i.push(a);
                            const l = 1 / (s - 2)
                              , c = -l
                              , u = 1 + l
                              , h = [c, c, u, c, u, u, c, c, u, u, c, u]
                              , d = 6
                              , p = 6
                              , f = 3
                              , A = 2
                              , g = 1
                              , m = new Float32Array(f * p * d)
                              , v = new Float32Array(A * p * d)
                              , y = new Float32Array(g * p * d);
                            for (let t = 0; t < d; t++) {
                                const e = t % 3 * 2 / 3 - 1
                                  , n = t > 2 ? 0 : -1
                                  , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                m.set(i, f * p * t),
                                v.set(h, A * p * t);
                                const r = [t, t, t, t, t, t];
                                y.set(r, g * p * t)
                            }
                            const _ = new Kn;
                            _.setAttribute("position", new Qn(m,f)),
                            _.setAttribute("uv", new Qn(v,A)),
                            _.setAttribute("faceIndex", new Qn(y,g)),
                            e.push(_),
                            r > 4 && r--
                        }
                        return {
                            lodPlanes: e,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)),
                    this._blurMaterial = function(t, e, n) {
                        const i = new Float32Array(20)
                          , r = new he(0,1,0);
                        return new Ei({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / e,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${t}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(i, t, e)
                }
                return i
            }
            _compileMaterial(t) {
                const e = new fi(this._lodPlanes[0],t);
                this._renderer.compile(e, Ki)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = new xi(90,1,e,n)
                  , s = [1, -1, 1, 1, 1, 1]
                  , o = [1, 1, 1, -1, -1, -1]
                  , a = this._renderer
                  , l = a.autoClear
                  , c = a.toneMapping;
                a.getClearColor(Ji),
                a.toneMapping = d,
                a.autoClear = !1;
                const u = new Pn({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , h = new fi(new gi,u);
                let p = !1;
                const f = t.background;
                f ? f.isColor && (u.color.copy(f),
                t.background = null,
                p = !0) : (u.color.copy(Ji),
                p = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (r.up.set(0, s[e], 0),
                    r.lookAt(o[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]),
                    r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0),
                    r.lookAt(0, 0, o[e]));
                    const l = this._cubeSize;
                    rr(i, n * l, e > 2 ? l : 0, l, l),
                    a.setRenderTarget(i),
                    p && a.render(h, r),
                    a.render(t, r)
                }
                h.geometry.dispose(),
                h.material.dispose(),
                a.toneMapping = c,
                a.autoClear = l,
                t.background = f
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer
                  , i = t.mapping === v || t.mapping === y;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = or()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = sr());
                const r = i ? this._cubemapMaterial : this._equirectMaterial
                  , s = new fi(this._lodPlanes[0],r);
                r.uniforms.envMap.value = t;
                const o = this._cubeSize;
                rr(e, 0, 0, 3 * o, 2 * o),
                n.setRenderTarget(e),
                n.render(s, Ki)
            }
            _applyPMREM(t) {
                const e = this._renderer
                  , n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < this._lodPlanes.length; e++) {
                    const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1])
                      , i = er[(e - 1) % er.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(t, s, e, n, i, "latitudinal", r),
                this._halfBlur(s, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, s, o) {
                const a = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new fi(this._lodPlanes[i],l)
                  , u = l.uniforms
                  , h = this._sizeLods[n] - 1
                  , d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39
                  , p = r / d
                  , f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const A = [];
                let g = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / p
                      , n = Math.exp(-e * e / 2);
                    A.push(n),
                    0 === t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < A.length; t++)
                    A[t] = A[t] / g;
                u.envMap.value = t.texture,
                u.samples.value = f,
                u.weights.value = A,
                u.latitudinal.value = "latitudinal" === s,
                o && (u.poleAxis.value = o);
                const {_lodMax: m} = this;
                u.dTheta.value = d,
                u.mipInt.value = m - n;
                const v = this._sizeLods[i];
                rr(e, 3 * v * (i > m - 4 ? i - m + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
                a.setRenderTarget(e),
                a.render(c, Ki)
            }
        }
        function ir(t, e, n) {
            const i = new ae(t,e,n);
            return i.texture.mapping = E,
            i.texture.name = "PMREM.cubeUv",
            i.scissorTest = !0,
            i
        }
        function rr(t, e, n, i, r) {
            t.viewport.set(e, n, i, r),
            t.scissor.set(e, n, i, r)
        }
        function sr() {
            return new Ei({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function or() {
            return new Ei({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function ar(t) {
            let e = new WeakMap
              , n = null;
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping
                          , o = s === _ || 304 === s
                          , a = s === v || s === y;
                        if (o || a) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = e.get(r);
                                return null === n && (n = new nr(t)),
                                i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i),
                                e.set(r, i),
                                i.texture
                            }
                            if (e.has(r))
                                return e.get(r).texture;
                            {
                                const s = r.image;
                                if (o && s && s.height > 0 || a && s && function(t) {
                                    let e = 0;
                                    for (let n = 0; n < 6; n++)
                                        void 0 !== t[n] && e++;
                                    return 6 === e
                                }(s)) {
                                    null === n && (n = new nr(t));
                                    const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, s),
                                    r.addEventListener("dispose", i),
                                    s.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function lr(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        function cr(t, e, n, i) {
            const r = {}
              , s = new WeakMap;
            function o(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes)
                    e.remove(a.attributes[t]);
                for (const t in a.morphAttributes) {
                    const n = a.morphAttributes[t];
                    for (let t = 0, i = n.length; t < i; t++)
                        e.remove(n[t])
                }
                a.removeEventListener("dispose", o),
                delete r[a.id];
                const l = s.get(a);
                l && (e.remove(l),
                s.delete(a)),
                i.releaseStatesOfGeometry(a),
                !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
                n.memory.geometries--
            }
            function a(t) {
                const n = []
                  , i = t.index
                  , r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0]
                          , r = t[e + 1]
                          , s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const t = r.array;
                        o = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0
                              , i = e + 1
                              , r = e + 2;
                            n.push(t, i, i, r, r, t)
                        }
                    }
                }
                const a = new (kt(n) ? Gn : kn)(n,1);
                a.version = o;
                const l = s.get(t);
                l && e.remove(l),
                s.set(t, a)
            }
            return {
                get: function(t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", o),
                    r[e.id] = !0,
                    n.memory.geometries++),
                    e
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i)
                        e.update(i[n], t.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++)
                            e.update(i[n], t.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else
                        a(t);
                    return s.get(t)
                }
            }
        }
        function ur(t, e, n, i) {
            const r = i.isWebGL2;
            let s, o, a;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.setIndex = function(t) {
                o = t.type,
                a = t.bytesPerElement
            }
            ,
            this.render = function(e, i) {
                t.drawElements(s, i, o, e * a),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, l, c) {
                if (0 === c)
                    return;
                let u, h;
                if (r)
                    u = t,
                    h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"),
                h = "drawElementsInstancedANGLE",
                null === u)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](s, l, o, i * a, c),
                n.update(l, s, c)
            }
        }
        function hr(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.calls = 0,
                    e.triangles = 0,
                    e.points = 0,
                    e.lines = 0
                },
                update: function(n, i, r) {
                    switch (e.calls++,
                    i) {
                    case t.TRIANGLES:
                        e.triangles += r * (n / 3);
                        break;
                    case t.LINES:
                        e.lines += r * (n / 2);
                        break;
                    case t.LINE_STRIP:
                        e.lines += r * (n - 1);
                        break;
                    case t.LINE_LOOP:
                        e.lines += r * n;
                        break;
                    case t.POINTS:
                        e.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }
        function dr(t, e) {
            return t[0] - e[0]
        }
        function pr(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function fr(t, e, n) {
            const i = {}
              , r = new Float32Array(8)
              , s = new WeakMap
              , o = new se
              , a = [];
            for (let t = 0; t < 8; t++)
                a[t] = [t, 0];
            return {
                update: function(l, c, u) {
                    const h = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                          , r = void 0 !== i ? i.length : 0;
                        let a = s.get(c);
                        if (void 0 === a || a.count !== r) {
                            void 0 !== a && a.texture.dispose();
                            const t = void 0 !== c.morphAttributes.position
                              , n = void 0 !== c.morphAttributes.normal
                              , i = void 0 !== c.morphAttributes.color
                              , l = c.morphAttributes.position || []
                              , u = c.morphAttributes.normal || []
                              , h = c.morphAttributes.color || [];
                            let d = 0;
                            !0 === t && (d = 1),
                            !0 === n && (d = 2),
                            !0 === i && (d = 3);
                            let p = c.attributes.position.count * d
                              , f = 1;
                            p > e.maxTextureSize && (f = Math.ceil(p / e.maxTextureSize),
                            p = e.maxTextureSize);
                            const A = new Float32Array(p * f * 4 * r)
                              , g = new le(A,p,f,r);
                            g.type = P,
                            g.needsUpdate = !0;
                            const m = 4 * d;
                            for (let e = 0; e < r; e++) {
                                const r = l[e]
                                  , s = u[e]
                                  , a = h[e]
                                  , c = p * f * 4 * e;
                                for (let e = 0; e < r.count; e++) {
                                    const l = e * m;
                                    !0 === t && (o.fromBufferAttribute(r, e),
                                    A[c + l + 0] = o.x,
                                    A[c + l + 1] = o.y,
                                    A[c + l + 2] = o.z,
                                    A[c + l + 3] = 0),
                                    !0 === n && (o.fromBufferAttribute(s, e),
                                    A[c + l + 4] = o.x,
                                    A[c + l + 5] = o.y,
                                    A[c + l + 6] = o.z,
                                    A[c + l + 7] = 0),
                                    !0 === i && (o.fromBufferAttribute(a, e),
                                    A[c + l + 8] = o.x,
                                    A[c + l + 9] = o.y,
                                    A[c + l + 10] = o.z,
                                    A[c + l + 11] = 4 === a.itemSize ? o.w : 1)
                                }
                            }
                            a = {
                                count: r,
                                texture: g,
                                size: new Nt(p,f)
                            },
                            s.set(c, a),
                            c.addEventListener("dispose", (function t() {
                                g.dispose(),
                                s.delete(c),
                                c.removeEventListener("dispose", t)
                            }
                            ))
                        }
                        let l = 0;
                        for (let t = 0; t < h.length; t++)
                            l += h[t];
                        const d = c.morphTargetsRelative ? 1 : 1 - l;
                        u.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
                        u.getUniforms().setValue(t, "morphTargetInfluences", h),
                        u.getUniforms().setValue(t, "morphTargetsTexture", a.texture, n),
                        u.getUniforms().setValue(t, "morphTargetsTextureSize", a.size)
                    } else {
                        const e = void 0 === h ? 0 : h.length;
                        let n = i[c.id];
                        if (void 0 === n || n.length !== e) {
                            n = [];
                            for (let t = 0; t < e; t++)
                                n[t] = [t, 0];
                            i[c.id] = n
                        }
                        for (let t = 0; t < e; t++) {
                            const e = n[t];
                            e[0] = t,
                            e[1] = h[t]
                        }
                        n.sort(pr);
                        for (let t = 0; t < 8; t++)
                            t < e && n[t][1] ? (a[t][0] = n[t][0],
                            a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER,
                            a[t][1] = 0);
                        a.sort(dr);
                        const s = c.morphAttributes.position
                          , o = c.morphAttributes.normal;
                        let l = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = a[t]
                              , n = e[0]
                              , i = e[1];
                            n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + t) !== s[n] && c.setAttribute("morphTarget" + t, s[n]),
                            o && c.getAttribute("morphNormal" + t) !== o[n] && c.setAttribute("morphNormal" + t, o[n]),
                            r[t] = i,
                            l += i) : (s && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t),
                            o && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t),
                            r[t] = 0)
                        }
                        const d = c.morphTargetsRelative ? 1 : 1 - l;
                        u.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
                        u.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }
        function Ar(t, e, n, i) {
            let r = new WeakMap;
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(o) {
                    const a = i.render.frame
                      , l = o.geometry
                      , c = e.get(o, l);
                    if (r.get(c) !== a && (e.update(c),
                    r.set(c, a)),
                    o.isInstancedMesh && (!1 === o.hasEventListener("dispose", s) && o.addEventListener("dispose", s),
                    r.get(o) !== a && (n.update(o.instanceMatrix, t.ARRAY_BUFFER),
                    null !== o.instanceColor && n.update(o.instanceColor, t.ARRAY_BUFFER),
                    r.set(o, a))),
                    o.isSkinnedMesh) {
                        const t = o.skeleton;
                        r.get(t) !== a && (t.update(),
                        r.set(t, a))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        const gr = new re
          , mr = new le
          , vr = new ce
          , yr = new Ci
          , _r = []
          , Er = []
          , br = new Float32Array(16)
          , xr = new Float32Array(9)
          , wr = new Float32Array(4);
        function Sr(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0)
                return t;
            const r = e * n;
            let s = _r[r];
            if (void 0 === s && (s = new Float32Array(r),
            _r[r] = s),
            0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i)
                    r += n,
                    t[i].toArray(s, r)
            }
            return s
        }
        function Cr(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function Mr(t, e) {
            for (let n = 0, i = e.length; n < i; n++)
                t[n] = e[n]
        }
        function Ir(t, e) {
            let n = Er[e];
            void 0 === n && (n = new Int32Array(e),
            Er[e] = n);
            for (let i = 0; i !== e; ++i)
                n[i] = t.allocateTextureUnit();
            return n
        }
        function Tr(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
            n[0] = e)
        }
        function Br(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (Cr(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                Mr(n, e)
            }
        }
        function Rr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                n[0] = e.r,
                n[1] = e.g,
                n[2] = e.b);
            else {
                if (Cr(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                Mr(n, e)
            }
        }
        function Lr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (Cr(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                Mr(n, e)
            }
        }
        function Dr(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Cr(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                Mr(n, e)
            } else {
                if (Cr(n, i))
                    return;
                wr.set(i),
                t.uniformMatrix2fv(this.addr, !1, wr),
                Mr(n, i)
            }
        }
        function Pr(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Cr(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                Mr(n, e)
            } else {
                if (Cr(n, i))
                    return;
                xr.set(i),
                t.uniformMatrix3fv(this.addr, !1, xr),
                Mr(n, i)
            }
        }
        function Ur(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (Cr(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                Mr(n, e)
            } else {
                if (Cr(n, i))
                    return;
                br.set(i),
                t.uniformMatrix4fv(this.addr, !1, br),
                Mr(n, i)
            }
        }
        function Or(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
            n[0] = e)
        }
        function Nr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (Cr(n, e))
                    return;
                t.uniform2iv(this.addr, e),
                Mr(n, e)
            }
        }
        function Fr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else {
                if (Cr(n, e))
                    return;
                t.uniform3iv(this.addr, e),
                Mr(n, e)
            }
        }
        function Qr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (Cr(n, e))
                    return;
                t.uniform4iv(this.addr, e),
                Mr(n, e)
            }
        }
        function kr(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
            n[0] = e)
        }
        function Gr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (Cr(n, e))
                    return;
                t.uniform2uiv(this.addr, e),
                Mr(n, e)
            }
        }
        function Hr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else {
                if (Cr(n, e))
                    return;
                t.uniform3uiv(this.addr, e),
                Mr(n, e)
            }
        }
        function zr(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (Cr(n, e))
                    return;
                t.uniform4uiv(this.addr, e),
                Mr(n, e)
            }
        }
        function Vr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2D(e || gr, r)
        }
        function Wr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(e || vr, r)
        }
        function qr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTextureCube(e || yr, r)
        }
        function jr(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(e || mr, r)
        }
        function Xr(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function Yr(t, e) {
            const n = Sr(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function Kr(t, e) {
            const n = Sr(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function Jr(t, e) {
            const n = Sr(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function $r(t, e) {
            const n = Sr(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function Zr(t, e) {
            const n = Sr(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function ts(t, e) {
            const n = Sr(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function es(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function ns(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function is(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function rs(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function ss(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function os(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function as(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function ls(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function cs(t, e, n) {
            const i = this.cache
              , r = e.length
              , s = Ir(n, r);
            Cr(i, s) || (t.uniform1iv(this.addr, s),
            Mr(i, s));
            for (let t = 0; t !== r; ++t)
                n.setTexture2D(e[t] || gr, s[t])
        }
        function us(t, e, n) {
            const i = this.cache
              , r = e.length
              , s = Ir(n, r);
            Cr(i, s) || (t.uniform1iv(this.addr, s),
            Mr(i, s));
            for (let t = 0; t !== r; ++t)
                n.setTexture3D(e[t] || vr, s[t])
        }
        function hs(t, e, n) {
            const i = this.cache
              , r = e.length
              , s = Ir(n, r);
            Cr(i, s) || (t.uniform1iv(this.addr, s),
            Mr(i, s));
            for (let t = 0; t !== r; ++t)
                n.setTextureCube(e[t] || yr, s[t])
        }
        function ds(t, e, n) {
            const i = this.cache
              , r = e.length
              , s = Ir(n, r);
            Cr(i, s) || (t.uniform1iv(this.addr, s),
            Mr(i, s));
            for (let t = 0; t !== r; ++t)
                n.setTexture2DArray(e[t] || mr, s[t])
        }
        class ps {
            constructor(t, e, n) {
                this.id = t,
                this.addr = n,
                this.cache = [],
                this.setValue = function(t) {
                    switch (t) {
                    case 5126:
                        return Tr;
                    case 35664:
                        return Br;
                    case 35665:
                        return Rr;
                    case 35666:
                        return Lr;
                    case 35674:
                        return Dr;
                    case 35675:
                        return Pr;
                    case 35676:
                        return Ur;
                    case 5124:
                    case 35670:
                        return Or;
                    case 35667:
                    case 35671:
                        return Nr;
                    case 35668:
                    case 35672:
                        return Fr;
                    case 35669:
                    case 35673:
                        return Qr;
                    case 5125:
                        return kr;
                    case 36294:
                        return Gr;
                    case 36295:
                        return Hr;
                    case 36296:
                        return zr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Vr;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Wr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return qr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return jr
                    }
                }(e.type)
            }
        }
        class fs {
            constructor(t, e, n) {
                this.id = t,
                this.addr = n,
                this.cache = [],
                this.size = e.size,
                this.setValue = function(t) {
                    switch (t) {
                    case 5126:
                        return Xr;
                    case 35664:
                        return Yr;
                    case 35665:
                        return Kr;
                    case 35666:
                        return Jr;
                    case 35674:
                        return $r;
                    case 35675:
                        return Zr;
                    case 35676:
                        return ts;
                    case 5124:
                    case 35670:
                        return es;
                    case 35667:
                    case 35671:
                        return ns;
                    case 35668:
                    case 35672:
                        return is;
                    case 35669:
                    case 35673:
                        return rs;
                    case 5125:
                        return ss;
                    case 36294:
                        return os;
                    case 36295:
                        return as;
                    case 36296:
                        return ls;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return cs;
                    case 35679:
                    case 36299:
                    case 36307:
                        return us;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return hs;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return ds
                    }
                }(e.type)
            }
        }
        class As {
            constructor(t) {
                this.id = t,
                this.seq = [],
                this.map = {}
            }
            setValue(t, e, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(t, e[s.id], n)
                }
            }
        }
        const gs = /(\w+)(\])?(\[|\.)?/g;
        function ms(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function vs(t, e, n) {
            const i = t.name
              , r = i.length;
            for (gs.lastIndex = 0; ; ) {
                const s = gs.exec(i)
                  , o = gs.lastIndex;
                let a = s[1];
                const l = "]" === s[2]
                  , c = s[3];
                if (l && (a |= 0),
                void 0 === c || "[" === c && o + 2 === r) {
                    ms(n, void 0 === c ? new ps(a,t,e) : new fs(a,t,e));
                    break
                }
                {
                    let t = n.map[a];
                    void 0 === t && (t = new As(a),
                    ms(n, t)),
                    n = t
                }
            }
        }
        class ys {
            constructor(t, e) {
                this.seq = [],
                this.map = {};
                const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    vs(n, t.getUniformLocation(e, n.name), this)
                }
            }
            setValue(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }
            setOptional(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }
            static upload(t, e, n, i) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r]
                      , o = n[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                }
            }
            static seqWithValue(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            }
        }
        function _s(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n),
            t.compileShader(i),
            i
        }
        let Es = 0;
        function bs(t, e, n) {
            const i = t.getShaderParameter(e, t.COMPILE_STATUS)
              , r = t.getShaderInfoLog(e).trim();
            if (i && "" === r)
                return "";
            const s = /ERROR: 0:(\d+)/.exec(r);
            if (s) {
                const i = parseInt(s[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(t, e) {
                    const n = t.split("\n")
                      , i = []
                      , r = Math.max(e - 6, 0)
                      , s = Math.min(e + 6, n.length);
                    for (let t = r; t < s; t++) {
                        const r = t + 1;
                        i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`)
                    }
                    return i.join("\n")
                }(t.getShaderSource(e), i)
            }
            return r
        }
        function xs(t, e) {
            const n = function(t) {
                const e = Yt.getPrimaries(Yt.workingColorSpace)
                  , n = Yt.getPrimaries(t);
                let i;
                switch (e === n ? i = "" : e === At && n === ft ? i = "LinearDisplayP3ToLinearSRGB" : e === ft && n === At && (i = "LinearSRGBToLinearDisplayP3"),
                t) {
                case ct:
                case ht:
                    return [i, "LinearTransferOETF"];
                case lt:
                case ut:
                    return [i, "sRGBTransferOETF"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", t),
                    [i, "LinearTransferOETF"]
                }
            }(e);
            return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }
        function ws(t, e) {
            let n;
            switch (e) {
            case p:
                n = "Linear";
                break;
            case f:
                n = "Reinhard";
                break;
            case A:
                n = "OptimizedCineon";
                break;
            case g:
                n = "ACESFilmic";
                break;
            case m:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function Ss(t) {
            return "" !== t
        }
        function Cs(t, e) {
            const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function Ms(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const Is = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Ts(t) {
            return t.replace(Is, Rs)
        }
        const Bs = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
        function Rs(t, e) {
            let n = Fi[e];
            if (void 0 === n) {
                const t = Bs.get(e);
                if (void 0 === t)
                    throw new Error("Can not resolve #include <" + e + ">");
                n = Fi[t],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
            }
            return Ts(n)
        }
        const Ls = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Ds(t) {
            return t.replace(Ls, Ps)
        }
        function Ps(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }
        function Us(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function Os(t, e, n, i) {
            const r = t.getContext()
              , l = n.defines;
            let p = n.vertexShader
              , f = n.fragmentShader;
            const A = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return t.shadowMapType === s ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === o ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === a && (e = "SHADOWMAP_TYPE_VSM"),
                e
            }(n)
              , g = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case v:
                    case y:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case E:
                        e = "ENVMAP_TYPE_CUBE_UV"
                    }
                return e
            }(n)
              , m = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                return t.envMap && t.envMapMode === y && (e = "ENVMAP_MODE_REFRACTION"),
                e
            }(n)
              , _ = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap)
                    switch (t.combine) {
                    case c:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case u:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case h:
                        e = "ENVMAP_BLENDING_ADD"
                    }
                return e
            }(n)
              , b = function(t) {
                const e = t.envMapCubeUVHeight;
                if (null === e)
                    return null;
                const n = Math.log2(e) - 2
                  , i = 1 / e;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n)
              , x = n.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ss).join("\n")
            }(n)
              , w = function(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(l)
              , S = r.createProgram();
            let C, M, I = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (C = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, w].filter(Ss).join("\n"),
            C.length > 0 && (C += "\n"),
            M = [x, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, w].filter(Ss).join("\n"),
            M.length > 0 && (M += "\n")) : (C = [Us(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, w, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + A : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ss).join("\n"),
            M = [x, Us(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, w, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + g : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + _ : "", b ? "#define CUBEUV_TEXEL_WIDTH " + b.texelWidth : "", b ? "#define CUBEUV_TEXEL_HEIGHT " + b.texelHeight : "", b ? "#define CUBEUV_MAX_MIP " + b.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + A : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== d ? "#define TONE_MAPPING" : "", n.toneMapping !== d ? Fi.tonemapping_pars_fragment : "", n.toneMapping !== d ? ws("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Fi.colorspace_pars_fragment, xs("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ss).join("\n")),
            p = Ts(p),
            p = Cs(p, n),
            p = Ms(p, n),
            f = Ts(f),
            f = Cs(f, n),
            f = Ms(f, n),
            p = Ds(p),
            f = Ds(f),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (I = "#version 300 es\n",
            C = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + C,
            M = ["#define varying in", n.glslVersion === vt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === vt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + M);
            const T = I + C + p
              , B = I + M + f
              , R = _s(r, r.VERTEX_SHADER, T)
              , L = _s(r, r.FRAGMENT_SHADER, B);
            if (r.attachShader(S, R),
            r.attachShader(S, L),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(S, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(S, 0, "position"),
            r.linkProgram(S),
            t.debug.checkShaderErrors) {
                const e = r.getProgramInfoLog(S).trim()
                  , n = r.getShaderInfoLog(R).trim()
                  , i = r.getShaderInfoLog(L).trim();
                let s = !0
                  , o = !0;
                if (!1 === r.getProgramParameter(S, r.LINK_STATUS))
                    if (s = !1,
                    "function" == typeof t.debug.onShaderError)
                        t.debug.onShaderError(r, S, R, L);
                    else {
                        const t = bs(r, R, "vertex")
                          , n = bs(r, L, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(S, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                    }
                else
                    "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== n && "" !== i || (o = !1);
                o && (this.diagnostics = {
                    runnable: s,
                    programLog: e,
                    vertexShader: {
                        log: n,
                        prefix: C
                    },
                    fragmentShader: {
                        log: i,
                        prefix: M
                    }
                })
            }
            let D, P;
            return r.deleteShader(R),
            r.deleteShader(L),
            this.getUniforms = function() {
                return void 0 === D && (D = new ys(r,S)),
                D
            }
            ,
            this.getAttributes = function() {
                return void 0 === P && (P = function(t, e) {
                    const n = {}
                      , i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r)
                          , s = i.name;
                        let o = 1;
                        i.type === t.FLOAT_MAT2 && (o = 2),
                        i.type === t.FLOAT_MAT3 && (o = 3),
                        i.type === t.FLOAT_MAT4 && (o = 4),
                        n[s] = {
                            type: i.type,
                            location: t.getAttribLocation(e, s),
                            locationSize: o
                        }
                    }
                    return n
                }(r, S)),
                P
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(S),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = Es++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = S,
            this.vertexShader = R,
            this.fragmentShader = L,
            this
        }
        let Ns = 0;
        class Fs {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader
                  , n = t.fragmentShader
                  , i = this._getShaderStage(e)
                  , r = this._getShaderStage(n)
                  , s = this._getShaderCacheForMaterial(t);
                return !1 === s.has(i) && (s.add(i),
                i.usedTimes++),
                !1 === s.has(r) && (s.add(r),
                r.usedTimes++),
                this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e)
                    t.usedTimes--,
                    0 === t.usedTimes && this.shaderCache.delete(t.code);
                return this.materialCache.delete(t),
                this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                let n = e.get(t);
                return void 0 === n && (n = new Set,
                e.set(t, n)),
                n
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                let n = e.get(t);
                return void 0 === n && (n = new Qs(t),
                e.set(t, n)),
                n
            }
        }
        class Qs {
            constructor(t) {
                this.id = Ns++,
                this.code = t,
                this.usedTimes = 0
            }
        }
        function ks(t, e, n, i, r, s, o) {
            const a = new $e
              , l = new Fs
              , c = []
              , u = r.isWebGL2
              , h = r.logarithmicDepthBuffer
              , p = r.vertexTextures;
            let f = r.precision;
            const A = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function g(t) {
                return 0 === t ? "uv" : `uv${t}`
            }
            return {
                getParameters: function(s, a, c, m, v) {
                    const y = m.fog
                      , _ = v.geometry
                      , b = s.isMeshStandardMaterial ? m.environment : null
                      , x = (s.isMeshStandardMaterial ? n : e).get(s.envMap || b)
                      , w = x && x.mapping === E ? x.image.height : null
                      , S = A[s.type];
                    null !== s.precision && (f = r.getMaxPrecision(s.precision),
                    f !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", f, "instead."));
                    const C = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color
                      , M = void 0 !== C ? C.length : 0;
                    let I, T, B, R, L = 0;
                    if (void 0 !== _.morphAttributes.position && (L = 1),
                    void 0 !== _.morphAttributes.normal && (L = 2),
                    void 0 !== _.morphAttributes.color && (L = 3),
                    S) {
                        const t = ki[S];
                        I = t.vertexShader,
                        T = t.fragmentShader
                    } else
                        I = s.vertexShader,
                        T = s.fragmentShader,
                        l.update(s),
                        B = l.getVertexShaderID(s),
                        R = l.getFragmentShaderID(s);
                    const D = t.getRenderTarget()
                      , P = !0 === v.isInstancedMesh
                      , U = !!s.map
                      , O = !!s.matcap
                      , N = !!x
                      , F = !!s.aoMap
                      , Q = !!s.lightMap
                      , k = !!s.bumpMap
                      , G = !!s.normalMap
                      , H = !!s.displacementMap
                      , z = !!s.emissiveMap
                      , V = !!s.metalnessMap
                      , W = !!s.roughnessMap
                      , q = s.anisotropy > 0
                      , j = s.clearcoat > 0
                      , X = s.iridescence > 0
                      , Y = s.sheen > 0
                      , K = s.transmission > 0
                      , J = q && !!s.anisotropyMap
                      , $ = j && !!s.clearcoatMap
                      , Z = j && !!s.clearcoatNormalMap
                      , tt = j && !!s.clearcoatRoughnessMap
                      , et = X && !!s.iridescenceMap
                      , nt = X && !!s.iridescenceThicknessMap
                      , it = Y && !!s.sheenColorMap
                      , rt = Y && !!s.sheenRoughnessMap
                      , st = !!s.specularMap
                      , ot = !!s.specularColorMap
                      , at = !!s.specularIntensityMap
                      , lt = K && !!s.transmissionMap
                      , ut = K && !!s.thicknessMap
                      , ht = !!s.gradientMap
                      , dt = !!s.alphaMap
                      , ft = s.alphaTest > 0
                      , At = !!s.alphaHash
                      , gt = !!s.extensions
                      , mt = !!_.attributes.uv1
                      , vt = !!_.attributes.uv2
                      , yt = !!_.attributes.uv3;
                    let _t = d;
                    return s.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (_t = t.toneMapping)),
                    {
                        isWebGL2: u,
                        shaderID: S,
                        shaderType: s.type,
                        shaderName: s.name,
                        vertexShader: I,
                        fragmentShader: T,
                        defines: s.defines,
                        customVertexShaderID: B,
                        customFragmentShaderID: R,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: f,
                        instancing: P,
                        instancingColor: P && null !== v.instanceColor,
                        supportsVertexTextures: p,
                        outputColorSpace: null === D ? t.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : ct,
                        map: U,
                        matcap: O,
                        envMap: N,
                        envMapMode: N && x.mapping,
                        envMapCubeUVHeight: w,
                        aoMap: F,
                        lightMap: Q,
                        bumpMap: k,
                        normalMap: G,
                        displacementMap: p && H,
                        emissiveMap: z,
                        normalMapObjectSpace: G && 1 === s.normalMapType,
                        normalMapTangentSpace: G && 0 === s.normalMapType,
                        metalnessMap: V,
                        roughnessMap: W,
                        anisotropy: q,
                        anisotropyMap: J,
                        clearcoat: j,
                        clearcoatMap: $,
                        clearcoatNormalMap: Z,
                        clearcoatRoughnessMap: tt,
                        iridescence: X,
                        iridescenceMap: et,
                        iridescenceThicknessMap: nt,
                        sheen: Y,
                        sheenColorMap: it,
                        sheenRoughnessMap: rt,
                        specularMap: st,
                        specularColorMap: ot,
                        specularIntensityMap: at,
                        transmission: K,
                        transmissionMap: lt,
                        thicknessMap: ut,
                        gradientMap: ht,
                        opaque: !1 === s.transparent && 1 === s.blending,
                        alphaMap: dt,
                        alphaTest: ft,
                        alphaHash: At,
                        combine: s.combine,
                        mapUv: U && g(s.map.channel),
                        aoMapUv: F && g(s.aoMap.channel),
                        lightMapUv: Q && g(s.lightMap.channel),
                        bumpMapUv: k && g(s.bumpMap.channel),
                        normalMapUv: G && g(s.normalMap.channel),
                        displacementMapUv: H && g(s.displacementMap.channel),
                        emissiveMapUv: z && g(s.emissiveMap.channel),
                        metalnessMapUv: V && g(s.metalnessMap.channel),
                        roughnessMapUv: W && g(s.roughnessMap.channel),
                        anisotropyMapUv: J && g(s.anisotropyMap.channel),
                        clearcoatMapUv: $ && g(s.clearcoatMap.channel),
                        clearcoatNormalMapUv: Z && g(s.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: tt && g(s.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: et && g(s.iridescenceMap.channel),
                        iridescenceThicknessMapUv: nt && g(s.iridescenceThicknessMap.channel),
                        sheenColorMapUv: it && g(s.sheenColorMap.channel),
                        sheenRoughnessMapUv: rt && g(s.sheenRoughnessMap.channel),
                        specularMapUv: st && g(s.specularMap.channel),
                        specularColorMapUv: ot && g(s.specularColorMap.channel),
                        specularIntensityMapUv: at && g(s.specularIntensityMap.channel),
                        transmissionMapUv: lt && g(s.transmissionMap.channel),
                        thicknessMapUv: ut && g(s.thicknessMap.channel),
                        alphaMapUv: dt && g(s.alphaMap.channel),
                        vertexTangents: !!_.attributes.tangent && (G || q),
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize,
                        vertexUv1s: mt,
                        vertexUv2s: vt,
                        vertexUv3s: yt,
                        pointsUvs: !0 === v.isPoints && !!_.attributes.uv && (U || dt),
                        fog: !!y,
                        useFog: !0 === s.fog,
                        fogExp2: y && y.isFogExp2,
                        flatShading: !0 === s.flatShading,
                        sizeAttenuation: !0 === s.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === v.isSkinnedMesh,
                        morphTargets: void 0 !== _.morphAttributes.position,
                        morphNormals: void 0 !== _.morphAttributes.normal,
                        morphColors: void 0 !== _.morphAttributes.color,
                        morphTargetsCount: M,
                        morphTextureStride: L,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numSpotLightMaps: a.spotLightMap.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                        numLightProbes: a.numLightProbes,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: _t,
                        useLegacyLights: t._useLegacyLights,
                        decodeVideoTexture: U && !0 === s.map.isVideoTexture && Yt.getTransfer(s.map.colorSpace) === pt,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: 2 === s.side,
                        flipSided: 1 === s.side,
                        useDepthPacking: s.depthPacking >= 0,
                        depthPacking: s.depthPacking || 0,
                        index0AttributeName: s.index0AttributeName,
                        extensionDerivatives: gt && !0 === s.extensions.derivatives,
                        extensionFragDepth: gt && !0 === s.extensions.fragDepth,
                        extensionDrawBuffers: gt && !0 === s.extensions.drawBuffers,
                        extensionShaderTextureLOD: gt && !0 === s.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID),
                    n.push(e.customFragmentShaderID)),
                    void 0 !== e.defines)
                        for (const t in e.defines)
                            n.push(t),
                            n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (function(t, e) {
                        t.push(e.precision),
                        t.push(e.outputColorSpace),
                        t.push(e.envMapMode),
                        t.push(e.envMapCubeUVHeight),
                        t.push(e.mapUv),
                        t.push(e.alphaMapUv),
                        t.push(e.lightMapUv),
                        t.push(e.aoMapUv),
                        t.push(e.bumpMapUv),
                        t.push(e.normalMapUv),
                        t.push(e.displacementMapUv),
                        t.push(e.emissiveMapUv),
                        t.push(e.metalnessMapUv),
                        t.push(e.roughnessMapUv),
                        t.push(e.anisotropyMapUv),
                        t.push(e.clearcoatMapUv),
                        t.push(e.clearcoatNormalMapUv),
                        t.push(e.clearcoatRoughnessMapUv),
                        t.push(e.iridescenceMapUv),
                        t.push(e.iridescenceThicknessMapUv),
                        t.push(e.sheenColorMapUv),
                        t.push(e.sheenRoughnessMapUv),
                        t.push(e.specularMapUv),
                        t.push(e.specularColorMapUv),
                        t.push(e.specularIntensityMapUv),
                        t.push(e.transmissionMapUv),
                        t.push(e.thicknessMapUv),
                        t.push(e.combine),
                        t.push(e.fogExp2),
                        t.push(e.sizeAttenuation),
                        t.push(e.morphTargetsCount),
                        t.push(e.morphAttributeCount),
                        t.push(e.numDirLights),
                        t.push(e.numPointLights),
                        t.push(e.numSpotLights),
                        t.push(e.numSpotLightMaps),
                        t.push(e.numHemiLights),
                        t.push(e.numRectAreaLights),
                        t.push(e.numDirLightShadows),
                        t.push(e.numPointLightShadows),
                        t.push(e.numSpotLightShadows),
                        t.push(e.numSpotLightShadowsWithMaps),
                        t.push(e.numLightProbes),
                        t.push(e.shadowMapType),
                        t.push(e.toneMapping),
                        t.push(e.numClippingPlanes),
                        t.push(e.numClipIntersection),
                        t.push(e.depthPacking)
                    }(n, e),
                    function(t, e) {
                        a.disableAll(),
                        e.isWebGL2 && a.enable(0),
                        e.supportsVertexTextures && a.enable(1),
                        e.instancing && a.enable(2),
                        e.instancingColor && a.enable(3),
                        e.matcap && a.enable(4),
                        e.envMap && a.enable(5),
                        e.normalMapObjectSpace && a.enable(6),
                        e.normalMapTangentSpace && a.enable(7),
                        e.clearcoat && a.enable(8),
                        e.iridescence && a.enable(9),
                        e.alphaTest && a.enable(10),
                        e.vertexColors && a.enable(11),
                        e.vertexAlphas && a.enable(12),
                        e.vertexUv1s && a.enable(13),
                        e.vertexUv2s && a.enable(14),
                        e.vertexUv3s && a.enable(15),
                        e.vertexTangents && a.enable(16),
                        e.anisotropy && a.enable(17),
                        t.push(a.mask),
                        a.disableAll(),
                        e.fog && a.enable(0),
                        e.useFog && a.enable(1),
                        e.flatShading && a.enable(2),
                        e.logarithmicDepthBuffer && a.enable(3),
                        e.skinning && a.enable(4),
                        e.morphTargets && a.enable(5),
                        e.morphNormals && a.enable(6),
                        e.morphColors && a.enable(7),
                        e.premultipliedAlpha && a.enable(8),
                        e.shadowMapEnabled && a.enable(9),
                        e.useLegacyLights && a.enable(10),
                        e.doubleSided && a.enable(11),
                        e.flipSided && a.enable(12),
                        e.useDepthPacking && a.enable(13),
                        e.dithering && a.enable(14),
                        e.transmission && a.enable(15),
                        e.sheen && a.enable(16),
                        e.opaque && a.enable(17),
                        e.pointsUvs && a.enable(18),
                        e.decodeVideoTexture && a.enable(19),
                        t.push(a.mask)
                    }(n, e),
                    n.push(t.outputColorSpace)),
                    n.push(e.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(t) {
                    const e = A[t.type];
                    let n;
                    if (e) {
                        const t = ki[e];
                        n = _i.clone(t.uniforms)
                    } else
                        n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let i;
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        if (e.cacheKey === n) {
                            i = e,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Os(t,n,e,s),
                    c.push(i)),
                    i
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = c.indexOf(t);
                        c[e] = c[c.length - 1],
                        c.pop(),
                        t.destroy()
                    }
                },
                releaseShaderCache: function(t) {
                    l.remove(t)
                },
                programs: c,
                dispose: function() {
                    l.dispose()
                }
            }
        }
        function Gs() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {},
                    t.set(e, n)),
                    n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Hs(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function zs(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function Vs() {
            const t = [];
            let e = 0;
            const n = []
              , i = []
              , r = [];
            function s(n, i, r, s, o, a) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: a
                },
                t[e] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = i,
                l.material = r,
                l.groupOrder = s,
                l.renderOrder = n.renderOrder,
                l.z = o,
                l.group = a),
                e++,
                l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    e = 0,
                    n.length = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.push(u) : !0 === o.transparent ? r.push(u) : n.push(u)
                },
                unshift: function(t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.unshift(u) : !0 === o.transparent ? r.unshift(u) : n.unshift(u)
                },
                finish: function() {
                    for (let n = e, i = t.length; n < i; n++) {
                        const e = t[n];
                        if (null === e.id)
                            break;
                        e.id = null,
                        e.object = null,
                        e.geometry = null,
                        e.material = null,
                        e.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || Hs),
                    i.length > 1 && i.sort(e || zs),
                    r.length > 1 && r.sort(e || zs)
                }
            }
        }
        function Ws() {
            let t = new WeakMap;
            return {
                get: function(e, n) {
                    const i = t.get(e);
                    let r;
                    return void 0 === i ? (r = new Vs,
                    t.set(e, [r])) : n >= i.length ? (r = new Vs,
                    i.push(r)) : r = i[n],
                    r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function qs() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new he,
                            color: new Ln
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new he,
                            direction: new he,
                            color: new Ln,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new he,
                            color: new Ln,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new he,
                            skyColor: new Ln,
                            groundColor: new Ln
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Ln,
                            position: new he,
                            halfWidth: new he,
                            halfHeight: new he
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        let js = 0;
        function Xs(t, e) {
            return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
        }
        function Ys(t, e) {
            const n = new qs
              , i = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        let n;
                        switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Nt
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Nt,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return t[e.id] = n,
                        n
                    }
                }
            }()
              , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let t = 0; t < 9; t++)
                r.probe.push(new he);
            const s = new he
              , o = new Ge
              , a = new Ge;
            return {
                setup: function(s, o) {
                    let a = 0
                      , l = 0
                      , c = 0;
                    for (let t = 0; t < 9; t++)
                        r.probe[t].set(0, 0, 0);
                    let u = 0
                      , h = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , A = 0
                      , g = 0
                      , m = 0
                      , v = 0
                      , y = 0
                      , _ = 0;
                    s.sort(Xs);
                    const E = !0 === o ? Math.PI : 1;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t]
                          , o = e.color
                          , b = e.intensity
                          , x = e.distance
                          , w = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight)
                            a += o.r * b * E,
                            l += o.g * b * E,
                            c += o.b * b * E;
                        else if (e.isLightProbe) {
                            for (let t = 0; t < 9; t++)
                                r.probe[t].addScaledVector(e.sh.coefficients[t], b);
                            _++
                        } else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * E),
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.directionalShadow[u] = n,
                                r.directionalShadowMap[u] = w,
                                r.directionalShadowMatrix[u] = e.shadow.matrix,
                                A++
                            }
                            r.directional[u] = t,
                            u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(o).multiplyScalar(b * E),
                            t.distance = x,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            r.spot[d] = t;
                            const s = e.shadow;
                            if (e.map && (r.spotLightMap[v] = e.map,
                            v++,
                            s.updateMatrices(e),
                            e.castShadow && y++),
                            r.spotLightMatrix[d] = s.matrix,
                            e.castShadow) {
                                const t = i.get(e);
                                t.shadowBias = s.bias,
                                t.shadowNormalBias = s.normalBias,
                                t.shadowRadius = s.radius,
                                t.shadowMapSize = s.mapSize,
                                r.spotShadow[d] = t,
                                r.spotShadowMap[d] = w,
                                m++
                            }
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(o).multiplyScalar(b),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            r.rectArea[p] = t,
                            p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * E),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                n.shadowCameraNear = t.camera.near,
                                n.shadowCameraFar = t.camera.far,
                                r.pointShadow[h] = n,
                                r.pointShadowMap[h] = w,
                                r.pointShadowMatrix[h] = e.shadow.matrix,
                                g++
                            }
                            r.point[h] = t,
                            h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(b * E),
                            t.groundColor.copy(e.groundColor).multiplyScalar(b * E),
                            r.hemi[f] = t,
                            f++
                        }
                    }
                    p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Qi.LTC_FLOAT_1,
                    r.rectAreaLTC2 = Qi.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Qi.LTC_HALF_1,
                    r.rectAreaLTC2 = Qi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = a,
                    r.ambient[1] = l,
                    r.ambient[2] = c;
                    const b = r.hash;
                    b.directionalLength === u && b.pointLength === h && b.spotLength === d && b.rectAreaLength === p && b.hemiLength === f && b.numDirectionalShadows === A && b.numPointShadows === g && b.numSpotShadows === m && b.numSpotMaps === v && b.numLightProbes === _ || (r.directional.length = u,
                    r.spot.length = d,
                    r.rectArea.length = p,
                    r.point.length = h,
                    r.hemi.length = f,
                    r.directionalShadow.length = A,
                    r.directionalShadowMap.length = A,
                    r.pointShadow.length = g,
                    r.pointShadowMap.length = g,
                    r.spotShadow.length = m,
                    r.spotShadowMap.length = m,
                    r.directionalShadowMatrix.length = A,
                    r.pointShadowMatrix.length = g,
                    r.spotLightMatrix.length = m + v - y,
                    r.spotLightMap.length = v,
                    r.numSpotLightShadowsWithMaps = y,
                    r.numLightProbes = _,
                    b.directionalLength = u,
                    b.pointLength = h,
                    b.spotLength = d,
                    b.rectAreaLength = p,
                    b.hemiLength = f,
                    b.numDirectionalShadows = A,
                    b.numPointShadows = g,
                    b.numSpotShadows = m,
                    b.numSpotMaps = v,
                    b.numLightProbes = _,
                    r.version = js++)
                },
                setupView: function(t, e) {
                    let n = 0
                      , i = 0
                      , l = 0
                      , c = 0
                      , u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(h),
                            n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(h),
                            l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            a.identity(),
                            o.copy(d.matrixWorld),
                            o.premultiply(h),
                            a.extractRotation(o),
                            t.halfWidth.set(.5 * d.width, 0, 0),
                            t.halfHeight.set(0, .5 * d.height, 0),
                            t.halfWidth.applyMatrix4(a),
                            t.halfHeight.applyMatrix4(a),
                            c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            t.direction.transformDirection(h),
                            u++
                        }
                    }
                },
                state: r
            }
        }
        function Ks(t, e) {
            const n = new Ys(t,e)
              , i = []
              , r = [];
            return {
                init: function() {
                    i.length = 0,
                    r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function(t) {
                    n.setup(i, t)
                },
                setupLightsView: function(t) {
                    n.setupView(i, t)
                },
                pushLight: function(t) {
                    i.push(t)
                },
                pushShadow: function(t) {
                    r.push(t)
                }
            }
        }
        function Js(t, e) {
            let n = new WeakMap;
            return {
                get: function(i) {
                    let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    const s = n.get(i);
                    let o;
                    return void 0 === s ? (o = new Ks(t,e),
                    n.set(i, [o])) : r >= s.length ? (o = new Ks(t,e),
                    s.push(o)) : o = s[r],
                    o
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class $s extends Mn {
            constructor(t) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        class Zs extends Mn {
            constructor(t) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        function to(t, e, n) {
            let i = new Pi;
            const r = new Nt
              , o = new Nt
              , l = new se
              , c = new $s({
                depthPacking: 3201
            })
              , u = new Zs
              , h = {}
              , d = n.maxTextureSize
              , p = {
                0: 1,
                1: 0,
                2: 2
            }
              , f = new Ei({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Nt
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , A = f.clone();
            A.defines.HORIZONTAL_PASS = 1;
            const g = new Kn;
            g.setAttribute("position", new Qn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const m = new fi(g,f)
              , v = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = s;
            let y = this.type;
            function _(n, i) {
                const s = e.update(m);
                f.defines.VSM_SAMPLES !== n.blurSamples && (f.defines.VSM_SAMPLES = n.blurSamples,
                A.defines.VSM_SAMPLES = n.blurSamples,
                f.needsUpdate = !0,
                A.needsUpdate = !0),
                null === n.mapPass && (n.mapPass = new ae(r.x,r.y)),
                f.uniforms.shadow_pass.value = n.map.texture,
                f.uniforms.resolution.value = n.mapSize,
                f.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.mapPass),
                t.clear(),
                t.renderBufferDirect(i, null, s, f, m, null),
                A.uniforms.shadow_pass.value = n.mapPass.texture,
                A.uniforms.resolution.value = n.mapSize,
                A.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.map),
                t.clear(),
                t.renderBufferDirect(i, null, s, A, m, null)
            }
            function E(e, n, i, r) {
                let s = null;
                const o = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (void 0 !== o)
                    s = o;
                else if (s = !0 === i.isPointLight ? u : c,
                t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const t = s.uuid
                      , e = n.uuid;
                    let i = h[t];
                    void 0 === i && (i = {},
                    h[t] = i);
                    let r = i[e];
                    void 0 === r && (r = s.clone(),
                    i[e] = r),
                    s = r
                }
                return s.visible = n.visible,
                s.wireframe = n.wireframe,
                s.side = r === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : p[n.side],
                s.alphaMap = n.alphaMap,
                s.alphaTest = n.alphaTest,
                s.map = n.map,
                s.clipShadows = n.clipShadows,
                s.clippingPlanes = n.clippingPlanes,
                s.clipIntersection = n.clipIntersection,
                s.displacementMap = n.displacementMap,
                s.displacementScale = n.displacementScale,
                s.displacementBias = n.displacementBias,
                s.wireframeLinewidth = n.wireframeLinewidth,
                s.linewidth = n.linewidth,
                !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial && (t.properties.get(s).light = i),
                s
            }
            function b(n, r, s, o, l) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && l === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n)
                      , r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let a = 0, c = e.length; a < c; a++) {
                            const c = e[a]
                              , u = r[c.materialIndex];
                            if (u && u.visible) {
                                const e = E(n, u, o, l);
                                t.renderBufferDirect(s, null, i, e, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const e = E(n, r, o, l);
                        t.renderBufferDirect(s, null, i, e, n, null)
                    }
                }
                const c = n.children;
                for (let t = 0, e = c.length; t < e; t++)
                    b(c[t], r, s, o, l)
            }
            this.render = function(e, n, s) {
                if (!1 === v.enabled)
                    return;
                if (!1 === v.autoUpdate && !1 === v.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const c = t.getRenderTarget()
                  , u = t.getActiveCubeFace()
                  , h = t.getActiveMipmapLevel()
                  , p = t.state;
                p.setBlending(0),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                const f = y !== a && this.type === a
                  , A = y === a && this.type !== a;
                for (let c = 0, u = e.length; c < u; c++) {
                    const u = e[c]
                      , h = u.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                        continue;
                    r.copy(h.mapSize);
                    const g = h.getFrameExtents();
                    if (r.multiply(g),
                    o.copy(h.mapSize),
                    (r.x > d || r.y > d) && (r.x > d && (o.x = Math.floor(d / g.x),
                    r.x = o.x * g.x,
                    h.mapSize.x = o.x),
                    r.y > d && (o.y = Math.floor(d / g.y),
                    r.y = o.y * g.y,
                    h.mapSize.y = o.y)),
                    null === h.map || !0 === f || !0 === A) {
                        const t = this.type !== a ? {
                            minFilter: S,
                            magFilter: S
                        } : {};
                        null !== h.map && h.map.dispose(),
                        h.map = new ae(r.x,r.y,t),
                        h.map.texture.name = u.name + ".shadowMap",
                        h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map),
                    t.clear();
                    const m = h.getViewportCount();
                    for (let t = 0; t < m; t++) {
                        const e = h.getViewport(t);
                        l.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                        p.viewport(l),
                        h.updateMatrices(u, t),
                        i = h.getFrustum(),
                        b(n, s, h.camera, u, this.type)
                    }
                    !0 !== h.isPointLightShadow && this.type === a && _(h, s),
                    h.needsUpdate = !1
                }
                y = this.type,
                v.needsUpdate = !1,
                t.setRenderTarget(c, u, h)
            }
        }
        function eo(t, e, n) {
            const i = n.isWebGL2
              , r = new function() {
                let e = !1;
                const n = new se;
                let i = null;
                const r = new se(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, s, o, a) {
                        !0 === a && (e *= o,
                        i *= o,
                        s *= o),
                        n.set(e, i, s, o),
                        !1 === r.equals(n) && (t.clearColor(e, i, s, o),
                        r.copy(n))
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , s = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null;
                return {
                    setTest: function(e) {
                        e ? G(t.DEPTH_TEST) : H(t.DEPTH_TEST)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i),
                        n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            switch (e) {
                            case 0:
                                t.depthFunc(t.NEVER);
                                break;
                            case 1:
                                t.depthFunc(t.ALWAYS);
                                break;
                            case 2:
                                t.depthFunc(t.LESS);
                                break;
                            case 3:
                            default:
                                t.depthFunc(t.LEQUAL);
                                break;
                            case 4:
                                t.depthFunc(t.EQUAL);
                                break;
                            case 5:
                                t.depthFunc(t.GEQUAL);
                                break;
                            case 6:
                                t.depthFunc(t.GREATER);
                                break;
                            case 7:
                                t.depthFunc(t.NOTEQUAL)
                            }
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                        r = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null
                    }
                }
            }
              , o = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null
                  , s = null
                  , o = null
                  , a = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        e || (n ? G(t.STENCIL_TEST) : H(t.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(e, n, o) {
                        i === e && r === n && s === o || (t.stencilFunc(e, n, o),
                        i = e,
                        r = n,
                        s = o)
                    },
                    setOp: function(e, n, i) {
                        o === e && a === n && l === i || (t.stencilOp(e, n, i),
                        o = e,
                        a = n,
                        l = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        c !== e && (t.clearStencil(e),
                        c = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        o = null,
                        a = null,
                        l = null,
                        c = null
                    }
                }
            }
              , a = new WeakMap
              , c = new WeakMap;
            let u = {}
              , h = {}
              , d = new WeakMap
              , p = []
              , f = null
              , A = !1
              , g = null
              , m = null
              , v = null
              , y = null
              , _ = null
              , E = null
              , b = null
              , x = !1
              , w = null
              , S = null
              , C = null
              , M = null
              , I = null;
            const T = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let B = !1
              , R = 0;
            const L = t.getParameter(t.VERSION);
            -1 !== L.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(L)[1]),
            B = R >= 1) : -1 !== L.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]),
            B = R >= 2);
            let D = null
              , P = {};
            const U = t.getParameter(t.SCISSOR_BOX)
              , O = t.getParameter(t.VIEWPORT)
              , N = (new se).fromArray(U)
              , F = (new se).fromArray(O);
            function Q(e, n, r, s) {
                const o = new Uint8Array(4)
                  , a = t.createTexture();
                t.bindTexture(e, a),
                t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (let a = 0; a < r; a++)
                    !i || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, o) : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, o);
                return a
            }
            const k = {};
            function G(e) {
                !0 !== u[e] && (t.enable(e),
                u[e] = !0)
            }
            function H(e) {
                !1 !== u[e] && (t.disable(e),
                u[e] = !1)
            }
            k[t.TEXTURE_2D] = Q(t.TEXTURE_2D, t.TEXTURE_2D, 1),
            k[t.TEXTURE_CUBE_MAP] = Q(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            i && (k[t.TEXTURE_2D_ARRAY] = Q(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1),
            k[t.TEXTURE_3D] = Q(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            o.setClear(0),
            G(t.DEPTH_TEST),
            s.setFunc(3),
            q(!1),
            j(1),
            G(t.CULL_FACE),
            W(0);
            const z = {
                [l]: t.FUNC_ADD,
                101: t.FUNC_SUBTRACT,
                102: t.FUNC_REVERSE_SUBTRACT
            };
            if (i)
                z[103] = t.MIN,
                z[104] = t.MAX;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (z[103] = t.MIN_EXT,
                z[104] = t.MAX_EXT)
            }
            const V = {
                200: t.ZERO,
                201: t.ONE,
                202: t.SRC_COLOR,
                204: t.SRC_ALPHA,
                210: t.SRC_ALPHA_SATURATE,
                208: t.DST_COLOR,
                206: t.DST_ALPHA,
                203: t.ONE_MINUS_SRC_COLOR,
                205: t.ONE_MINUS_SRC_ALPHA,
                209: t.ONE_MINUS_DST_COLOR,
                207: t.ONE_MINUS_DST_ALPHA
            };
            function W(e, n, i, r, s, o, a, c) {
                if (0 !== e) {
                    if (!1 === A && (G(t.BLEND),
                    A = !0),
                    5 === e)
                        s = s || n,
                        o = o || i,
                        a = a || r,
                        n === m && s === _ || (t.blendEquationSeparate(z[n], z[s]),
                        m = n,
                        _ = s),
                        i === v && r === y && o === E && a === b || (t.blendFuncSeparate(V[i], V[r], V[o], V[a]),
                        v = i,
                        y = r,
                        E = o,
                        b = a),
                        g = e,
                        x = !1;
                    else if (e !== g || c !== x) {
                        if (m === l && _ === l || (t.blendEquation(t.FUNC_ADD),
                        m = l,
                        _ = l),
                        c)
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.ONE, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        else
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                t.blendFunc(t.SRC_ALPHA, t.ONE);
                                break;
                            case 3:
                                t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                                break;
                            case 4:
                                t.blendFunc(t.ZERO, t.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        v = null,
                        y = null,
                        E = null,
                        b = null,
                        g = e,
                        x = c
                    }
                } else
                    !0 === A && (H(t.BLEND),
                    A = !1)
            }
            function q(e) {
                w !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                w = e)
            }
            function j(e) {
                0 !== e ? (G(t.CULL_FACE),
                e !== S && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : H(t.CULL_FACE),
                S = e
            }
            function X(e, n, i) {
                e ? (G(t.POLYGON_OFFSET_FILL),
                M === n && I === i || (t.polygonOffset(n, i),
                M = n,
                I = i)) : H(t.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: o
                },
                enable: G,
                disable: H,
                bindFramebuffer: function(e, n) {
                    return h[e] !== n && (t.bindFramebuffer(e, n),
                    h[e] = n,
                    i && (e === t.DRAW_FRAMEBUFFER && (h[t.FRAMEBUFFER] = n),
                    e === t.FRAMEBUFFER && (h[t.DRAW_FRAMEBUFFER] = n)),
                    !0)
                },
                drawBuffers: function(i, r) {
                    let s = p
                      , o = !1;
                    if (i)
                        if (s = d.get(r),
                        void 0 === s && (s = [],
                        d.set(r, s)),
                        i.isWebGLMultipleRenderTargets) {
                            const e = i.texture;
                            if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                                for (let n = 0, i = e.length; n < i; n++)
                                    s[n] = t.COLOR_ATTACHMENT0 + n;
                                s.length = e.length,
                                o = !0
                            }
                        } else
                            s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0,
                            o = !0);
                    else
                        s[0] !== t.BACK && (s[0] = t.BACK,
                        o = !0);
                    o && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                },
                useProgram: function(e) {
                    return f !== e && (t.useProgram(e),
                    f = e,
                    !0)
                },
                setBlending: W,
                setMaterial: function(e, n) {
                    2 === e.side ? H(t.CULL_FACE) : G(t.CULL_FACE);
                    let i = 1 === e.side;
                    n && (i = !i),
                    q(i),
                    1 === e.blending && !1 === e.transparent ? W(0) : W(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                    s.setFunc(e.depthFunc),
                    s.setTest(e.depthTest),
                    s.setMask(e.depthWrite),
                    r.setMask(e.colorWrite);
                    const a = e.stencilWrite;
                    o.setTest(a),
                    a && (o.setMask(e.stencilWriteMask),
                    o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                    o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                    X(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                    !0 === e.alphaToCoverage ? G(t.SAMPLE_ALPHA_TO_COVERAGE) : H(t.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: q,
                setCullFace: j,
                setLineWidth: function(e) {
                    e !== C && (B && t.lineWidth(e),
                    C = e)
                },
                setPolygonOffset: X,
                setScissorTest: function(e) {
                    e ? G(t.SCISSOR_TEST) : H(t.SCISSOR_TEST)
                },
                activeTexture: function(e) {
                    void 0 === e && (e = t.TEXTURE0 + T - 1),
                    D !== e && (t.activeTexture(e),
                    D = e)
                },
                bindTexture: function(e, n, i) {
                    void 0 === i && (i = null === D ? t.TEXTURE0 + T - 1 : D);
                    let r = P[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    },
                    P[i] = r),
                    r.type === e && r.texture === n || (D !== i && (t.activeTexture(i),
                    D = i),
                    t.bindTexture(e, n || k[e]),
                    r.type = e,
                    r.texture = n)
                },
                unbindTexture: function() {
                    const e = P[D];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        t.compressedTexImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function(e, n) {
                    let i = c.get(n);
                    void 0 === i && (i = new WeakMap,
                    c.set(n, i));
                    let r = i.get(e);
                    void 0 === r && (r = t.getUniformBlockIndex(n, e.name),
                    i.set(e, r))
                },
                uniformBlockBinding: function(e, n) {
                    const i = c.get(n).get(e);
                    a.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex),
                    a.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        t.compressedTexSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    N.copy(e))
                },
                viewport: function(e) {
                    !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    F.copy(e))
                },
                reset: function() {
                    t.disable(t.BLEND),
                    t.disable(t.CULL_FACE),
                    t.disable(t.DEPTH_TEST),
                    t.disable(t.POLYGON_OFFSET_FILL),
                    t.disable(t.SCISSOR_TEST),
                    t.disable(t.STENCIL_TEST),
                    t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
                    t.blendEquation(t.FUNC_ADD),
                    t.blendFunc(t.ONE, t.ZERO),
                    t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(t.LESS),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(t.ALWAYS, 0, 4294967295),
                    t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
                    t.clearStencil(0),
                    t.cullFace(t.BACK),
                    t.frontFace(t.CCW),
                    t.polygonOffset(0, 0),
                    t.activeTexture(t.TEXTURE0),
                    t.bindFramebuffer(t.FRAMEBUFFER, null),
                    !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                    t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    u = {},
                    D = null,
                    P = {},
                    h = {},
                    d = new WeakMap,
                    p = [],
                    f = null,
                    A = !1,
                    g = null,
                    m = null,
                    v = null,
                    y = null,
                    _ = null,
                    E = null,
                    b = null,
                    x = !1,
                    w = null,
                    S = null,
                    C = null,
                    M = null,
                    I = null,
                    N.set(0, 0, t.canvas.width, t.canvas.height),
                    F.set(0, 0, t.canvas.width, t.canvas.height),
                    r.reset(),
                    s.reset(),
                    o.reset()
                }
            }
        }
        function no(t, e, n, i, r, s, o) {
            const a = r.isWebGL2
              , l = r.maxTextures
              , c = r.maxCubemapSize
              , u = r.maxTextureSize
              , h = r.maxSamples
              , d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
              , p = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , f = new WeakMap;
            let A;
            const g = new WeakMap;
            let m = !1;
            try {
                m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (t) {}
            function v(t, e) {
                return m ? new OffscreenCanvas(t,e) : Gt("canvas")
            }
            function y(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
                r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Dt : Math.floor
                          , s = i(r * t.width)
                          , o = i(r * t.height);
                        void 0 === A && (A = v(s, o));
                        const a = n ? v(s, o) : A;
                        return a.width = s,
                        a.height = o,
                        a.getContext("2d").drawImage(t, 0, 0, s, o),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."),
                        a
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                    t
                }
                return t
            }
            function _(t) {
                return Rt(t.width) && Rt(t.height)
            }
            function E(t, e) {
                return t.generateMipmaps && e && t.minFilter !== S && t.minFilter !== I
            }
            function k(e) {
                t.generateMipmap(e)
            }
            function G(n, i, r, s) {
                let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                if (!1 === a)
                    return i;
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = i;
                if (i === t.RED && (r === t.FLOAT && (l = t.R32F),
                r === t.HALF_FLOAT && (l = t.R16F),
                r === t.UNSIGNED_BYTE && (l = t.R8)),
                i === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (l = t.R8UI),
                r === t.UNSIGNED_SHORT && (l = t.R16UI),
                r === t.UNSIGNED_INT && (l = t.R32UI),
                r === t.BYTE && (l = t.R8I),
                r === t.SHORT && (l = t.R16I),
                r === t.INT && (l = t.R32I)),
                i === t.RG && (r === t.FLOAT && (l = t.RG32F),
                r === t.HALF_FLOAT && (l = t.RG16F),
                r === t.UNSIGNED_BYTE && (l = t.RG8)),
                i === t.RGBA) {
                    const e = o ? dt : Yt.getTransfer(s);
                    r === t.FLOAT && (l = t.RGBA32F),
                    r === t.HALF_FLOAT && (l = t.RGBA16F),
                    r === t.UNSIGNED_BYTE && (l = e === pt ? t.SRGB8_ALPHA8 : t.RGBA8),
                    r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
                    r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)
                }
                return l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"),
                l
            }
            function H(t, e, n) {
                return !0 === E(t, n) || t.isFramebufferTexture && t.minFilter !== S && t.minFilter !== I ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }
            function z(e) {
                return e === S || e === C || e === M ? t.NEAREST : t.LINEAR
            }
            function V(t) {
                const e = t.target;
                e.removeEventListener("dispose", V),
                function(t) {
                    const e = i.get(t);
                    if (void 0 === e.__webglInit)
                        return;
                    const n = t.source
                      , r = g.get(n);
                    if (r) {
                        const i = r[e.__cacheKey];
                        i.usedTimes--,
                        0 === i.usedTimes && q(t),
                        0 === Object.keys(r).length && g.delete(n)
                    }
                    i.remove(t)
                }(e),
                e.isVideoTexture && f.delete(e)
            }
            function W(e) {
                const n = e.target;
                n.removeEventListener("dispose", W),
                function(e) {
                    const n = e.texture
                      , r = i.get(e)
                      , s = i.get(n);
                    if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture),
                    o.memory.textures--),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++) {
                            if (Array.isArray(r.__webglFramebuffer[e]))
                                for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                                    t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                            else
                                t.deleteFramebuffer(r.__webglFramebuffer[e]);
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e])
                        }
                    else {
                        if (Array.isArray(r.__webglFramebuffer))
                            for (let e = 0; e < r.__webglFramebuffer.length; e++)
                                t.deleteFramebuffer(r.__webglFramebuffer[e]);
                        else
                            t.deleteFramebuffer(r.__webglFramebuffer);
                        if (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                        r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                        r.__webglColorRenderbuffer)
                            for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                                r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                    }
                    if (e.isWebGLMultipleRenderTargets)
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            r.__webglTexture && (t.deleteTexture(r.__webglTexture),
                            o.memory.textures--),
                            i.remove(n[e])
                        }
                    i.remove(n),
                    i.remove(e)
                }(n)
            }
            function q(e) {
                const n = i.get(e);
                t.deleteTexture(n.__webglTexture);
                const r = e.source;
                delete g.get(r)[n.__cacheKey],
                o.memory.textures--
            }
            let j = 0;
            function X(e, r) {
                const s = i.get(e);
                if (e.isVideoTexture && function(t) {
                    const e = o.render.frame;
                    f.get(t) !== e && (f.set(t, e),
                    t.update())
                }(e),
                !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version) {
                    const t = e.image;
                    if (null === t)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== t.complete)
                            return void tt(s, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r)
            }
            const Y = {
                [b]: t.REPEAT,
                [x]: t.CLAMP_TO_EDGE,
                [w]: t.MIRRORED_REPEAT
            }
              , K = {
                [S]: t.NEAREST,
                [C]: t.NEAREST_MIPMAP_NEAREST,
                [M]: t.NEAREST_MIPMAP_LINEAR,
                [I]: t.LINEAR,
                [T]: t.LINEAR_MIPMAP_NEAREST,
                [B]: t.LINEAR_MIPMAP_LINEAR
            }
              , J = {
                512: t.NEVER,
                519: t.ALWAYS,
                513: t.LESS,
                515: t.LEQUAL,
                514: t.EQUAL,
                518: t.GEQUAL,
                516: t.GREATER,
                517: t.NOTEQUAL
            };
            function $(n, s, o) {
                if (o ? (t.texParameteri(n, t.TEXTURE_WRAP_S, Y[s.wrapS]),
                t.texParameteri(n, t.TEXTURE_WRAP_T, Y[s.wrapT]),
                n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, Y[s.wrapR]),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, K[s.magFilter]),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, K[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                s.wrapS === x && s.wrapT === x || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, z(s.magFilter)),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, z(s.minFilter)),
                s.minFilter !== S && s.minFilter !== I && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                s.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
                t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, J[s.compareFunction])),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const o = e.get("EXT_texture_filter_anisotropic");
                    if (s.magFilter === S)
                        return;
                    if (s.minFilter !== M && s.minFilter !== B)
                        return;
                    if (s.type === P && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === a && s.type === U && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                    i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }
            function Z(e, n) {
                let i = !1;
                void 0 === e.__webglInit && (e.__webglInit = !0,
                n.addEventListener("dispose", V));
                const r = n.source;
                let s = g.get(r);
                void 0 === s && (s = {},
                g.set(r, s));
                const a = function(t) {
                    const e = [];
                    return e.push(t.wrapS),
                    e.push(t.wrapT),
                    e.push(t.wrapR || 0),
                    e.push(t.magFilter),
                    e.push(t.minFilter),
                    e.push(t.anisotropy),
                    e.push(t.internalFormat),
                    e.push(t.format),
                    e.push(t.type),
                    e.push(t.generateMipmaps),
                    e.push(t.premultiplyAlpha),
                    e.push(t.flipY),
                    e.push(t.unpackAlignment),
                    e.push(t.colorSpace),
                    e.join()
                }(n);
                if (a !== e.__cacheKey) {
                    void 0 === s[a] && (s[a] = {
                        texture: t.createTexture(),
                        usedTimes: 0
                    },
                    o.memory.textures++,
                    i = !0),
                    s[a].usedTimes++;
                    const r = s[e.__cacheKey];
                    void 0 !== r && (s[e.__cacheKey].usedTimes--,
                    0 === r.usedTimes && q(n)),
                    e.__cacheKey = a,
                    e.__webglTexture = s[a].texture
                }
                return i
            }
            function tt(e, r, o) {
                let l = t.TEXTURE_2D;
                (r.isDataArrayTexture || r.isCompressedArrayTexture) && (l = t.TEXTURE_2D_ARRAY),
                r.isData3DTexture && (l = t.TEXTURE_3D);
                const c = Z(e, r)
                  , h = r.source;
                n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
                const d = i.get(h);
                if (h.version !== d.__version || !0 === c) {
                    n.activeTexture(t.TEXTURE0 + o);
                    const e = Yt.getPrimaries(Yt.workingColorSpace)
                      , i = r.colorSpace === at ? null : Yt.getPrimaries(r.colorSpace)
                      , p = r.colorSpace === at || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                    t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                    t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                    t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                    const f = function(t) {
                        return !a && (t.wrapS !== x || t.wrapT !== x || t.minFilter !== S && t.minFilter !== I)
                    }(r) && !1 === _(r.image);
                    let A = y(r.image, f, !1, u);
                    A = ot(r, A);
                    const g = _(A) || a
                      , m = s.convert(r.format, r.colorSpace);
                    let v, b = s.convert(r.type), w = G(r.internalFormat, m, b, r.colorSpace, r.isVideoTexture);
                    $(l, r, g);
                    const C = r.mipmaps
                      , M = a && !0 !== r.isVideoTexture
                      , T = void 0 === d.__version || !0 === c
                      , B = H(r, A, g);
                    if (r.isDepthTexture)
                        w = t.DEPTH_COMPONENT,
                        a ? w = r.type === P ? t.DEPTH_COMPONENT32F : r.type === D ? t.DEPTH_COMPONENT24 : r.type === O ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : r.type === P && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        r.format === F && w === t.DEPTH_COMPONENT && r.type !== L && r.type !== D && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        r.type = D,
                        b = s.convert(r.type)),
                        r.format === Q && w === t.DEPTH_COMPONENT && (w = t.DEPTH_STENCIL,
                        r.type !== O && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        r.type = O,
                        b = s.convert(r.type))),
                        T && (M ? n.texStorage2D(t.TEXTURE_2D, 1, w, A.width, A.height) : n.texImage2D(t.TEXTURE_2D, 0, w, A.width, A.height, 0, m, b, null));
                    else if (r.isDataTexture)
                        if (C.length > 0 && g) {
                            M && T && n.texStorage2D(t.TEXTURE_2D, B, w, C[0].width, C[0].height);
                            for (let e = 0, i = C.length; e < i; e++)
                                v = C[e],
                                M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, v.width, v.height, m, b, v.data) : n.texImage2D(t.TEXTURE_2D, e, w, v.width, v.height, 0, m, b, v.data);
                            r.generateMipmaps = !1
                        } else
                            M ? (T && n.texStorage2D(t.TEXTURE_2D, B, w, A.width, A.height),
                            n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, A.width, A.height, m, b, A.data)) : n.texImage2D(t.TEXTURE_2D, 0, w, A.width, A.height, 0, m, b, A.data);
                    else if (r.isCompressedTexture)
                        if (r.isCompressedArrayTexture) {
                            M && T && n.texStorage3D(t.TEXTURE_2D_ARRAY, B, w, C[0].width, C[0].height, A.depth);
                            for (let e = 0, i = C.length; e < i; e++)
                                v = C[e],
                                r.format !== N ? null !== m ? M ? n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, v.width, v.height, A.depth, m, v.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, w, v.width, v.height, A.depth, 0, v.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, v.width, v.height, A.depth, m, b, v.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, w, v.width, v.height, A.depth, 0, m, b, v.data)
                        } else {
                            M && T && n.texStorage2D(t.TEXTURE_2D, B, w, C[0].width, C[0].height);
                            for (let e = 0, i = C.length; e < i; e++)
                                v = C[e],
                                r.format !== N ? null !== m ? M ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, v.width, v.height, m, v.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, w, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, v.width, v.height, m, b, v.data) : n.texImage2D(t.TEXTURE_2D, e, w, v.width, v.height, 0, m, b, v.data)
                        }
                    else if (r.isDataArrayTexture)
                        M ? (T && n.texStorage3D(t.TEXTURE_2D_ARRAY, B, w, A.width, A.height, A.depth),
                        n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, A.width, A.height, A.depth, m, b, A.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, w, A.width, A.height, A.depth, 0, m, b, A.data);
                    else if (r.isData3DTexture)
                        M ? (T && n.texStorage3D(t.TEXTURE_3D, B, w, A.width, A.height, A.depth),
                        n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, A.width, A.height, A.depth, m, b, A.data)) : n.texImage3D(t.TEXTURE_3D, 0, w, A.width, A.height, A.depth, 0, m, b, A.data);
                    else if (r.isFramebufferTexture) {
                        if (T)
                            if (M)
                                n.texStorage2D(t.TEXTURE_2D, B, w, A.width, A.height);
                            else {
                                let e = A.width
                                  , i = A.height;
                                for (let r = 0; r < B; r++)
                                    n.texImage2D(t.TEXTURE_2D, r, w, e, i, 0, m, b, null),
                                    e >>= 1,
                                    i >>= 1
                            }
                    } else if (C.length > 0 && g) {
                        M && T && n.texStorage2D(t.TEXTURE_2D, B, w, C[0].width, C[0].height);
                        for (let e = 0, i = C.length; e < i; e++)
                            v = C[e],
                            M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m, b, v) : n.texImage2D(t.TEXTURE_2D, e, w, m, b, v);
                        r.generateMipmaps = !1
                    } else
                        M ? (T && n.texStorage2D(t.TEXTURE_2D, B, w, A.width, A.height),
                        n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, m, b, A)) : n.texImage2D(t.TEXTURE_2D, 0, w, m, b, A);
                    E(r, g) && k(l),
                    d.__version = h.version,
                    r.onUpdate && r.onUpdate(r)
                }
                e.__version = r.version
            }
            function et(e, r, o, a, l, c) {
                const u = s.convert(o.format, o.colorSpace)
                  , h = s.convert(o.type)
                  , p = G(o.internalFormat, u, h, o.colorSpace);
                if (!i.get(r).__hasExternalTextures) {
                    const e = Math.max(1, r.width >> c)
                      , i = Math.max(1, r.height >> c);
                    l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, c, p, e, i, r.depth, 0, u, h, null) : n.texImage2D(l, c, p, e, i, 0, u, h, null)
                }
                n.bindFramebuffer(t.FRAMEBUFFER, e),
                st(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, a, l, i.get(o).__webglTexture, 0, rt(r)) : (l === t.TEXTURE_2D || l >= t.TEXTURE_CUBE_MAP_POSITIVE_X && l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, a, l, i.get(o).__webglTexture, c),
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function nt(e, n, i) {
                if (t.bindRenderbuffer(t.RENDERBUFFER, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = !0 === a ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
                    if (i || st(n)) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === P ? r = t.DEPTH_COMPONENT32F : e.type === D && (r = t.DEPTH_COMPONENT24));
                        const i = rt(n);
                        st(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                    } else
                        t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = rt(n);
                    i && !1 === st(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : st(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r]
                          , a = s.convert(o.format, o.colorSpace)
                          , l = s.convert(o.type)
                          , c = G(o.internalFormat, a, l, o.colorSpace)
                          , u = rt(n);
                        i && !1 === st(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, u, c, n.width, n.height) : st(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, u, c, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height)
                    }
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null)
            }
            function it(e) {
                const r = i.get(e)
                  , s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(t.FRAMEBUFFER, e),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        X(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture
                          , o = rt(r);
                        if (r.depthTexture.format === F)
                            st(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                        else {
                            if (r.depthTexture.format !== Q)
                                throw new Error("Unknown depthTexture format");
                            st(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, o) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                        nt(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
                    r.__webglDepthbuffer = t.createRenderbuffer(),
                    nt(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(t.FRAMEBUFFER, null)
            }
            function rt(t) {
                return Math.min(h, t.samples)
            }
            function st(t) {
                const n = i.get(t);
                return a && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function ot(t, n) {
                const i = t.colorSpace
                  , r = t.format
                  , s = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === yt || i !== ct && i !== at && (Yt.getTransfer(i) === pt ? !1 === a ? !0 === e.has("EXT_sRGB") && r === N ? (t.format = yt,
                t.minFilter = I,
                t.generateMipmaps = !1) : n = Zt.sRGBToLinear(n) : r === N && s === R || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)),
                n
            }
            this.allocateTextureUnit = function() {
                const t = j;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
                j += 1,
                t
            }
            ,
            this.resetTextureUnits = function() {
                j = 0
            }
            ,
            this.setTexture2D = X,
            this.setTexture2DArray = function(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? tt(s, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r)
            }
            ,
            this.setTexture3D = function(e, r) {
                const s = i.get(e);
                e.version > 0 && s.__version !== e.version ? tt(s, e, r) : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r)
            }
            ,
            this.setTextureCube = function(e, r) {
                const o = i.get(e);
                e.version > 0 && o.__version !== e.version ? function(e, r, o) {
                    if (6 !== r.image.length)
                        return;
                    const l = Z(e, r)
                      , u = r.source;
                    n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + o);
                    const h = i.get(u);
                    if (u.version !== h.__version || !0 === l) {
                        n.activeTexture(t.TEXTURE0 + o);
                        const e = Yt.getPrimaries(Yt.workingColorSpace)
                          , i = r.colorSpace === at ? null : Yt.getPrimaries(r.colorSpace)
                          , d = r.colorSpace === at || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                        t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                        const p = r.isCompressedTexture || r.image[0].isCompressedTexture
                          , f = r.image[0] && r.image[0].isDataTexture
                          , A = [];
                        for (let t = 0; t < 6; t++)
                            A[t] = p || f ? f ? r.image[t].image : r.image[t] : y(r.image[t], !1, !0, c),
                            A[t] = ot(r, A[t]);
                        const g = A[0]
                          , m = _(g) || a
                          , v = s.convert(r.format, r.colorSpace)
                          , b = s.convert(r.type)
                          , x = G(r.internalFormat, v, b, r.colorSpace)
                          , w = a && !0 !== r.isVideoTexture
                          , S = void 0 === h.__version || !0 === l;
                        let C, M = H(r, g, m);
                        if ($(t.TEXTURE_CUBE_MAP, r, m),
                        p) {
                            w && S && n.texStorage2D(t.TEXTURE_CUBE_MAP, M, x, g.width, g.height);
                            for (let e = 0; e < 6; e++) {
                                C = A[e].mipmaps;
                                for (let i = 0; i < C.length; i++) {
                                    const s = C[i];
                                    r.format !== N ? null !== v ? w ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, v, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, x, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, v, b, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, x, s.width, s.height, 0, v, b, s.data)
                                }
                            }
                        } else {
                            C = r.mipmaps,
                            w && S && (C.length > 0 && M++,
                            n.texStorage2D(t.TEXTURE_CUBE_MAP, M, x, A[0].width, A[0].height));
                            for (let e = 0; e < 6; e++)
                                if (f) {
                                    w ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, A[e].width, A[e].height, v, b, A[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, x, A[e].width, A[e].height, 0, v, b, A[e].data);
                                    for (let i = 0; i < C.length; i++) {
                                        const r = C[i].image[e].image;
                                        w ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, v, b, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, x, r.width, r.height, 0, v, b, r.data)
                                    }
                                } else {
                                    w ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, v, b, A[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, x, v, b, A[e]);
                                    for (let i = 0; i < C.length; i++) {
                                        const r = C[i];
                                        w ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, v, b, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, x, v, b, r.image[e])
                                    }
                                }
                        }
                        E(r, m) && k(t.TEXTURE_CUBE_MAP),
                        h.__version = u.version,
                        r.onUpdate && r.onUpdate(r)
                    }
                    e.__version = r.version
                }(o, e, r) : n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture, t.TEXTURE0 + r)
            }
            ,
            this.rebindTextures = function(e, n, r) {
                const s = i.get(e);
                void 0 !== n && et(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0),
                void 0 !== r && it(e)
            }
            ,
            this.setupRenderTarget = function(e) {
                const l = e.texture
                  , c = i.get(e)
                  , u = i.get(l);
                e.addEventListener("dispose", W),
                !0 !== e.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = t.createTexture()),
                u.__version = l.version,
                o.memory.textures++);
                const h = !0 === e.isWebGLCubeRenderTarget
                  , d = !0 === e.isWebGLMultipleRenderTargets
                  , p = _(e) || a;
                if (h) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        if (a && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[e] = [];
                            for (let n = 0; n < l.mipmaps.length; n++)
                                c.__webglFramebuffer[e][n] = t.createFramebuffer()
                        } else
                            c.__webglFramebuffer[e] = t.createFramebuffer()
                } else {
                    if (a && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let e = 0; e < l.mipmaps.length; e++)
                            c.__webglFramebuffer[e] = t.createFramebuffer()
                    } else
                        c.__webglFramebuffer = t.createFramebuffer();
                    if (d)
                        if (r.drawBuffers) {
                            const n = e.texture;
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(),
                                o.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (a && e.samples > 0 && !1 === st(e)) {
                        const i = d ? l : [l];
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        c.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            const r = i[n];
                            c.__webglColorRenderbuffer[n] = t.createRenderbuffer(),
                            t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const o = s.convert(r.format, r.colorSpace)
                              , a = s.convert(r.type)
                              , l = G(r.internalFormat, o, a, r.colorSpace, !0 === e.isXRRenderTarget)
                              , u = rt(e);
                            t.renderbufferStorageMultisample(t.RENDERBUFFER, u, l, e.width, e.height),
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        t.bindRenderbuffer(t.RENDERBUFFER, null),
                        e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        nt(c.__webglDepthRenderbuffer, e, !0)),
                        n.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                }
                if (h) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture),
                    $(t.TEXTURE_CUBE_MAP, l, p);
                    for (let n = 0; n < 6; n++)
                        if (a && l.mipmaps && l.mipmaps.length > 0)
                            for (let i = 0; i < l.mipmaps.length; i++)
                                et(c.__webglFramebuffer[n][i], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            et(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    E(l, p) && k(t.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (d) {
                    const r = e.texture;
                    for (let s = 0, o = r.length; s < o; s++) {
                        const o = r[s]
                          , a = i.get(o);
                        n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                        $(t.TEXTURE_2D, o, p),
                        et(c.__webglFramebuffer, e, o, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0),
                        E(o, p) && k(t.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = t.TEXTURE_2D;
                    if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (a ? i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    n.bindTexture(i, u.__webglTexture),
                    $(i, l, p),
                    a && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++)
                            et(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                    else
                        et(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                    E(l, p) && k(i),
                    n.unbindTexture()
                }
                e.depthBuffer && it(e)
            }
            ,
            this.updateRenderTargetMipmap = function(e) {
                const r = _(e) || a
                  , s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                for (let o = 0, a = s.length; o < a; o++) {
                    const a = s[o];
                    if (E(a, r)) {
                        const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D
                          , s = i.get(a).__webglTexture;
                        n.bindTexture(r, s),
                        k(r),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(e) {
                if (a && e.samples > 0 && !1 === st(e)) {
                    const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture]
                      , s = e.width
                      , o = e.height;
                    let a = t.COLOR_BUFFER_BIT;
                    const l = []
                      , c = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT
                      , u = i.get(e)
                      , h = !0 === e.isWebGLMultipleRenderTargets;
                    if (h)
                        for (let e = 0; e < r.length; e++)
                            n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null),
                            n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(t.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                    for (let n = 0; n < r.length; n++) {
                        l.push(t.COLOR_ATTACHMENT0 + n),
                        e.depthBuffer && l.push(c);
                        const d = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                        if (!1 === d && (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                        e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)),
                        h && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, u.__webglColorRenderbuffer[n]),
                        !0 === d && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]),
                        t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])),
                        h) {
                            const e = i.get(r[n]).__webglTexture;
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                        }
                        t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, t.NEAREST),
                        p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                    h)
                        for (let e = 0; e < r.length; e++) {
                            n.bindFramebuffer(t.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, u.__webglColorRenderbuffer[e]);
                            const s = i.get(r[e]).__webglTexture;
                            n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                            t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, s, 0)
                        }
                    n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                }
            }
            ,
            this.setupDepthRenderbuffer = it,
            this.setupFrameBufferTexture = et,
            this.useMultisampledRTT = st
        }
        function io(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function(n) {
                    let r, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at;
                    const o = Yt.getTransfer(s);
                    if (n === R)
                        return t.UNSIGNED_BYTE;
                    if (1017 === n)
                        return t.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n)
                        return t.UNSIGNED_SHORT_5_5_5_1;
                    if (1010 === n)
                        return t.BYTE;
                    if (1011 === n)
                        return t.SHORT;
                    if (n === L)
                        return t.UNSIGNED_SHORT;
                    if (1013 === n)
                        return t.INT;
                    if (n === D)
                        return t.UNSIGNED_INT;
                    if (n === P)
                        return t.FLOAT;
                    if (n === U)
                        return i ? t.HALF_FLOAT : (r = e.get("OES_texture_half_float"),
                        null !== r ? r.HALF_FLOAT_OES : null);
                    if (1021 === n)
                        return t.ALPHA;
                    if (n === N)
                        return t.RGBA;
                    if (1024 === n)
                        return t.LUMINANCE;
                    if (1025 === n)
                        return t.LUMINANCE_ALPHA;
                    if (n === F)
                        return t.DEPTH_COMPONENT;
                    if (n === Q)
                        return t.DEPTH_STENCIL;
                    if (n === yt)
                        return r = e.get("EXT_sRGB"),
                        null !== r ? r.SRGB_ALPHA_EXT : null;
                    if (n === k)
                        return t.RED;
                    if (1029 === n)
                        return t.RED_INTEGER;
                    if (n === G)
                        return t.RG;
                    if (1031 === n)
                        return t.RG_INTEGER;
                    if (1033 === n)
                        return t.RGBA_INTEGER;
                    if (n === H || n === z || n === V || n === W)
                        if (o === pt) {
                            if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === r)
                                return null;
                            if (n === H)
                                return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === z)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === V)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === W)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (r = e.get("WEBGL_compressed_texture_s3tc"),
                            null === r)
                                return null;
                            if (n === H)
                                return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === z)
                                return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === V)
                                return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === W)
                                return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === q || 35841 === n || n === j || 35843 === n) {
                        if (r = e.get("WEBGL_compressed_texture_pvrtc"),
                        null === r)
                            return null;
                        if (n === q)
                            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n)
                            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === j)
                            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n)
                            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === n)
                        return r = e.get("WEBGL_compressed_texture_etc1"),
                        null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (n === X || n === Y) {
                        if (r = e.get("WEBGL_compressed_texture_etc"),
                        null === r)
                            return null;
                        if (n === X)
                            return o === pt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (n === Y)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === K || 37809 === n || 37810 === n || 37811 === n || n === J || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (r = e.get("WEBGL_compressed_texture_astc"),
                        null === r)
                            return null;
                        if (n === K)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === J)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n)
                            return o === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === $ || 36494 === n || 36495 === n) {
                        if (r = e.get("EXT_texture_compression_bptc"),
                        null === r)
                            return null;
                        if (n === $)
                            return o === pt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === n)
                            return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === n)
                            return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (r = e.get("EXT_texture_compression_rgtc"),
                        null === r)
                            return null;
                        if (n === $)
                            return r.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n)
                            return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n)
                            return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n)
                            return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === O ? i ? t.UNSIGNED_INT_24_8 : (r = e.get("WEBGL_depth_texture"),
                    null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
                }
            }
        }
        class ro extends xi {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                super(),
                this.isArrayCamera = !0,
                this.cameras = t
            }
        }
        class so extends pn {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const oo = {
            type: "move"
        };
        class ao {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new so,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new so,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new he,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new he),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new so,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new he,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new he),
                this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            }
            connect(t) {
                if (t && t.hand) {
                    const e = this._hand;
                    if (e)
                        for (const n of t.hand.values())
                            this._getHandJoint(e, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: t
                }),
                this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(t, e, n) {
                let i = null
                  , r = null
                  , s = null;
                const o = this._targetRay
                  , a = this._grip
                  , l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState) {
                    if (l && t.hand) {
                        s = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n)
                              , r = this._getHandJoint(l, i);
                            null !== t && (r.matrix.fromArray(t.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.matrixWorldNeedsUpdate = !0,
                            r.jointRadius = t.radius),
                            r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , o = i.position.distanceTo(r.position)
                          , a = .02
                          , c = .005;
                        l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                        null !== r && (a.matrix.fromArray(r.transform.matrix),
                        a.matrix.decompose(a.position, a.rotation, a.scale),
                        a.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (a.hasLinearVelocity = !0,
                        a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
                        r.angularVelocity ? (a.hasAngularVelocity = !0,
                        a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                    null !== o && (i = e.getPose(t.targetRaySpace, n),
                    null === i && null !== r && (i = r),
                    null !== i && (o.matrix.fromArray(i.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    o.matrixWorldNeedsUpdate = !0,
                    i.linearVelocity ? (o.hasLinearVelocity = !0,
                    o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                    i.angularVelocity ? (o.hasAngularVelocity = !0,
                    o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                    this.dispatchEvent(oo)))
                }
                return null !== o && (o.visible = null !== i),
                null !== a && (a.visible = null !== r),
                null !== l && (l.visible = null !== s),
                this
            }
            _getHandJoint(t, e) {
                if (void 0 === t.joints[e.jointName]) {
                    const n = new so;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    t.joints[e.jointName] = n,
                    t.add(n)
                }
                return t.joints[e.jointName]
            }
        }
        class lo extends re {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                if ((c = void 0 !== c ? c : F) !== F && c !== Q)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === F && (n = D),
                void 0 === n && c === Q && (n = O),
                super(null, i, r, s, o, a, c, n, l),
                this.isDepthTexture = !0,
                this.image = {
                    width: t,
                    height: e
                },
                this.magFilter = void 0 !== o ? o : S,
                this.minFilter = void 0 !== a ? a : S,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(t) {
                return super.copy(t),
                this.compareFunction = t.compareFunction,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.compareFunction && (e.compareFunction = this.compareFunction),
                e
            }
        }
        class co extends bt {
            constructor(t, e) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , s = null
                  , o = "local-floor"
                  , a = 1
                  , l = null
                  , c = null
                  , u = null
                  , h = null
                  , d = null
                  , p = null;
                const f = e.getContextAttributes();
                let A = null
                  , g = null;
                const m = []
                  , v = []
                  , y = new xi;
                y.layers.enable(1),
                y.viewport = new se;
                const _ = new xi;
                _.layers.enable(2),
                _.viewport = new se;
                const E = [y, _]
                  , b = new ro;
                b.layers.enable(1),
                b.layers.enable(2);
                let x = null
                  , w = null;
                function S(t) {
                    const e = v.indexOf(t.inputSource);
                    if (-1 === e)
                        return;
                    const n = m[e];
                    void 0 !== n && (n.update(t.inputSource, t.frame, l || s),
                    n.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    }))
                }
                function C() {
                    i.removeEventListener("select", S),
                    i.removeEventListener("selectstart", S),
                    i.removeEventListener("selectend", S),
                    i.removeEventListener("squeeze", S),
                    i.removeEventListener("squeezestart", S),
                    i.removeEventListener("squeezeend", S),
                    i.removeEventListener("end", C),
                    i.removeEventListener("inputsourceschange", M);
                    for (let t = 0; t < m.length; t++) {
                        const e = v[t];
                        null !== e && (v[t] = null,
                        m[t].disconnect(e))
                    }
                    x = null,
                    w = null,
                    t.setRenderTarget(A),
                    d = null,
                    h = null,
                    u = null,
                    i = null,
                    g = null,
                    P.stop(),
                    n.isPresenting = !1,
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function M(t) {
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e]
                          , i = v.indexOf(n);
                        i >= 0 && (v[i] = null,
                        m[i].disconnect(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e];
                        let i = v.indexOf(n);
                        if (-1 === i) {
                            for (let t = 0; t < m.length; t++) {
                                if (t >= v.length) {
                                    v.push(n),
                                    i = t;
                                    break
                                }
                                if (null === v[t]) {
                                    v[t] = n,
                                    i = t;
                                    break
                                }
                            }
                            if (-1 === i)
                                break
                        }
                        const r = m[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new ao,
                    m[t] = e),
                    e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new ao,
                    m[t] = e),
                    e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = m[t];
                    return void 0 === e && (e = new ao,
                    m[t] = e),
                    e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    r = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    o = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return l || s
                }
                ,
                this.setReferenceSpace = function(t) {
                    l = t
                }
                ,
                this.getBaseLayer = function() {
                    return null !== h ? h : d
                }
                ,
                this.getBinding = function() {
                    return u
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(c) {
                    if (i = c,
                    null !== i) {
                        if (A = t.getRenderTarget(),
                        i.addEventListener("select", S),
                        i.addEventListener("selectstart", S),
                        i.addEventListener("selectend", S),
                        i.addEventListener("squeeze", S),
                        i.addEventListener("squeezestart", S),
                        i.addEventListener("squeezeend", S),
                        i.addEventListener("end", C),
                        i.addEventListener("inputsourceschange", M),
                        !0 !== f.xrCompatible && await e.makeXRCompatible(),
                        void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: !0,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            d = new XRWebGLLayer(i,e,n),
                            i.updateRenderState({
                                baseLayer: d
                            }),
                            g = new ae(d.framebufferWidth,d.framebufferHeight,{
                                format: N,
                                type: R,
                                colorSpace: t.outputColorSpace,
                                stencilBuffer: f.stencil
                            })
                        } else {
                            let n = null
                              , s = null
                              , o = null;
                            f.depth && (o = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24,
                            n = f.stencil ? Q : F,
                            s = f.stencil ? O : D);
                            const a = {
                                colorFormat: e.RGBA8,
                                depthFormat: o,
                                scaleFactor: r
                            };
                            u = new XRWebGLBinding(i,e),
                            h = u.createProjectionLayer(a),
                            i.updateRenderState({
                                layers: [h]
                            }),
                            g = new ae(h.textureWidth,h.textureHeight,{
                                format: N,
                                type: R,
                                depthTexture: new lo(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: f.stencil,
                                colorSpace: t.outputColorSpace,
                                samples: f.antialias ? 4 : 0
                            }),
                            t.properties.get(g).__ignoreDepthValues = h.ignoreDepthValues
                        }
                        g.isXRRenderTarget = !0,
                        this.setFoveation(a),
                        l = null,
                        s = await i.requestReferenceSpace(o),
                        P.setContext(i),
                        P.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== i)
                        return i.environmentBlendMode
                }
                ;
                const I = new he
                  , T = new he;
                function B(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === i)
                        return;
                    b.near = _.near = y.near = t.near,
                    b.far = _.far = y.far = t.far,
                    x === b.near && w === b.far || (i.updateRenderState({
                        depthNear: b.near,
                        depthFar: b.far
                    }),
                    x = b.near,
                    w = b.far);
                    const e = t.parent
                      , n = b.cameras;
                    B(b, e);
                    for (let t = 0; t < n.length; t++)
                        B(n[t], e);
                    2 === n.length ? function(t, e, n) {
                        I.setFromMatrixPosition(e.matrixWorld),
                        T.setFromMatrixPosition(n.matrixWorld);
                        const i = I.distanceTo(T)
                          , r = e.projectionMatrix.elements
                          , s = n.projectionMatrix.elements
                          , o = r[14] / (r[10] - 1)
                          , a = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , u = (r[8] - 1) / r[0]
                          , h = (s[8] + 1) / s[0]
                          , d = o * u
                          , p = o * h
                          , f = i / (-u + h)
                          , A = f * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                        t.translateX(A),
                        t.translateZ(f),
                        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = o + f
                          , m = a + f
                          , v = d - A
                          , y = p + (i - A)
                          , _ = l * a / m * g
                          , E = c * a / m * g;
                        t.projectionMatrix.makePerspective(v, y, _, E, g, m),
                        t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                    }(b, y, _) : b.projectionMatrix.copy(y.projectionMatrix),
                    function(t, e, n) {
                        null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld),
                        t.matrix.invert(),
                        t.matrix.multiply(e.matrixWorld)),
                        t.matrix.decompose(t.position, t.quaternion, t.scale),
                        t.updateMatrixWorld(!0),
                        t.projectionMatrix.copy(e.projectionMatrix),
                        t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                        t.isPerspectiveCamera && (t.fov = 2 * Ct * Math.atan(1 / t.projectionMatrix.elements[5]),
                        t.zoom = 1)
                    }(t, b, e)
                }
                ,
                this.getCamera = function() {
                    return b
                }
                ,
                this.getFoveation = function() {
                    if (null !== h || null !== d)
                        return a
                }
                ,
                this.setFoveation = function(t) {
                    a = t,
                    null !== h && (h.fixedFoveation = t),
                    null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                }
                ;
                let L = null;
                const P = new Ui;
                P.setAnimationLoop((function(e, i) {
                    if (c = i.getViewerPose(l || s),
                    p = i,
                    null !== c) {
                        const e = c.views;
                        null !== d && (t.setRenderTargetFramebuffer(g, d.framebuffer),
                        t.setRenderTarget(g));
                        let n = !1;
                        e.length !== b.cameras.length && (b.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let s = null;
                            if (null !== d)
                                s = d.getViewport(r);
                            else {
                                const e = u.getViewSubImage(h, r);
                                s = e.viewport,
                                0 === i && (t.setRenderTargetTextures(g, e.colorTexture, h.ignoreDepthValues ? void 0 : e.depthStencilTexture),
                                t.setRenderTarget(g))
                            }
                            let o = E[i];
                            void 0 === o && (o = new xi,
                            o.layers.enable(i),
                            o.viewport = new se,
                            E[i] = o),
                            o.matrix.fromArray(r.transform.matrix),
                            o.matrix.decompose(o.position, o.quaternion, o.scale),
                            o.projectionMatrix.fromArray(r.projectionMatrix),
                            o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                            o.viewport.set(s.x, s.y, s.width, s.height),
                            0 === i && (b.matrix.copy(o.matrix),
                            b.matrix.decompose(b.position, b.quaternion, b.scale)),
                            !0 === n && b.cameras.push(o)
                        }
                    }
                    for (let t = 0; t < m.length; t++) {
                        const e = v[t]
                          , n = m[t];
                        null !== e && void 0 !== n && n.update(e, i, l || s)
                    }
                    L && L(e, i),
                    i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }),
                    p = null
                }
                )),
                this.setAnimationLoop = function(t) {
                    L = t
                }
                ,
                this.dispose = function() {}
            }
        }
        function uo(t, e) {
            function n(t, e) {
                !0 === t.matrixAutoUpdate && t.updateMatrix(),
                e.value.copy(t.matrix)
            }
            function i(i, r) {
                i.opacity.value = r.opacity,
                r.color && i.diffuse.value.copy(r.color),
                r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
                r.map && (i.map.value = r.map,
                n(r.map, i.mapTransform)),
                r.alphaMap && (i.alphaMap.value = r.alphaMap,
                n(r.alphaMap, i.alphaMapTransform)),
                r.bumpMap && (i.bumpMap.value = r.bumpMap,
                n(r.bumpMap, i.bumpMapTransform),
                i.bumpScale.value = r.bumpScale,
                1 === r.side && (i.bumpScale.value *= -1)),
                r.normalMap && (i.normalMap.value = r.normalMap,
                n(r.normalMap, i.normalMapTransform),
                i.normalScale.value.copy(r.normalScale),
                1 === r.side && i.normalScale.value.negate()),
                r.displacementMap && (i.displacementMap.value = r.displacementMap,
                n(r.displacementMap, i.displacementMapTransform),
                i.displacementScale.value = r.displacementScale,
                i.displacementBias.value = r.displacementBias),
                r.emissiveMap && (i.emissiveMap.value = r.emissiveMap,
                n(r.emissiveMap, i.emissiveMapTransform)),
                r.specularMap && (i.specularMap.value = r.specularMap,
                n(r.specularMap, i.specularMapTransform)),
                r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const s = e.get(r).envMap;
                if (s && (i.envMap.value = s,
                i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1,
                i.reflectivity.value = r.reflectivity,
                i.ior.value = r.ior,
                i.refractionRatio.value = r.refractionRatio),
                r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const e = !0 === t._useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * e,
                    n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap,
                i.aoMapIntensity.value = r.aoMapIntensity,
                n(r.aoMap, i.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(e, n) {
                    n.color.getRGB(e.fogColor.value, yi(t)),
                    n.isFog ? (e.fogNear.value = n.near,
                    e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(t, r, s, o, a) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(t, r) : r.isMeshToonMaterial ? (i(t, r),
                    function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(t, r)) : r.isMeshPhongMaterial ? (i(t, r),
                    function(t, e) {
                        t.specular.value.copy(e.specular),
                        t.shininess.value = Math.max(e.shininess, 1e-4)
                    }(t, r)) : r.isMeshStandardMaterial ? (i(t, r),
                    function(t, i) {
                        t.metalness.value = i.metalness,
                        i.metalnessMap && (t.metalnessMap.value = i.metalnessMap,
                        n(i.metalnessMap, t.metalnessMapTransform)),
                        t.roughness.value = i.roughness,
                        i.roughnessMap && (t.roughnessMap.value = i.roughnessMap,
                        n(i.roughnessMap, t.roughnessMapTransform));
                        e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity)
                    }(t, r),
                    r.isMeshPhysicalMaterial && function(t, e, i) {
                        t.ior.value = e.ior,
                        e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                        t.sheenRoughness.value = e.sheenRoughness,
                        e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap,
                        n(e.sheenColorMap, t.sheenColorMapTransform)),
                        e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap,
                        n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                        t.clearcoatRoughness.value = e.clearcoatRoughness,
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap,
                        n(e.clearcoatMap, t.clearcoatMapTransform)),
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap,
                        n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)),
                        e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                        n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                        t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                        1 === e.side && t.clearcoatNormalScale.value.negate())),
                        e.iridescence > 0 && (t.iridescence.value = e.iridescence,
                        t.iridescenceIOR.value = e.iridescenceIOR,
                        t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0],
                        t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1],
                        e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap,
                        n(e.iridescenceMap, t.iridescenceMapTransform)),
                        e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap,
                        n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform))),
                        e.transmission > 0 && (t.transmission.value = e.transmission,
                        t.transmissionSamplerMap.value = i.texture,
                        t.transmissionSamplerSize.value.set(i.width, i.height),
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap,
                        n(e.transmissionMap, t.transmissionMapTransform)),
                        t.thickness.value = e.thickness,
                        e.thicknessMap && (t.thicknessMap.value = e.thicknessMap,
                        n(e.thicknessMap, t.thicknessMapTransform)),
                        t.attenuationDistance.value = e.attenuationDistance,
                        t.attenuationColor.value.copy(e.attenuationColor)),
                        e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)),
                        e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap,
                        n(e.anisotropyMap, t.anisotropyMapTransform))),
                        t.specularIntensity.value = e.specularIntensity,
                        t.specularColor.value.copy(e.specularColor),
                        e.specularColorMap && (t.specularColorMap.value = e.specularColorMap,
                        n(e.specularColorMap, t.specularColorMapTransform)),
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap,
                        n(e.specularIntensityMap, t.specularIntensityMapTransform))
                    }(t, r, a)) : r.isMeshMatcapMaterial ? (i(t, r),
                    function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap)
                    }(t, r)) : r.isMeshDepthMaterial ? i(t, r) : r.isMeshDistanceMaterial ? (i(t, r),
                    function(t, n) {
                        const i = e.get(n).light;
                        t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                        t.nearDistance.value = i.shadow.camera.near,
                        t.farDistance.value = i.shadow.camera.far
                    }(t, r)) : r.isMeshNormalMaterial ? i(t, r) : r.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        e.map && (t.map.value = e.map,
                        n(e.map, t.mapTransform))
                    }(t, r),
                    r.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, r)) : r.isPointsMaterial ? function(t, e, i, r) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * i,
                        t.scale.value = .5 * r,
                        e.map && (t.map.value = e.map,
                        n(e.map, t.uvTransform)),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap,
                        n(e.alphaMap, t.alphaMapTransform)),
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r, s, o) : r.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map,
                        n(e.map, t.mapTransform)),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap,
                        n(e.alphaMap, t.alphaMapTransform)),
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                    }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color),
                    t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }
        function ho(t, e, n, i) {
            let r = {}
              , s = {}
              , o = [];
            const a = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function l(t, e, n) {
                const i = t.value;
                if (void 0 === n[e]) {
                    if ("number" == typeof i)
                        n[e] = i;
                    else {
                        const t = Array.isArray(i) ? i : [i]
                          , r = [];
                        for (let e = 0; e < t.length; e++)
                            r.push(t[e].clone());
                        n[e] = r
                    }
                    return !0
                }
                if ("number" == typeof i) {
                    if (n[e] !== i)
                        return n[e] = i,
                        !0
                } else {
                    const t = Array.isArray(n[e]) ? n[e] : [n[e]]
                      , r = Array.isArray(i) ? i : [i];
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        if (!1 === n.equals(r[e]))
                            return n.copy(r[e]),
                            !0
                    }
                }
                return !1
            }
            function c(t) {
                const e = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof t ? (e.boundary = 4,
                e.storage = 4) : t.isVector2 ? (e.boundary = 8,
                e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16,
                e.storage = 12) : t.isVector4 ? (e.boundary = 16,
                e.storage = 16) : t.isMatrix3 ? (e.boundary = 48,
                e.storage = 48) : t.isMatrix4 ? (e.boundary = 64,
                e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t),
                e
            }
            function u(e) {
                const n = e.target;
                n.removeEventListener("dispose", u);
                const i = o.indexOf(n.__bindingPointIndex);
                o.splice(i, 1),
                t.deleteBuffer(r[n.id]),
                delete r[n.id],
                delete s[n.id]
            }
            return {
                bind: function(t, e) {
                    const n = e.program;
                    i.uniformBlockBinding(t, n)
                },
                update: function(n, h) {
                    let d = r[n.id];
                    void 0 === d && (function(t) {
                        const e = t.uniforms;
                        let n = 0;
                        let i = 0;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t]
                              , s = {
                                boundary: 0,
                                storage: 0
                            }
                              , o = Array.isArray(r.value) ? r.value : [r.value];
                            for (let t = 0, e = o.length; t < e; t++) {
                                const e = c(o[t]);
                                s.boundary += e.boundary,
                                s.storage += e.storage
                            }
                            r.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT),
                            r.__offset = n,
                            t > 0 && (i = n % 16,
                            0 !== i && 16 - i - s.boundary < 0 && (n += 16 - i,
                            r.__offset = n)),
                            n += s.storage
                        }
                        i = n % 16,
                        i > 0 && (n += 16 - i),
                        t.__size = n,
                        t.__cache = {}
                    }(n),
                    d = function(e) {
                        const n = function() {
                            for (let t = 0; t < a; t++)
                                if (-1 === o.indexOf(t))
                                    return o.push(t),
                                    t;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        e.__bindingPointIndex = n;
                        const i = t.createBuffer()
                          , r = e.__size
                          , s = e.usage;
                        return t.bindBuffer(t.UNIFORM_BUFFER, i),
                        t.bufferData(t.UNIFORM_BUFFER, r, s),
                        t.bindBuffer(t.UNIFORM_BUFFER, null),
                        t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                        i
                    }(n),
                    r[n.id] = d,
                    n.addEventListener("dispose", u));
                    const p = h.program;
                    i.updateUBOMapping(n, p);
                    const f = e.render.frame;
                    s[n.id] !== f && (function(e) {
                        const n = r[e.id]
                          , i = e.uniforms
                          , s = e.__cache;
                        t.bindBuffer(t.UNIFORM_BUFFER, n);
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            if (!0 === l(n, e, s)) {
                                const e = n.__offset
                                  , i = Array.isArray(n.value) ? n.value : [n.value];
                                let r = 0;
                                for (let s = 0; s < i.length; s++) {
                                    const o = i[s]
                                      , a = c(o);
                                    "number" == typeof o ? (n.__data[0] = o,
                                    t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data)) : o.isMatrix3 ? (n.__data[0] = o.elements[0],
                                    n.__data[1] = o.elements[1],
                                    n.__data[2] = o.elements[2],
                                    n.__data[3] = o.elements[0],
                                    n.__data[4] = o.elements[3],
                                    n.__data[5] = o.elements[4],
                                    n.__data[6] = o.elements[5],
                                    n.__data[7] = o.elements[0],
                                    n.__data[8] = o.elements[6],
                                    n.__data[9] = o.elements[7],
                                    n.__data[10] = o.elements[8],
                                    n.__data[11] = o.elements[0]) : (o.toArray(n.__data, r),
                                    r += a.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data)
                            }
                        }
                        t.bindBuffer(t.UNIFORM_BUFFER, null)
                    }(n),
                    s[n.id] = f)
                },
                dispose: function() {
                    for (const e in r)
                        t.deleteBuffer(r[e]);
                    o = [],
                    r = {},
                    s = {}
                }
            }
        }
        class po {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {canvas: e=Ht(), context: n=null, depth: i=!0, stencil: s=!0, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1} = t;
                let p;
                this.isWebGLRenderer = !0,
                p = null !== n ? n.getContextAttributes().alpha : o;
                const f = new Uint32Array(4)
                  , A = new Int32Array(4);
                let g = null
                  , m = null;
                const v = []
                  , y = [];
                this.domElement = e,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = lt,
                this._useLegacyLights = !1,
                this.toneMapping = d,
                this.toneMappingExposure = 1;
                const _ = this;
                let E = !1
                  , b = 0
                  , x = 0
                  , w = null
                  , S = -1
                  , C = null;
                const M = new se
                  , I = new se;
                let T = null;
                const F = new Ln(0);
                let Q = 0
                  , k = e.width
                  , G = e.height
                  , H = 1
                  , z = null
                  , V = null;
                const W = new se(0,0,k,G)
                  , q = new se(0,0,k,G);
                let j = !1;
                const X = new Pi;
                let Y = !1
                  , K = !1
                  , J = null;
                const $ = new Ge
                  , Z = new Nt
                  , tt = new he
                  , et = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function nt() {
                    return null === w ? H : 1
                }
                let it, rt, st, ot, at, ut, ht, dt, pt, ft, At, gt, mt, vt, yt, _t, Et, bt, xt, wt, St, Ct, Mt, It, Tt = n;
                function Bt(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i]
                          , s = e.getContext(r, n);
                        if (null !== s)
                            return s
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: !0,
                        depth: i,
                        stencil: s,
                        antialias: a,
                        premultipliedAlpha: l,
                        preserveDrawingBuffer: c,
                        powerPreference: u,
                        failIfMajorPerformanceCaveat: h
                    };
                    if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r${r}`),
                    e.addEventListener("webglcontextlost", Pt, !1),
                    e.addEventListener("webglcontextrestored", Ut, !1),
                    e.addEventListener("webglcontextcreationerror", Ot, !1),
                    null === Tt) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === _.isWebGL1Renderer && e.shift(),
                        Tt = Bt(e, t),
                        null === Tt)
                            throw Bt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" != typeof WebGLRenderingContext && Tt instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                    void 0 === Tt.getShaderPrecisionFormat && (Tt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    )
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message),
                    t
                }
                function Rt() {
                    it = new lr(Tt),
                    rt = new Wi(Tt,it,t),
                    it.init(rt),
                    Ct = new io(Tt,it,rt),
                    st = new eo(Tt,it,rt),
                    ot = new hr(Tt),
                    at = new Gs,
                    ut = new no(Tt,it,st,at,rt,Ct,ot),
                    ht = new ji(_),
                    dt = new ar(_),
                    pt = new Oi(Tt,rt),
                    Mt = new zi(Tt,it,pt,rt),
                    ft = new cr(Tt,pt,ot,Mt),
                    At = new Ar(Tt,ft,pt,ot),
                    xt = new fr(Tt,rt,ut),
                    _t = new qi(at),
                    gt = new ks(_,ht,dt,it,rt,Mt,_t),
                    mt = new uo(_,at),
                    vt = new Ws,
                    yt = new Js(it,rt),
                    bt = new Hi(_,ht,dt,st,At,p,l),
                    Et = new to(_,At,rt),
                    It = new ho(Tt,ot,rt,st),
                    wt = new Vi(Tt,it,ot,rt),
                    St = new ur(Tt,it,ot,rt),
                    ot.programs = gt.programs,
                    _.capabilities = rt,
                    _.extensions = it,
                    _.properties = at,
                    _.renderLists = vt,
                    _.shadowMap = Et,
                    _.state = st,
                    _.info = ot
                }
                Rt();
                const Lt = new co(_,Tt);
                function Pt(t) {
                    t.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    E = !0
                }
                function Ut() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    E = !1;
                    const t = ot.autoReset
                      , e = Et.enabled
                      , n = Et.autoUpdate
                      , i = Et.needsUpdate
                      , r = Et.type;
                    Rt(),
                    ot.autoReset = t,
                    Et.enabled = e,
                    Et.autoUpdate = n,
                    Et.needsUpdate = i,
                    Et.type = r
                }
                function Ot(t) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
                }
                function Ft(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", Ft),
                    function(t) {
                        (function(t) {
                            const e = at.get(t).programs;
                            void 0 !== e && (e.forEach((function(t) {
                                gt.releaseProgram(t)
                            }
                            )),
                            t.isShaderMaterial && gt.releaseShaderCache(t))
                        }
                        )(t),
                        at.remove(t)
                    }(e)
                }
                this.xr = Lt,
                this.getContext = function() {
                    return Tt
                }
                ,
                this.getContextAttributes = function() {
                    return Tt.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const t = it.get("WEBGL_lose_context");
                    t && t.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const t = it.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return H
                }
                ,
                this.setPixelRatio = function(t) {
                    void 0 !== t && (H = t,
                    this.setSize(k, G, !1))
                }
                ,
                this.getSize = function(t) {
                    return t.set(k, G)
                }
                ,
                this.setSize = function(t, n) {
                    let i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    Lt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (k = t,
                    G = n,
                    e.width = Math.floor(t * H),
                    e.height = Math.floor(n * H),
                    !0 === i && (e.style.width = t + "px",
                    e.style.height = n + "px"),
                    this.setViewport(0, 0, t, n))
                }
                ,
                this.getDrawingBufferSize = function(t) {
                    return t.set(k * H, G * H).floor()
                }
                ,
                this.setDrawingBufferSize = function(t, n, i) {
                    k = t,
                    G = n,
                    H = i,
                    e.width = Math.floor(t * i),
                    e.height = Math.floor(n * i),
                    this.setViewport(0, 0, t, n)
                }
                ,
                this.getCurrentViewport = function(t) {
                    return t.copy(M)
                }
                ,
                this.getViewport = function(t) {
                    return t.copy(W)
                }
                ,
                this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? W.set(t.x, t.y, t.z, t.w) : W.set(t, e, n, i),
                    st.viewport(M.copy(W).multiplyScalar(H).floor())
                }
                ,
                this.getScissor = function(t) {
                    return t.copy(q)
                }
                ,
                this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, n, i),
                    st.scissor(I.copy(q).multiplyScalar(H).floor())
                }
                ,
                this.getScissorTest = function() {
                    return j
                }
                ,
                this.setScissorTest = function(t) {
                    st.setScissorTest(j = t)
                }
                ,
                this.setOpaqueSort = function(t) {
                    z = t
                }
                ,
                this.setTransparentSort = function(t) {
                    V = t
                }
                ,
                this.getClearColor = function(t) {
                    return t.copy(bt.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    bt.setClearColor.apply(bt, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return bt.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    bt.setClearAlpha.apply(bt, arguments)
                }
                ,
                this.clear = function() {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                      , e = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                      , n = 0;
                    if (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) {
                        let t = !1;
                        if (null !== w) {
                            const e = w.texture.format;
                            t = 1033 === e || 1031 === e || 1029 === e
                        }
                        if (t) {
                            const t = w.texture.type
                              , e = t === R || t === D || t === L || t === O || 1017 === t || 1018 === t
                              , n = bt.getClearColor()
                              , i = bt.getClearAlpha()
                              , r = n.r
                              , s = n.g
                              , o = n.b;
                            e ? (f[0] = r,
                            f[1] = s,
                            f[2] = o,
                            f[3] = i,
                            Tt.clearBufferuiv(Tt.COLOR, 0, f)) : (A[0] = r,
                            A[1] = s,
                            A[2] = o,
                            A[3] = i,
                            Tt.clearBufferiv(Tt.COLOR, 0, A))
                        } else
                            n |= Tt.COLOR_BUFFER_BIT
                    }
                    t && (n |= Tt.DEPTH_BUFFER_BIT),
                    e && (n |= Tt.STENCIL_BUFFER_BIT),
                    Tt.clear(n)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    e.removeEventListener("webglcontextlost", Pt, !1),
                    e.removeEventListener("webglcontextrestored", Ut, !1),
                    e.removeEventListener("webglcontextcreationerror", Ot, !1),
                    vt.dispose(),
                    yt.dispose(),
                    at.dispose(),
                    ht.dispose(),
                    dt.dispose(),
                    At.dispose(),
                    Mt.dispose(),
                    It.dispose(),
                    gt.dispose(),
                    Lt.dispose(),
                    Lt.removeEventListener("sessionstart", kt),
                    Lt.removeEventListener("sessionend", Gt),
                    J && (J.dispose(),
                    J = null),
                    zt.stop()
                }
                ,
                this.renderBufferDirect = function(t, e, n, i, r, s) {
                    null === e && (e = et);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0
                      , a = function(t, e, n, i, r) {
                        !0 !== e.isScene && (e = et),
                        ut.resetTextureUnits();
                        const s = e.fog
                          , o = i.isMeshStandardMaterial ? e.environment : null
                          , a = null === w ? _.outputColorSpace : !0 === w.isXRRenderTarget ? w.texture.colorSpace : ct
                          , l = (i.isMeshStandardMaterial ? dt : ht).get(i.envMap || o)
                          , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                          , u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                          , h = !!n.morphAttributes.position
                          , p = !!n.morphAttributes.normal
                          , f = !!n.morphAttributes.color;
                        let A = d;
                        i.toneMapped && (null !== w && !0 !== w.isXRRenderTarget || (A = _.toneMapping));
                        const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                          , v = void 0 !== g ? g.length : 0
                          , y = at.get(i)
                          , E = m.state.lights;
                        if (!0 === Y && (!0 === K || t !== C)) {
                            const e = t === C && i.id === S;
                            _t.setState(i, t, e)
                        }
                        let b = !1;
                        i.version === y.__version ? y.needsLights && y.lightsStateVersion !== E.state.version || y.outputColorSpace !== a || r.isInstancedMesh && !1 === y.instancing ? b = !0 : r.isInstancedMesh || !0 !== y.instancing ? r.isSkinnedMesh && !1 === y.skinning ? b = !0 : r.isSkinnedMesh || !0 !== y.skinning ? r.isInstancedMesh && !0 === y.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === y.instancingColor && null !== r.instanceColor || y.envMap !== l || !0 === i.fog && y.fog !== s ? b = !0 : void 0 === y.numClippingPlanes || y.numClippingPlanes === _t.numPlanes && y.numIntersection === _t.numIntersection ? (y.vertexAlphas !== c || y.vertexTangents !== u || y.morphTargets !== h || y.morphNormals !== p || y.morphColors !== f || y.toneMapping !== A || !0 === rt.isWebGL2 && y.morphTargetsCount !== v) && (b = !0) : b = !0 : b = !0 : b = !0 : (b = !0,
                        y.__version = i.version);
                        let x = y.currentProgram;
                        !0 === b && (x = Xt(i, e, r));
                        let M = !1
                          , I = !1
                          , T = !1;
                        const B = x.getUniforms()
                          , R = y.uniforms;
                        if (st.useProgram(x.program) && (M = !0,
                        I = !0,
                        T = !0),
                        i.id !== S && (S = i.id,
                        I = !0),
                        M || C !== t) {
                            B.setValue(Tt, "projectionMatrix", t.projectionMatrix),
                            B.setValue(Tt, "viewMatrix", t.matrixWorldInverse);
                            const e = B.map.cameraPosition;
                            void 0 !== e && e.setValue(Tt, tt.setFromMatrixPosition(t.matrixWorld)),
                            rt.logarithmicDepthBuffer && B.setValue(Tt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && B.setValue(Tt, "isOrthographic", !0 === t.isOrthographicCamera),
                            C !== t && (C = t,
                            I = !0,
                            T = !0)
                        }
                        if (r.isSkinnedMesh) {
                            B.setOptional(Tt, r, "bindMatrix"),
                            B.setOptional(Tt, r, "bindMatrixInverse");
                            const t = r.skeleton;
                            t && (rt.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(),
                            B.setValue(Tt, "boneTexture", t.boneTexture, ut),
                            B.setValue(Tt, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const L = n.morphAttributes;
                        var D, P;
                        if ((void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === rt.isWebGL2) && xt.update(r, n, x),
                        (I || y.receiveShadow !== r.receiveShadow) && (y.receiveShadow = r.receiveShadow,
                        B.setValue(Tt, "receiveShadow", r.receiveShadow)),
                        i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l,
                        R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1),
                        I && (B.setValue(Tt, "toneMappingExposure", _.toneMappingExposure),
                        y.needsLights && (P = T,
                        (D = R).ambientLightColor.needsUpdate = P,
                        D.lightProbe.needsUpdate = P,
                        D.directionalLights.needsUpdate = P,
                        D.directionalLightShadows.needsUpdate = P,
                        D.pointLights.needsUpdate = P,
                        D.pointLightShadows.needsUpdate = P,
                        D.spotLights.needsUpdate = P,
                        D.spotLightShadows.needsUpdate = P,
                        D.rectAreaLights.needsUpdate = P,
                        D.hemisphereLights.needsUpdate = P),
                        s && !0 === i.fog && mt.refreshFogUniforms(R, s),
                        mt.refreshMaterialUniforms(R, i, H, G, J),
                        ys.upload(Tt, y.uniformsList, R, ut)),
                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ys.upload(Tt, y.uniformsList, R, ut),
                        i.uniformsNeedUpdate = !1),
                        i.isSpriteMaterial && B.setValue(Tt, "center", r.center),
                        B.setValue(Tt, "modelViewMatrix", r.modelViewMatrix),
                        B.setValue(Tt, "normalMatrix", r.normalMatrix),
                        B.setValue(Tt, "modelMatrix", r.matrixWorld),
                        i.isShaderMaterial || i.isRawShaderMaterial) {
                            const t = i.uniformsGroups;
                            for (let e = 0, n = t.length; e < n; e++)
                                if (rt.isWebGL2) {
                                    const n = t[e];
                                    It.update(n, x),
                                    It.bind(n, x)
                                } else
                                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return x
                    }(t, e, n, i, r);
                    st.setMaterial(i, o);
                    let l = n.index
                      , c = 1;
                    if (!0 === i.wireframe) {
                        if (l = ft.getWireframeAttribute(n),
                        void 0 === l)
                            return;
                        c = 2
                    }
                    const u = n.drawRange
                      , h = n.attributes.position;
                    let p = u.start * c
                      , f = (u.start + u.count) * c;
                    null !== s && (p = Math.max(p, s.start * c),
                    f = Math.min(f, (s.start + s.count) * c)),
                    null !== l ? (p = Math.max(p, 0),
                    f = Math.min(f, l.count)) : null != h && (p = Math.max(p, 0),
                    f = Math.min(f, h.count));
                    const A = f - p;
                    if (A < 0 || A === 1 / 0)
                        return;
                    let g;
                    Mt.setup(r, i, a, n, l);
                    let v = wt;
                    if (null !== l && (g = pt.get(l),
                    v = St,
                    v.setIndex(g)),
                    r.isMesh)
                        !0 === i.wireframe ? (st.setLineWidth(i.wireframeLinewidth * nt()),
                        v.setMode(Tt.LINES)) : v.setMode(Tt.TRIANGLES);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1),
                        st.setLineWidth(t * nt()),
                        r.isLineSegments ? v.setMode(Tt.LINES) : r.isLineLoop ? v.setMode(Tt.LINE_LOOP) : v.setMode(Tt.LINE_STRIP)
                    } else
                        r.isPoints ? v.setMode(Tt.POINTS) : r.isSprite && v.setMode(Tt.TRIANGLES);
                    if (r.isInstancedMesh)
                        v.renderInstances(p, A, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , e = Math.min(n.instanceCount, t);
                        v.renderInstances(p, A, e)
                    } else
                        v.render(p, A)
                }
                ,
                this.compile = function(t, e) {
                    function n(t, e, n) {
                        !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass ? (t.side = 1,
                        t.needsUpdate = !0,
                        Xt(t, e, n),
                        t.side = 0,
                        t.needsUpdate = !0,
                        Xt(t, e, n),
                        t.side = 2) : Xt(t, e, n)
                    }
                    m = yt.get(t),
                    m.init(),
                    y.push(m),
                    t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (m.pushLight(t),
                        t.castShadow && m.pushShadow(t))
                    }
                    )),
                    m.setupLights(_._useLegacyLights),
                    t.traverse((function(e) {
                        const i = e.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let r = 0; r < i.length; r++)
                                    n(i[r], t, e);
                            else
                                n(i, t, e)
                    }
                    )),
                    y.pop(),
                    m = null
                }
                ;
                let Qt = null;
                function kt() {
                    zt.stop()
                }
                function Gt() {
                    zt.start()
                }
                const zt = new Ui;
                function Vt(t, e, n, i) {
                    if (!1 === t.visible)
                        return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup)
                            n = t.renderOrder;
                        else if (t.isLOD)
                            !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight)
                            m.pushLight(t),
                            t.castShadow && m.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || X.intersectsSprite(t)) {
                                i && tt.setFromMatrixPosition(t.matrixWorld).applyMatrix4($);
                                const e = At.update(t)
                                  , r = t.material;
                                r.visible && g.push(t, e, r, n, tt.z, null)
                            }
                        } else if ((t.isMesh || t.isLine || t.isPoints) && (!t.frustumCulled || X.intersectsObject(t))) {
                            const e = At.update(t)
                              , r = t.material;
                            if (i && (void 0 !== t.boundingSphere ? (null === t.boundingSphere && t.computeBoundingSphere(),
                            tt.copy(t.boundingSphere.center)) : (null === e.boundingSphere && e.computeBoundingSphere(),
                            tt.copy(e.boundingSphere.center)),
                            tt.applyMatrix4(t.matrixWorld).applyMatrix4($)),
                            Array.isArray(r)) {
                                const i = e.groups;
                                for (let s = 0, o = i.length; s < o; s++) {
                                    const o = i[s]
                                      , a = r[o.materialIndex];
                                    a && a.visible && g.push(t, e, a, n, tt.z, o)
                                }
                            } else
                                r.visible && g.push(t, e, r, n, tt.z, null)
                        }
                    const r = t.children;
                    for (let t = 0, s = r.length; t < s; t++)
                        Vt(r[t], e, n, i)
                }
                function Wt(t, e, n, i) {
                    const r = t.opaque
                      , s = t.transmissive
                      , o = t.transparent;
                    m.setupLightsView(n),
                    !0 === Y && _t.setGlobalState(_.clippingPlanes, n),
                    s.length > 0 && function(t, e, n, i) {
                        const r = rt.isWebGL2;
                        null === J && (J = new ae(1,1,{
                            generateMipmaps: !0,
                            type: it.has("EXT_color_buffer_half_float") ? U : R,
                            minFilter: B,
                            samples: r ? 4 : 0
                        })),
                        _.getDrawingBufferSize(Z),
                        r ? J.setSize(Z.x, Z.y) : J.setSize(Dt(Z.x), Dt(Z.y));
                        const s = _.getRenderTarget();
                        _.setRenderTarget(J),
                        _.getClearColor(F),
                        Q = _.getClearAlpha(),
                        Q < 1 && _.setClearColor(16777215, .5),
                        _.clear();
                        const o = _.toneMapping;
                        _.toneMapping = d,
                        qt(t, n, i),
                        ut.updateMultisampleRenderTarget(J),
                        ut.updateRenderTargetMipmap(J);
                        let a = !1;
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t]
                              , s = r.object
                              , o = r.geometry
                              , l = r.material
                              , c = r.group;
                            if (2 === l.side && s.layers.test(i.layers)) {
                                const t = l.side;
                                l.side = 1,
                                l.needsUpdate = !0,
                                jt(s, n, i, o, l, c),
                                l.side = t,
                                l.needsUpdate = !0,
                                a = !0
                            }
                        }
                        !0 === a && (ut.updateMultisampleRenderTarget(J),
                        ut.updateRenderTargetMipmap(J)),
                        _.setRenderTarget(s),
                        _.setClearColor(F, Q),
                        _.toneMapping = o
                    }(r, s, e, n),
                    i && st.viewport(M.copy(i)),
                    r.length > 0 && qt(r, e, n),
                    s.length > 0 && qt(s, e, n),
                    o.length > 0 && qt(o, e, n),
                    st.buffers.depth.setTest(!0),
                    st.buffers.depth.setMask(!0),
                    st.buffers.color.setMask(!0),
                    st.setPolygonOffset(!1)
                }
                function qt(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r]
                          , o = s.object
                          , a = s.geometry
                          , l = null === i ? s.material : i
                          , c = s.group;
                        o.layers.test(n.layers) && jt(o, e, n, a, l, c)
                    }
                }
                function jt(t, e, n, i, r, s) {
                    t.onBeforeRender(_, e, n, i, r, s),
                    t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                    t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                    r.onBeforeRender(_, e, n, i, t, s),
                    !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass ? (r.side = 1,
                    r.needsUpdate = !0,
                    _.renderBufferDirect(n, e, i, r, t, s),
                    r.side = 0,
                    r.needsUpdate = !0,
                    _.renderBufferDirect(n, e, i, r, t, s),
                    r.side = 2) : _.renderBufferDirect(n, e, i, r, t, s),
                    t.onAfterRender(_, e, n, i, r, s)
                }
                function Xt(t, e, n) {
                    !0 !== e.isScene && (e = et);
                    const i = at.get(t)
                      , r = m.state.lights
                      , s = m.state.shadowsArray
                      , o = r.state.version
                      , a = gt.getParameters(t, r.state, s, e, n)
                      , l = gt.getProgramCacheKey(a);
                    let c = i.programs;
                    i.environment = t.isMeshStandardMaterial ? e.environment : null,
                    i.fog = e.fog,
                    i.envMap = (t.isMeshStandardMaterial ? dt : ht).get(t.envMap || i.environment),
                    void 0 === c && (t.addEventListener("dispose", Ft),
                    c = new Map,
                    i.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (i.currentProgram === u && i.lightsStateVersion === o)
                            return Yt(t, a),
                            u
                    } else
                        a.uniforms = gt.getUniforms(t),
                        t.onBuild(n, a, _),
                        t.onBeforeCompile(a, _),
                        u = gt.acquireProgram(a, l),
                        c.set(l, u),
                        i.uniforms = a.uniforms;
                    const h = i.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = _t.uniform),
                    Yt(t, a),
                    i.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t),
                    i.lightsStateVersion = o,
                    i.needsLights && (h.ambientLightColor.value = r.state.ambient,
                    h.lightProbe.value = r.state.probe,
                    h.directionalLights.value = r.state.directional,
                    h.directionalLightShadows.value = r.state.directionalShadow,
                    h.spotLights.value = r.state.spot,
                    h.spotLightShadows.value = r.state.spotShadow,
                    h.rectAreaLights.value = r.state.rectArea,
                    h.ltc_1.value = r.state.rectAreaLTC1,
                    h.ltc_2.value = r.state.rectAreaLTC2,
                    h.pointLights.value = r.state.point,
                    h.pointLightShadows.value = r.state.pointShadow,
                    h.hemisphereLights.value = r.state.hemi,
                    h.directionalShadowMap.value = r.state.directionalShadowMap,
                    h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    h.spotShadowMap.value = r.state.spotShadowMap,
                    h.spotLightMatrix.value = r.state.spotLightMatrix,
                    h.spotLightMap.value = r.state.spotLightMap,
                    h.pointShadowMap.value = r.state.pointShadowMap,
                    h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const d = u.getUniforms()
                      , p = ys.seqWithValue(d.seq, h);
                    return i.currentProgram = u,
                    i.uniformsList = p,
                    u
                }
                function Yt(t, e) {
                    const n = at.get(t);
                    n.outputColorSpace = e.outputColorSpace,
                    n.instancing = e.instancing,
                    n.instancingColor = e.instancingColor,
                    n.skinning = e.skinning,
                    n.morphTargets = e.morphTargets,
                    n.morphNormals = e.morphNormals,
                    n.morphColors = e.morphColors,
                    n.morphTargetsCount = e.morphTargetsCount,
                    n.numClippingPlanes = e.numClippingPlanes,
                    n.numIntersection = e.numClipIntersection,
                    n.vertexAlphas = e.vertexAlphas,
                    n.vertexTangents = e.vertexTangents,
                    n.toneMapping = e.toneMapping
                }
                zt.setAnimationLoop((function(t) {
                    Qt && Qt(t)
                }
                )),
                "undefined" != typeof self && zt.setContext(self),
                this.setAnimationLoop = function(t) {
                    Qt = t,
                    Lt.setAnimationLoop(t),
                    null === t ? zt.stop() : zt.start()
                }
                ,
                Lt.addEventListener("sessionstart", kt),
                Lt.addEventListener("sessionend", Gt),
                this.render = function(t, e) {
                    if (void 0 !== e && !0 !== e.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === E)
                        return;
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    !0 === Lt.enabled && !0 === Lt.isPresenting && (!0 === Lt.cameraAutoUpdate && Lt.updateCamera(e),
                    e = Lt.getCamera()),
                    !0 === t.isScene && t.onBeforeRender(_, t, e, w),
                    m = yt.get(t, y.length),
                    m.init(),
                    y.push(m),
                    $.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                    X.setFromProjectionMatrix($),
                    K = this.localClippingEnabled,
                    Y = _t.init(this.clippingPlanes, K),
                    g = vt.get(t, v.length),
                    g.init(),
                    v.push(g),
                    Vt(t, e, 0, _.sortObjects),
                    g.finish(),
                    !0 === _.sortObjects && g.sort(z, V),
                    this.info.render.frame++,
                    !0 === Y && _t.beginShadows();
                    const n = m.state.shadowsArray;
                    if (Et.render(n, t, e),
                    !0 === Y && _t.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    bt.render(g, t),
                    m.setupLights(_._useLegacyLights),
                    e.isArrayCamera) {
                        const n = e.cameras;
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            Wt(g, t, i, i.viewport)
                        }
                    } else
                        Wt(g, t, e);
                    null !== w && (ut.updateMultisampleRenderTarget(w),
                    ut.updateRenderTargetMipmap(w)),
                    !0 === t.isScene && t.onAfterRender(_, t, e),
                    Mt.resetDefaultState(),
                    S = -1,
                    C = null,
                    y.pop(),
                    m = y.length > 0 ? y[y.length - 1] : null,
                    v.pop(),
                    g = v.length > 0 ? v[v.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return b
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return x
                }
                ,
                this.getRenderTarget = function() {
                    return w
                }
                ,
                this.setRenderTargetTextures = function(t, e, n) {
                    at.get(t.texture).__webglTexture = e,
                    at.get(t.depthTexture).__webglTexture = n;
                    const i = at.get(t);
                    i.__hasExternalTextures = !0,
                    i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n,
                    i.__autoAllocateDepthBuffer || !0 === it.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    i.__useRenderToTexture = !1))
                }
                ,
                this.setRenderTargetFramebuffer = function(t, e) {
                    const n = at.get(t);
                    n.__webglFramebuffer = e,
                    n.__useDefaultFramebuffer = void 0 === e
                }
                ,
                this.setRenderTarget = function(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                      , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    w = t,
                    b = e,
                    x = n;
                    let i = !0
                      , r = null
                      , s = !1
                      , o = !1;
                    if (t) {
                        const a = at.get(t);
                        void 0 !== a.__useDefaultFramebuffer ? (st.bindFramebuffer(Tt.FRAMEBUFFER, null),
                        i = !1) : void 0 === a.__webglFramebuffer ? ut.setupRenderTarget(t) : a.__hasExternalTextures && ut.rebindTextures(t, at.get(t.texture).__webglTexture, at.get(t.depthTexture).__webglTexture);
                        const l = t.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                        const c = at.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (r = Array.isArray(c[e]) ? c[e][n] : c[e],
                        s = !0) : r = rt.isWebGL2 && t.samples > 0 && !1 === ut.useMultisampledRTT(t) ? at.get(t).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                        M.copy(t.viewport),
                        I.copy(t.scissor),
                        T = t.scissorTest
                    } else
                        M.copy(W).multiplyScalar(H).floor(),
                        I.copy(q).multiplyScalar(H).floor(),
                        T = j;
                    if (st.bindFramebuffer(Tt.FRAMEBUFFER, r) && rt.drawBuffers && i && st.drawBuffers(t, r),
                    st.viewport(M),
                    st.scissor(I),
                    st.setScissorTest(T),
                    s) {
                        const i = at.get(t.texture);
                        Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                    } else if (o) {
                        const i = at.get(t.texture)
                          , r = e || 0;
                        Tt.framebufferTextureLayer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    S = -1
                }
                ,
                this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                    if (!t || !t.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = at.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]),
                    a) {
                        st.bindFramebuffer(Tt.FRAMEBUFFER, a);
                        try {
                            const o = t.texture
                              , a = o.format
                              , l = o.type;
                            if (a !== N && Ct.convert(a) !== Tt.getParameter(Tt.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === U && (it.has("EXT_color_buffer_half_float") || rt.isWebGL2 && it.has("EXT_color_buffer_float"));
                            if (!(l === R || Ct.convert(l) === Tt.getParameter(Tt.IMPLEMENTATION_COLOR_READ_TYPE) || l === P && (rt.isWebGL2 || it.has("OES_texture_float") || it.has("WEBGL_color_buffer_float")) || c))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Tt.readPixels(e, n, i, r, Ct.convert(a), Ct.convert(l), s)
                        } finally {
                            const t = null !== w ? at.get(w).__webglFramebuffer : null;
                            st.bindFramebuffer(Tt.FRAMEBUFFER, t)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    const i = Math.pow(2, -n)
                      , r = Math.floor(e.image.width * i)
                      , s = Math.floor(e.image.height * i);
                    ut.setTexture2D(e, 0),
                    Tt.copyTexSubImage2D(Tt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
                    st.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(t, e, n) {
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                    const r = e.image.width
                      , s = e.image.height
                      , o = Ct.convert(n.format)
                      , a = Ct.convert(n.type);
                    ut.setTexture2D(n, 0),
                    Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, n.flipY),
                    Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
                    Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, n.unpackAlignment),
                    e.isDataTexture ? Tt.texSubImage2D(Tt.TEXTURE_2D, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? Tt.compressedTexSubImage2D(Tt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : Tt.texSubImage2D(Tt.TEXTURE_2D, i, t.x, t.y, o, a, e.image),
                    0 === i && n.generateMipmaps && Tt.generateMipmap(Tt.TEXTURE_2D),
                    st.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(t, e, n, i) {
                    let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    if (_.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const s = t.max.x - t.min.x + 1
                      , o = t.max.y - t.min.y + 1
                      , a = t.max.z - t.min.z + 1
                      , l = Ct.convert(i.format)
                      , c = Ct.convert(i.type);
                    let u;
                    if (i.isData3DTexture)
                        ut.setTexture3D(i, 0),
                        u = Tt.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        ut.setTexture2DArray(i, 0),
                        u = Tt.TEXTURE_2D_ARRAY
                    }
                    Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, i.flipY),
                    Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                    Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const h = Tt.getParameter(Tt.UNPACK_ROW_LENGTH)
                      , d = Tt.getParameter(Tt.UNPACK_IMAGE_HEIGHT)
                      , p = Tt.getParameter(Tt.UNPACK_SKIP_PIXELS)
                      , f = Tt.getParameter(Tt.UNPACK_SKIP_ROWS)
                      , A = Tt.getParameter(Tt.UNPACK_SKIP_IMAGES)
                      , g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    Tt.pixelStorei(Tt.UNPACK_ROW_LENGTH, g.width),
                    Tt.pixelStorei(Tt.UNPACK_IMAGE_HEIGHT, g.height),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_PIXELS, t.min.x),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_ROWS, t.min.y),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_IMAGES, t.min.z),
                    n.isDataTexture || n.isData3DTexture ? Tt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                    Tt.compressedTexSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, g.data)) : Tt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g),
                    Tt.pixelStorei(Tt.UNPACK_ROW_LENGTH, h),
                    Tt.pixelStorei(Tt.UNPACK_IMAGE_HEIGHT, d),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_PIXELS, p),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_ROWS, f),
                    Tt.pixelStorei(Tt.UNPACK_SKIP_IMAGES, A),
                    0 === r && i.generateMipmaps && Tt.generateMipmap(u),
                    st.unbindTexture()
                }
                ,
                this.initTexture = function(t) {
                    t.isCubeTexture ? ut.setTextureCube(t, 0) : t.isData3DTexture ? ut.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? ut.setTexture2DArray(t, 0) : ut.setTexture2D(t, 0),
                    st.unbindTexture()
                }
                ,
                this.resetState = function() {
                    b = 0,
                    x = 0,
                    w = null,
                    st.reset(),
                    Mt.reset()
                }
                ,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return _t
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(t) {
                this._outputColorSpace = t;
                const e = this.getContext();
                e.drawingBufferColorSpace = t === ut ? "display-p3" : "srgb",
                e.unpackColorSpace = Yt.workingColorSpace === ht ? "display-p3" : "srgb"
            }
            get physicallyCorrectLights() {
                return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                !this.useLegacyLights
            }
            set physicallyCorrectLights(t) {
                console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                this.useLegacyLights = !t
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace === lt ? ot : 3e3
            }
            set outputEncoding(t) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace = t === ot ? lt : ct
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(t) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = t
            }
        }
        (class extends po {
        }
        ).prototype.isWebGL1Renderer = !0;
        class fo extends pn {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                this.backgroundBlurriness = t.backgroundBlurriness,
                this.backgroundIntensity = t.backgroundIntensity,
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity),
                e
            }
        }
        class Ao {
            constructor(t, e) {
                this.isInterleavedBuffer = !0,
                this.array = t,
                this.stride = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.usage = mt,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = Mt()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array),
                this.count = t.count,
                this.stride = t.stride,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.stride,
                n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            set(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(t, e),
                this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Mt()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(e,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Mt()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const go = new he;
        class mo {
            constructor(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = t,
                this.itemSize = e,
                this.offset = n,
                this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++)
                    go.fromBufferAttribute(this, e),
                    go.applyMatrix4(t),
                    this.setXYZ(e, go.x, go.y, go.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    go.fromBufferAttribute(this, e),
                    go.applyNormalMatrix(t),
                    this.setXYZ(e, go.x, go.y, go.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    go.fromBufferAttribute(this, e),
                    go.transformDirection(t),
                    this.setXYZ(e, go.x, go.y, go.z);
                return this
            }
            setX(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.data.array[t * this.data.stride + this.offset] = e,
                this
            }
            setY(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            }
            setZ(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            }
            setW(t, e) {
                return this.normalized && (e = Ut(e, this.array)),
                this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            }
            getX(t) {
                let e = this.data.array[t * this.data.stride + this.offset];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            getY(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 1];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            getZ(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 2];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            getW(t) {
                let e = this.data.array[t * this.data.stride + this.offset + 3];
                return this.normalized && (e = Pt(e, this.array)),
                e
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array)),
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array),
                i = Ut(i, this.array)),
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset,
                this.normalized && (e = Ut(e, this.array),
                n = Ut(n, this.array),
                i = Ut(i, this.array),
                r = Ut(r, this.array)),
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this.data.array[t + 3] = r,
                this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return new Qn(new this.array.constructor(t),this.itemSize,this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new mo(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const vo = new he
          , yo = new se
          , _o = new se
          , Eo = new he
          , bo = new Ge
          , xo = new he
          , wo = new Le
          , So = new Ge
          , Co = new ke;
        class Mo extends fi {
            constructor(t, e) {
                super(t, e),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new Ge,
                this.bindMatrixInverse = new Ge,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const t = this.geometry;
                null === this.boundingBox && (this.boundingBox = new fe),
                this.boundingBox.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++)
                    xo.fromBufferAttribute(e, t),
                    this.applyBoneTransform(t, xo),
                    this.boundingBox.expandByPoint(xo)
            }
            computeBoundingSphere() {
                const t = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Le),
                this.boundingSphere.makeEmpty();
                const e = t.getAttribute("position");
                for (let t = 0; t < e.count; t++)
                    xo.fromBufferAttribute(e, t),
                    this.applyBoneTransform(t, xo),
                    this.boundingSphere.expandByPoint(xo)
            }
            copy(t, e) {
                return super.copy(t, e),
                this.bindMode = t.bindMode,
                this.bindMatrix.copy(t.bindMatrix),
                this.bindMatrixInverse.copy(t.bindMatrixInverse),
                this.skeleton = t.skeleton,
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                this
            }
            raycast(t, e) {
                const n = this.material
                  , i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                wo.copy(this.boundingSphere),
                wo.applyMatrix4(i),
                !1 !== t.ray.intersectsSphere(wo) && (So.copy(i).invert(),
                Co.copy(t.ray).applyMatrix4(So),
                null !== this.boundingBox && !1 === Co.intersectsBox(this.boundingBox) || this._computeIntersections(t, e, Co)))
            }
            getVertexPosition(t, e) {
                return super.getVertexPosition(t, e),
                this.applyBoneTransform(t, e),
                e
            }
            bind(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                e = this.matrixWorld),
                this.bindMatrix.copy(e),
                this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new se
                  , e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.fromBufferAttribute(e, n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                    e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(t, e) {
                const n = this.skeleton
                  , i = this.geometry;
                yo.fromBufferAttribute(i.attributes.skinIndex, t),
                _o.fromBufferAttribute(i.attributes.skinWeight, t),
                vo.copy(e).applyMatrix4(this.bindMatrix),
                e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = _o.getComponent(t);
                    if (0 !== i) {
                        const r = yo.getComponent(t);
                        bo.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        e.addScaledVector(Eo.copy(vo).applyMatrix4(bo), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(t, e) {
                return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
                this.applyBoneTransform(t, e)
            }
        }
        class Io extends pn {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class To extends re {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(null, arguments.length > 5 ? arguments[5] : void 0, arguments.length > 6 ? arguments[6] : void 0, arguments.length > 7 ? arguments[7] : void 0, arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1003, arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 1003, arguments.length > 3 ? arguments[3] : void 0, arguments.length > 4 ? arguments[4] : void 0, arguments.length > 10 ? arguments[10] : void 0, arguments.length > 11 ? arguments[11] : void 0),
                this.isDataTexture = !0,
                this.image = {
                    data: t,
                    width: e,
                    height: n
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Bo = new Ge
          , Ro = new Ge;
        class Lo {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                this.uuid = Mt(),
                this.bones = t.slice(0),
                this.boneInverses = e,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.init()
            }
            init() {
                const t = this.bones
                  , e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length),
                0 === e.length)
                    this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new Ge)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Ge;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                    this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                    e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones
                  , e = this.boneInverses
                  , n = this.boneMatrices
                  , i = this.boneTexture;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i] ? t[i].matrixWorld : Ro;
                    Bo.multiplyMatrices(r, e[i]),
                    Bo.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Lo(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = Lt(t),
                t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new To(e,t,t,N,P);
                return n.needsUpdate = !0,
                this.boneMatrices = e,
                this.boneTexture = n,
                this.boneTextureSize = t,
                this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    const i = t.bones[n];
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                    r = new Io),
                    this.bones.push(r),
                    this.boneInverses.push((new Ge).fromArray(t.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones
                  , n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const s = n[i];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        class Do extends Qn {
            constructor(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(t, e, n),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = i
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute,
                t.isInstancedBufferAttribute = !0,
                t
            }
        }
        const Po = new Ge
          , Uo = new Ge
          , Oo = []
          , No = new fe
          , Fo = new Ge
          , Qo = new fi
          , ko = new Le;
        class Go extends fi {
            constructor(t, e, n) {
                super(t, e),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new Do(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let t = 0; t < n; t++)
                    this.setMatrixAt(t, Fo)
            }
            computeBoundingBox() {
                const t = this.geometry
                  , e = this.count;
                null === this.boundingBox && (this.boundingBox = new fe),
                null === t.boundingBox && t.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let n = 0; n < e; n++)
                    this.getMatrixAt(n, Po),
                    No.copy(t.boundingBox).applyMatrix4(Po),
                    this.boundingBox.union(No)
            }
            computeBoundingSphere() {
                const t = this.geometry
                  , e = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Le),
                null === t.boundingSphere && t.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let n = 0; n < e; n++)
                    this.getMatrixAt(n, Po),
                    ko.copy(t.boundingSphere).applyMatrix4(Po),
                    this.boundingSphere.union(ko)
            }
            copy(t, e) {
                return super.copy(t, e),
                this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                this.count = t.count,
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld
                  , i = this.count;
                if (Qo.geometry = this.geometry,
                Qo.material = this.material,
                void 0 !== Qo.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                ko.copy(this.boundingSphere),
                ko.applyMatrix4(n),
                !1 !== t.ray.intersectsSphere(ko)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Po),
                        Uo.multiplyMatrices(n, Po),
                        Qo.matrixWorld = Uo,
                        Qo.raycast(t, Oo);
                        for (let t = 0, n = Oo.length; t < n; t++) {
                            const n = Oo[t];
                            n.instanceId = r,
                            n.object = this,
                            e.push(n)
                        }
                        Oo.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Do(new Float32Array(3 * this.instanceMatrix.count),3)),
                e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Ho extends Mn {
            constructor(t) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new Ln(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this.fog = t.fog,
                this
            }
        }
        const zo = new he
          , Vo = new he
          , Wo = new Ge
          , qo = new ke
          , jo = new Le;
        class Xo extends pn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Kn
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ho;
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [0];
                    for (let t = 1, i = e.count; t < i; t++)
                        zo.fromBufferAttribute(e, t - 1),
                        Vo.fromBufferAttribute(e, t),
                        n[t] = n[t - 1],
                        n[t] += zo.distanceTo(Vo);
                    t.setAttribute("lineDistance", new Hn(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Line.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                jo.copy(n.boundingSphere),
                jo.applyMatrix4(i),
                jo.radius += r,
                !1 === t.ray.intersectsSphere(jo))
                    return;
                Wo.copy(i).invert(),
                qo.copy(t.ray).applyMatrix4(Wo);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o
                  , l = new he
                  , c = new he
                  , u = new he
                  , h = new he
                  , d = this.isLineSegments ? 2 : 1
                  , p = n.index
                  , f = n.attributes.position;
                if (null !== p)
                    for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                        const i = p.getX(n)
                          , r = p.getX(n + 1);
                        if (l.fromBufferAttribute(f, i),
                        c.fromBufferAttribute(f, r),
                        qo.distanceSqToSegment(l, c, h, u) > a)
                            continue;
                        h.applyMatrix4(this.matrixWorld);
                        const s = t.ray.origin.distanceTo(h);
                        s < t.near || s > t.far || e.push({
                            distance: s,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                else
                    for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) {
                        if (l.fromBufferAttribute(f, n),
                        c.fromBufferAttribute(f, n + 1),
                        qo.distanceSqToSegment(l, c, h, u) > a)
                            continue;
                        h.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(h);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes
                  , e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        const Yo = new he
          , Ko = new he;
        class Jo extends Xo {
            constructor(t, e) {
                super(t, e),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [];
                    for (let t = 0, i = e.count; t < i; t += 2)
                        Yo.fromBufferAttribute(e, t),
                        Ko.fromBufferAttribute(e, t + 1),
                        n[t] = 0 === t ? 0 : n[t - 1],
                        n[t + 1] = n[t] + Yo.distanceTo(Ko);
                    t.setAttribute("lineDistance", new Hn(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class $o extends Xo {
            constructor(t, e) {
                super(t, e),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class Zo extends Mn {
            constructor(t) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new Ln(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this.fog = t.fog,
                this
            }
        }
        const ta = new Ge
          , ea = new ke
          , na = new Le
          , ia = new he;
        class ra extends pn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Kn
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Zo;
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.material = Array.isArray(t.material) ? t.material.slice() : t.material,
                this.geometry = t.geometry,
                this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Points.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                na.copy(n.boundingSphere),
                na.applyMatrix4(i),
                na.radius += r,
                !1 === t.ray.intersectsSphere(na))
                    return;
                ta.copy(i).invert(),
                ea.copy(t.ray).applyMatrix4(ta);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o
                  , l = n.index
                  , c = n.attributes.position;
                if (null !== l)
                    for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                        const r = l.getX(n);
                        ia.fromBufferAttribute(c, r),
                        sa(ia, r, a, i, t, e, this)
                    }
                else
                    for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++)
                        ia.fromBufferAttribute(c, n),
                        sa(ia, n, a, i, t, e, this)
            }
            updateMorphTargets() {
                const t = this.geometry.morphAttributes
                  , e = Object.keys(t);
                if (e.length > 0) {
                    const n = t[e[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[e] = t
                        }
                    }
                }
            }
        }
        function sa(t, e, n, i, r, s, o) {
            const a = ea.distanceSqToPoint(t);
            if (a < n) {
                const n = new he;
                ea.closestPointToPoint(t, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }
        class oa extends re {
            constructor(t, e, n, i, r, s, o, a, l) {
                super(t, e, n, i, r, s, o, a, l),
                this.isVideoTexture = !0,
                this.minFilter = void 0 !== s ? s : I,
                this.magFilter = void 0 !== r ? r : I,
                this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0,
                    t.requestVideoFrameCallback(e)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 == "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class aa extends re {
            constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
                super(null, s, o, a, l, c, i, r, u, h),
                this.isCompressedTexture = !0,
                this.image = {
                    width: e,
                    height: n
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class la extends aa {
            constructor(t, e, n, i, r, s) {
                super(t, e, n, r, s),
                this.isCompressedArrayTexture = !0,
                this.image.depth = i,
                this.wrapR = x
            }
        }
        class ca extends aa {
            constructor(t, e, n) {
                super(void 0, t[0].width, t[0].height, e, n, v),
                this.isCompressedCubeTexture = !0,
                this.isCubeTexture = !0,
                this.image = t
            }
        }
        class ua extends re {
            constructor(t, e, n, i, r, s, o, a, l) {
                super(t, e, n, i, r, s, o, a, l),
                this.isCanvasTexture = !0,
                this.needsUpdate = !0
            }
        }
        class ha extends Mn {
            constructor(t) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Ln(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Ln(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Nt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(t.color),
                this.roughness = t.roughness,
                this.metalness = t.metalness,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.roughnessMap = t.roughnessMap,
                this.metalnessMap = t.metalnessMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapIntensity = t.envMapIntensity,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.flatShading = t.flatShading,
                this.fog = t.fog,
                this
            }
        }
        class da extends ha {
            constructor(t) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new Nt(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return It(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new Ln(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new Ln(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Ln(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(t)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(t) {
                this._anisotropy > 0 != t > 0 && this.version++,
                this._anisotropy = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++,
                this._clearcoat = t
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(t) {
                this._iridescence > 0 != t > 0 && this.version++,
                this._iridescence = t
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++,
                this._sheen = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++,
                this._transmission = t
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = t.anisotropy,
                this.anisotropyRotation = t.anisotropyRotation,
                this.anisotropyMap = t.anisotropyMap,
                this.clearcoat = t.clearcoat,
                this.clearcoatMap = t.clearcoatMap,
                this.clearcoatRoughness = t.clearcoatRoughness,
                this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                this.clearcoatNormalMap = t.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                this.ior = t.ior,
                this.iridescence = t.iridescence,
                this.iridescenceMap = t.iridescenceMap,
                this.iridescenceIOR = t.iridescenceIOR,
                this.iridescenceThicknessRange = [...t.iridescenceThicknessRange],
                this.iridescenceThicknessMap = t.iridescenceThicknessMap,
                this.sheen = t.sheen,
                this.sheenColor.copy(t.sheenColor),
                this.sheenColorMap = t.sheenColorMap,
                this.sheenRoughness = t.sheenRoughness,
                this.sheenRoughnessMap = t.sheenRoughnessMap,
                this.transmission = t.transmission,
                this.transmissionMap = t.transmissionMap,
                this.thickness = t.thickness,
                this.thicknessMap = t.thicknessMap,
                this.attenuationDistance = t.attenuationDistance,
                this.attenuationColor.copy(t.attenuationColor),
                this.specularIntensity = t.specularIntensity,
                this.specularIntensityMap = t.specularIntensityMap,
                this.specularColor.copy(t.specularColor),
                this.specularColorMap = t.specularColorMap,
                this
            }
        }
        function pa(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }
        function fa(t) {
            const e = t.length
              , n = new Array(e);
            for (let t = 0; t !== e; ++t)
                n[t] = t;
            return n.sort((function(e, n) {
                return t[e] - t[n]
            }
            )),
            n
        }
        function Aa(t, e, n) {
            const i = t.length
              , r = new t.constructor(i);
            for (let s = 0, o = 0; o !== i; ++s) {
                const i = n[s] * e;
                for (let n = 0; n !== e; ++n)
                    r[o++] = t[i + n]
            }
            return r
        }
        function ga(t, e, n, i) {
            let r = 1
              , s = t[0];
            for (; void 0 !== s && void 0 === s[i]; )
                s = t[r++];
            if (void 0 === s)
                return;
            let o = s[i];
            if (void 0 !== o)
                if (Array.isArray(o))
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        n.push.apply(n, o)),
                        s = t[r++]
                    } while (void 0 !== s);
                else if (void 0 !== o.toArray)
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        o.toArray(n, n.length)),
                        s = t[r++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[i],
                        void 0 !== o && (e.push(s.time),
                        n.push(o)),
                        s = t[r++]
                    } while (void 0 !== s)
        }
        class ma {
            constructor(t, e, n, i) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                  , i = e[n]
                  , r = e[n - 1];
                t: {
                    e: {
                        let s;
                        n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < r)
                                            break i;
                                        return n = e.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === s)
                                        break;
                                    if (r = i,
                                    i = e[++n],
                                    t < i)
                                        break e
                                }
                                s = e.length;
                                break n
                            }
                            if (t >= r)
                                break t;
                            {
                                const o = e[1];
                                t < o && (n = 2,
                                r = o);
                                for (let s = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === s)
                                        break;
                                    if (i = r,
                                    r = e[--n - 1],
                                    t >= r)
                                        break e
                                }
                                s = n,
                                n = 0
                            }
                        }
                        for (; n < s; ) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n],
                        r = e[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = e.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i;
                for (let t = 0; t !== i; ++t)
                    e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class va extends ma {
            constructor(t, e, n, i) {
                super(t, e, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: it,
                    endingEnd: it
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2
                  , s = t + 1
                  , o = i[r]
                  , a = i[s];
                if (void 0 === o)
                    switch (this.getSettings_().endingStart) {
                    case rt:
                        r = t,
                        o = 2 * e - n;
                        break;
                    case st:
                        r = i.length - 2,
                        o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t,
                        o = n
                    }
                if (void 0 === a)
                    switch (this.getSettings_().endingEnd) {
                    case rt:
                        s = t,
                        a = 2 * n - e;
                        break;
                    case st:
                        s = 1,
                        a = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1,
                        a = e
                    }
                const l = .5 * (n - e)
                  , c = this.valueSize;
                this._weightPrev = l / (e - o),
                this._weightNext = l / (a - n),
                this._offsetPrev = r * c,
                this._offsetNext = s * c
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = t * o
                  , l = a - o
                  , c = this._offsetPrev
                  , u = this._offsetNext
                  , h = this._weightPrev
                  , d = this._weightNext
                  , p = (n - e) / (i - e)
                  , f = p * p
                  , A = f * p
                  , g = -h * A + 2 * h * f - h * p
                  , m = (1 + h) * A + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                  , v = (-1 - d) * A + (1.5 + d) * f + .5 * p
                  , y = d * A - d * f;
                for (let t = 0; t !== o; ++t)
                    r[t] = g * s[c + t] + m * s[l + t] + v * s[a + t] + y * s[u + t];
                return r
            }
        }
        class ya extends ma {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = t * o
                  , l = a - o
                  , c = (n - e) / (i - e)
                  , u = 1 - c;
                for (let t = 0; t !== o; ++t)
                    r[t] = s[l + t] * u + s[a + t] * c;
                return r
            }
        }
        class _a extends ma {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class Ea {
            constructor(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = pa(e, this.TimeBufferType),
                this.values = pa(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: pa(t.times, Array),
                        values: pa(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new _a(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new ya(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new va(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case tt:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case et:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case nt:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return tt;
                case this.InterpolantFactoryMethodLinear:
                    return et;
                case this.InterpolantFactoryMethodSmooth:
                    return nt
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , s = i - 1;
                for (; r !== i && n[r] < t; )
                    ++r;
                for (; -1 !== s && n[s] > e; )
                    --s;
                if (++s,
                0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1),
                    r = s - 1);
                    const t = this.getValueSize();
                    this.times = n.slice(r, s),
                    this.values = this.values.slice(r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                        t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s),
                        t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && (o = i,
                ArrayBuffer.isView(o) && !(o instanceof DataView)))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                            t = !1;
                            break
                        }
                    }
                var o;
                return t
            }
            optimize() {
                const t = this.times.slice()
                  , e = this.values.slice()
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === nt
                  , r = t.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const a = t[o];
                    if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                        if (i)
                            r = !0;
                        else {
                            const t = o * n
                              , i = t - n
                              , s = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[s + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (o !== s) {
                            t[s] = t[o];
                            const i = o * n
                              , r = s * n;
                            for (let t = 0; t !== n; ++t)
                                e[r + t] = e[i + t]
                        }
                        ++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
                        e[i + o] = e[t + o];
                    ++s
                }
                return s !== t.length ? (this.times = t.slice(0, s),
                this.values = e.slice(0, s * n)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = this.times.slice()
                  , e = this.values.slice()
                  , n = new (0,
                this.constructor)(this.name,t,e);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        Ea.prototype.TimeBufferType = Float32Array,
        Ea.prototype.ValueBufferType = Float32Array,
        Ea.prototype.DefaultInterpolation = et;
        class ba extends Ea {
        }
        ba.prototype.ValueTypeName = "bool",
        ba.prototype.ValueBufferType = Array,
        ba.prototype.DefaultInterpolation = tt,
        ba.prototype.InterpolantFactoryMethodLinear = void 0,
        ba.prototype.InterpolantFactoryMethodSmooth = void 0;
        class xa extends Ea {
        }
        xa.prototype.ValueTypeName = "color";
        class wa extends Ea {
        }
        wa.prototype.ValueTypeName = "number";
        class Sa extends ma {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = (n - e) / (i - e);
                let l = t * o;
                for (let t = l + o; l !== t; l += 4)
                    ue.slerpFlat(r, 0, s, l - o, s, l, a);
                return r
            }
        }
        class Ca extends Ea {
            InterpolantFactoryMethodLinear(t) {
                return new Sa(this.times,this.values,this.getValueSize(),t)
            }
        }
        Ca.prototype.ValueTypeName = "quaternion",
        Ca.prototype.DefaultInterpolation = et,
        Ca.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Ma extends Ea {
        }
        Ma.prototype.ValueTypeName = "string",
        Ma.prototype.ValueBufferType = Array,
        Ma.prototype.DefaultInterpolation = tt,
        Ma.prototype.InterpolantFactoryMethodLinear = void 0,
        Ma.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Ia extends Ea {
        }
        Ia.prototype.ValueTypeName = "vector";
        class Ta {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1
                  , n = arguments.length > 2 ? arguments[2] : void 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2500;
                this.name = t,
                this.tracks = n,
                this.duration = e,
                this.blendMode = i,
                this.uuid = Mt(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                  , n = t.tracks
                  , i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t)
                    e.push(Ba(n[t]).scale(i));
                const r = new this(t.name,t.duration,e,t.blendMode);
                return r.uuid = t.uuid,
                r
            }
            static toJSON(t) {
                const e = []
                  , n = t.tracks
                  , i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let t = 0, i = n.length; t !== i; ++t)
                    e.push(Ea.toJSON(n[t]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length
                  , s = [];
                for (let t = 0; t < r; t++) {
                    let o = []
                      , a = [];
                    o.push((t + r - 1) % r, t, (t + 1) % r),
                    a.push(0, 1, 0);
                    const l = fa(o);
                    o = Aa(o, 1, l),
                    a = Aa(a, 1, l),
                    i || 0 !== o[0] || (o.push(r),
                    a.push(a[0])),
                    s.push(new wa(".morphTargetInfluences[" + e[t].name + "]",o,a).scale(1 / n))
                }
                return new this(t,-1,s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e)
                        return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e]
                      , s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []),
                        e.push(n)
                    }
                }
                const s = [];
                for (const t in i)
                    s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        const s = []
                          , o = [];
                        ga(n, s, o, i),
                        0 !== s.length && r.push(new t(e,s,o))
                    }
                }
                  , i = []
                  , r = t.name || "default"
                  , s = t.fps || 30
                  , o = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++)
                                        t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = []
                                  , s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time),
                                    s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new wa(".morphTargetInfluence[" + n + "]",t,s))
                            }
                            a = t.length * s
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(Ia, s + ".position", r, "pos", i),
                            n(Ca, s + ".quaternion", r, "rot", i),
                            n(Ia, s + ".scale", r, "scl", i)
                        }
                }
                return 0 === i.length ? null : new this(r,a,i,o)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t,
                this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Ba(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return wa;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Ia;
                case "color":
                    return xa;
                case "quaternion":
                    return Ca;
                case "bool":
                case "boolean":
                    return ba;
                case "string":
                    return Ma
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = []
                  , n = [];
                ga(t.keys, e, n, "value"),
                t.times = e,
                t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        const Ra = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        const La = new class {
            constructor(t, e, n) {
                const i = this;
                let r, s = !1, o = 0, a = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    a++,
                    !1 === s && void 0 !== i.onStart && i.onStart(t, o, a),
                    s = !0
                }
                ,
                this.itemEnd = function(t) {
                    o++,
                    void 0 !== i.onProgress && i.onProgress(t, o, a),
                    o === a && (s = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return r ? r(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return r = t,
                    this
                }
                ,
                this.addHandler = function(t, e) {
                    return l.push(t, e),
                    this
                }
                ,
                this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2),
                    this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e]
                          , i = l[e + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(t))
                            return i
                    }
                    return null
                }
            }
        }
        ;
        class Da {
            constructor(t) {
                this.manager = void 0 !== t ? t : La,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(t, i, e, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t,
                this
            }
            setWithCredentials(t) {
                return this.withCredentials = t,
                this
            }
            setPath(t) {
                return this.path = t,
                this
            }
            setResourcePath(t) {
                return this.resourcePath = t,
                this
            }
            setRequestHeader(t) {
                return this.requestHeader = t,
                this
            }
        }
        Da.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Pa = {};
        class Ua extends Error {
            constructor(t, e) {
                super(t),
                this.response = e
            }
        }
        class Oa extends Da {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = Ra.get(t);
                if (void 0 !== r)
                    return this.manager.itemStart(t),
                    setTimeout((()=>{
                        e && e(r),
                        this.manager.itemEnd(t)
                    }
                    ), 0),
                    r;
                if (void 0 !== Pa[t])
                    return void Pa[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                Pa[t] = [],
                Pa[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(t,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , o = this.mimeType
                  , a = this.responseType;
                fetch(s).then((e=>{
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader)
                            return e;
                        const n = Pa[t]
                          , i = e.body.getReader()
                          , r = e.headers.get("Content-Length") || e.headers.get("X-File-Size")
                          , s = r ? parseInt(r) : 0
                          , o = 0 !== s;
                        let a = 0;
                        const l = new ReadableStream({
                            start(t) {
                                !function e() {
                                    i.read().then((i=>{
                                        let {done: r, value: l} = i;
                                        if (r)
                                            t.close();
                                        else {
                                            a += l.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: o,
                                                loaded: a,
                                                total: s
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(l),
                                            e()
                                        }
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Ua(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)
                }
                )).then((t=>{
                    switch (a) {
                    case "arraybuffer":
                        return t.arrayBuffer();
                    case "blob":
                        return t.blob();
                    case "document":
                        return t.text().then((t=>(new DOMParser).parseFromString(t, o)));
                    case "json":
                        return t.json();
                    default:
                        if (void 0 === o)
                            return t.text();
                        {
                            const e = /charset="?([^;"\s]*)"?/i.exec(o)
                              , n = e && e[1] ? e[1].toLowerCase() : void 0
                              , i = new TextDecoder(n);
                            return t.arrayBuffer().then((t=>i.decode(t)))
                        }
                    }
                }
                )).then((e=>{
                    Ra.add(t, e);
                    const n = Pa[t];
                    delete Pa[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                }
                )).catch((e=>{
                    const n = Pa[t];
                    if (void 0 === n)
                        throw this.manager.itemError(t),
                        e;
                    delete Pa[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t)
                }
                )).finally((()=>{
                    this.manager.itemEnd(t)
                }
                )),
                this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t,
                this
            }
            setMimeType(t) {
                return this.mimeType = t,
                this
            }
        }
        class Na extends Da {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = Ra.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const o = Gt("img");
                function a() {
                    c(),
                    Ra.add(t, this),
                    e && e(this),
                    r.manager.itemEnd(t)
                }
                function l(e) {
                    c(),
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                function c() {
                    o.removeEventListener("load", a, !1),
                    o.removeEventListener("error", l, !1)
                }
                return o.addEventListener("load", a, !1),
                o.addEventListener("error", l, !1),
                "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
                r.manager.itemStart(t),
                o.src = t,
                o
            }
        }
        class Fa extends Da {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = this
                  , s = new To
                  , o = new Oa(this.manager);
                return o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setPath(this.path),
                o.setWithCredentials(r.withCredentials),
                o.load(t, (function(t) {
                    let n;
                    try {
                        n = r.parse(t)
                    } catch (t) {
                        if (void 0 === i)
                            return void console.error(t);
                        i(t)
                    }
                    void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width,
                    s.image.height = n.height,
                    s.image.data = n.data),
                    s.wrapS = void 0 !== n.wrapS ? n.wrapS : x,
                    s.wrapT = void 0 !== n.wrapT ? n.wrapT : x,
                    s.magFilter = void 0 !== n.magFilter ? n.magFilter : I,
                    s.minFilter = void 0 !== n.minFilter ? n.minFilter : I,
                    s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                    void 0 !== n.colorSpace ? s.colorSpace = n.colorSpace : void 0 !== n.encoding && (s.encoding = n.encoding),
                    void 0 !== n.flipY && (s.flipY = n.flipY),
                    void 0 !== n.format && (s.format = n.format),
                    void 0 !== n.type && (s.type = n.type),
                    void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps,
                    s.minFilter = B),
                    1 === n.mipmapCount && (s.minFilter = I),
                    void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                    s.needsUpdate = !0,
                    e && e(s, n)
                }
                ), n, i),
                s
            }
        }
        class Qa extends Da {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new re
                  , s = new Na(this.manager);
                return s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(t, (function(t) {
                    r.image = t,
                    r.needsUpdate = !0,
                    void 0 !== e && e(r)
                }
                ), n, i),
                r
            }
        }
        class ka extends pn {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Ln(t),
                this.intensity = e
            }
            dispose() {}
            copy(t, e) {
                return super.copy(t, e),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        const Ga = new Ge
          , Ha = new he
          , za = new he;
        class Va {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new Nt(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Ge,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Pi,
                this._frameExtents = new Nt(1,1),
                this._viewportCount = 1,
                this._viewports = [new se(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = this.matrix;
                Ha.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(Ha),
                za.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(za),
                e.updateMatrixWorld(),
                Ga.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Ga),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(Ga)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        class Wa extends Va {
            constructor() {
                super(new xi(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = 2 * Ct * t.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
                e.aspect = i,
                e.far = r,
                e.updateProjectionMatrix()),
                super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t),
                this.focus = t.focus,
                this
            }
        }
        class qa extends ka {
            constructor(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3
                  , r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2;
                super(t, e),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(pn.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new pn,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = s,
                this.map = null,
                this.shadow = new Wa
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.distance = t.distance,
                this.angle = t.angle,
                this.penumbra = t.penumbra,
                this.decay = t.decay,
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        const ja = new Ge
          , Xa = new he
          , Ya = new he;
        class Ka extends Va {
            constructor() {
                super(new xi(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new Nt(4,2),
                this._viewportCount = 6,
                this._viewports = [new se(2,1,1,1), new se(0,1,1,1), new se(3,1,1,1), new se(1,1,1,1), new se(3,0,1,1), new se(1,0,1,1)],
                this._cubeDirections = [new he(1,0,0), new he(-1,0,0), new he(0,0,1), new he(0,0,-1), new he(0,1,0), new he(0,-1,0)],
                this._cubeUps = [new he(0,1,0), new he(0,1,0), new he(0,1,0), new he(0,1,0), new he(0,0,1), new he(0,0,-1)]
            }
            updateMatrices(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.camera
                  , i = this.matrix
                  , r = t.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                Xa.setFromMatrixPosition(t.matrixWorld),
                n.position.copy(Xa),
                Ya.copy(n.position),
                Ya.add(this._cubeDirections[e]),
                n.up.copy(this._cubeUps[e]),
                n.lookAt(Ya),
                n.updateMatrixWorld(),
                i.makeTranslation(-Xa.x, -Xa.y, -Xa.z),
                ja.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(ja)
            }
        }
        class Ja extends ka {
            constructor(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2;
                super(t, e),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new Ka
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.distance = t.distance,
                this.decay = t.decay,
                this.shadow = t.shadow.clone(),
                this
            }
        }
        class $a extends Va {
            constructor() {
                super(new Xi(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class Za extends ka {
            constructor(t, e) {
                super(t, e),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(pn.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new pn,
                this.shadow = new $a
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        class tl {
            constructor() {
                this.isSphericalHarmonics3 = !0,
                this.coefficients = [];
                for (let t = 0; t < 9; t++)
                    this.coefficients.push(new he)
            }
            set(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.282095),
                e.addScaledVector(s[1], .488603 * i),
                e.addScaledVector(s[2], .488603 * r),
                e.addScaledVector(s[3], .488603 * n),
                e.addScaledVector(s[4], n * i * 1.092548),
                e.addScaledVector(s[5], i * r * 1.092548),
                e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
                e.addScaledVector(s[7], n * r * 1.092548),
                e.addScaledVector(s[8], .546274 * (n * n - i * i)),
                e
            }
            getIrradianceAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.886227),
                e.addScaledVector(s[1], 1.023328 * i),
                e.addScaledVector(s[2], 1.023328 * r),
                e.addScaledVector(s[3], 1.023328 * n),
                e.addScaledVector(s[4], .858086 * n * i),
                e.addScaledVector(s[5], .858086 * i * r),
                e.addScaledVector(s[6], .743125 * r * r - .247708),
                e.addScaledVector(s[7], .858086 * n * r),
                e.addScaledVector(s[8], .429043 * (n * n - i * i)),
                e
            }
            add(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z;
                e[0] = .282095,
                e[1] = .488603 * i,
                e[2] = .488603 * r,
                e[3] = .488603 * n,
                e[4] = 1.092548 * n * i,
                e[5] = 1.092548 * i * r,
                e[6] = .315392 * (3 * r * r - 1),
                e[7] = 1.092548 * n * r,
                e[8] = .546274 * (n * n - i * i)
            }
        }
        class el extends ka {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new tl;
                super(void 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1),
                this.isLightProbe = !0,
                this.sh = t
            }
            copy(t) {
                return super.copy(t),
                this.sh.copy(t.sh),
                this
            }
            fromJSON(t) {
                return this.intensity = t.intensity,
                this.sh.fromArray(t.sh),
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(),
                e
            }
        }
        class nl {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++)
                    e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.slice(0, e + 1)
            }
            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }
        class il extends Da {
            constructor(t) {
                super(t),
                this.isImageBitmapLoader = !0,
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t,
                this
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = Ra.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const o = {};
                o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                o.headers = this.requestHeader,
                fetch(t, o).then((function(t) {
                    return t.blob()
                }
                )).then((function(t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    Ra.add(t, n),
                    e && e(n),
                    r.manager.itemEnd(t)
                }
                )).catch((function(e) {
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                )),
                r.manager.itemStart(t)
            }
        }
        class rl {
            constructor(t, e, n) {
                let i, r, s;
                switch (this.binding = t,
                this.valueSize = n,
                e) {
                case "quaternion":
                    i = this._slerp,
                    r = this._slerpAdditive,
                    s = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * n),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select,
                    r = this._select,
                    s = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp,
                    r = this._lerpAdditive,
                    s = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i,
                this._mixBufferRegionAdditive = r,
                this._setIdentity = s,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer
                  , i = this.valueSize
                  , r = t * i + i;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let t = 0; t !== i; ++t)
                        n[r + t] = n[t];
                    s = e
                } else {
                    s += e;
                    const t = e / s;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(t) {
                const e = this.buffer
                  , n = this.valueSize
                  , i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(e, i, 0, t, n),
                this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize
                  , n = this.buffer
                  , i = t * e + e
                  , r = this.cumulativeWeight
                  , s = this.cumulativeWeightAdditive
                  , o = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t)
                    if (n[t] !== n[t + e]) {
                        o.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding
                  , e = this.buffer
                  , n = this.valueSize
                  , i = n * this._origIndex;
                t.getValue(e, i);
                for (let t = n, r = i; t !== r; ++t)
                    e[t] = e[i + t % n];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize
                  , e = t + this.valueSize;
                for (let n = t; n < e; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize
                  , e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[e + n] = this.buffer[t + n]
            }
            _select(t, e, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i)
                        t[e + i] = t[n + i]
            }
            _slerp(t, e, n, i) {
                ue.slerpFlat(t, e, t, e, t, n, i)
            }
            _slerpAdditive(t, e, n, i, r) {
                const s = this._workIndex * r;
                ue.multiplyQuaternionsFlat(t, s, t, e, t, n),
                ue.slerpFlat(t, e, t, e, t, s, i)
            }
            _lerp(t, e, n, i, r) {
                const s = 1 - i;
                for (let o = 0; o !== r; ++o) {
                    const r = e + o;
                    t[r] = t[r] * s + t[n + o] * i
                }
            }
            _lerpAdditive(t, e, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] + t[n + s] * i
                }
            }
        }
        const sl = "\\[\\]\\.:\\/"
          , ol = new RegExp("[" + sl + "]","g")
          , al = "[^" + sl + "]"
          , ll = "[^" + sl.replace("\\.", "") + "]"
          , cl = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", al) + /(WCOD+)?/.source.replace("WCOD", ll) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", al) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", al) + "$")
          , ul = ["material", "materials", "bones", "map"];
        class hl {
            constructor(t, e, n) {
                this.path = e,
                this.parsedPath = n || hl.parseTrackName(e),
                this.node = hl.findNode(t, this.parsedPath.nodeName),
                this.rootNode = t,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new hl.Composite(t,e,n) : new hl(t,e,n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(ol, "")
            }
            static parseTrackName(t) {
                const e = cl.exec(t);
                if (null === e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1);
                    -1 !== ul.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n)
                        return n
                }
                if (t.children) {
                    const n = function(t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e)
                                return r;
                            const s = n(r.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , i = n(t.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(),
                this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(),
                this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath
                  , n = e.objectName
                  , i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = hl.findNode(this.rootNode, e.nodeName),
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in t) {
                            t = t.map;
                            break
                        }
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        t = t.material.map;
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let o = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = r
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a],
                this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        hl.Composite = class {
            constructor(t, e, n) {
                const i = n || hl.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }
        ,
        hl.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        hl.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        hl.prototype.GetterByBindingType = [hl.prototype._getValue_direct, hl.prototype._getValue_array, hl.prototype._getValue_arrayElement, hl.prototype._getValue_toArray],
        hl.prototype.SetterByBindingTypeAndVersioning = [[hl.prototype._setValue_direct, hl.prototype._setValue_direct_setNeedsUpdate, hl.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [hl.prototype._setValue_array, hl.prototype._setValue_array_setNeedsUpdate, hl.prototype._setValue_array_setMatrixWorldNeedsUpdate], [hl.prototype._setValue_arrayElement, hl.prototype._setValue_arrayElement_setNeedsUpdate, hl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [hl.prototype._setValue_fromArray, hl.prototype._setValue_fromArray_setNeedsUpdate, hl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class dl {
            constructor(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.blendMode;
                this._mixer = t,
                this._clip = e,
                this._localRoot = n,
                this.blendMode = i;
                const r = e.tracks
                  , s = r.length
                  , o = new Array(s)
                  , a = {
                    endingStart: it,
                    endingEnd: it
                };
                for (let t = 0; t !== s; ++t) {
                    const e = r[t].createInterpolant(null);
                    o[t] = e,
                    e.settings = a
                }
                this._interpolantSettings = a,
                this._interpolants = o,
                this._propertyBindings = new Array(s),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = 2201,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t,
                this
            }
            setLoop(t, e) {
                return this.loop = t,
                this.repetitions = e,
                this
            }
            setEffectiveWeight(t) {
                return this.weight = t,
                this._effectiveWeight = this.enabled ? t : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e),
                this.fadeIn(e),
                n) {
                    const n = this._clip.duration
                      , i = t._clip.duration
                      , r = i / n
                      , s = n / i;
                    t.warp(1, r, e),
                    this.warp(s, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t,
                this._effectiveTimeScale = this.paused ? 0 : t,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t,
                this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time,
                this.timeScale = t.timeScale,
                this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const i = this._mixer
                  , r = i.time
                  , s = this.timeScale;
                let o = this._timeScaleInterpolant;
                null === o && (o = i._lendControlInterpolant(),
                this._timeScaleInterpolant = o);
                const a = o.parameterPositions
                  , l = o.sampleValues;
                return a[0] = r,
                a[1] = r + n,
                l[0] = t / s,
                l[1] = e / s,
                this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, i) {
                if (!this.enabled)
                    return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    i < 0 || 0 === n ? e = 0 : (this._startTime = null,
                    e = n * i)
                }
                e *= this._updateTimeScale(t);
                const s = this._updateTime(e)
                  , o = this._updateWeight(t);
                if (o > 0) {
                    const t = this._interpolants
                      , e = this._propertyBindings;
                    if (2501 === this.blendMode)
                        for (let n = 0, i = t.length; n !== i; ++n)
                            t[n].evaluate(s),
                            e[n].accumulateAdditive(o);
                    else
                        for (let n = 0, r = t.length; n !== r; ++n)
                            t[n].evaluate(s),
                            e[n].accumulate(i, o)
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i,
                        t > n.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    null !== n && (e *= n.evaluate(t)[0],
                    t > n.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e))
                }
                return this._effectiveTimeScale = e,
                e
            }
            _updateTime(t) {
                const e = this._clip.duration
                  , n = this.loop;
                let i = this.time + t
                  , r = this._loopCount;
                const s = n === Z;
                if (0 === t)
                    return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    t: {
                        if (i >= e)
                            i = e;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0,
                    this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                    i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n,
                        r += Math.abs(n);
                        const o = this.repetitions - r;
                        if (o <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            i = t > 0 ? e : 0,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                        else {
                            if (1 === o) {
                                const e = t < 0;
                                this._setEndings(e, !e, s)
                            } else
                                this._setEndings(!1, !1, s);
                            this._loopCount = r,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else
                        this.time = i;
                    if (s && 1 == (1 & r))
                        return e - i
                }
                return i
            }
            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = rt,
                i.endingEnd = rt) : (i.endingStart = t ? this.zeroSlopeAtStart ? rt : it : st,
                i.endingEnd = e ? this.zeroSlopeAtEnd ? rt : it : st)
            }
            _scheduleFading(t, e, n) {
                const i = this._mixer
                  , r = i.time;
                let s = this._weightInterpolant;
                null === s && (s = i._lendControlInterpolant(),
                this._weightInterpolant = s);
                const o = s.parameterPositions
                  , a = s.sampleValues;
                return o[0] = r,
                a[0] = e,
                o[1] = r + t,
                a[1] = n,
                this
            }
        }
        const pl = new Float32Array(1);
        class fl extends bt {
            constructor(t) {
                super(),
                this._root = t,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root
                  , i = t._clip.tracks
                  , r = i.length
                  , s = t._propertyBindings
                  , o = t._interpolants
                  , a = n.uuid
                  , l = this._bindingsByRootAndName;
                let c = l[a];
                void 0 === c && (c = {},
                l[a] = c);
                for (let t = 0; t !== r; ++t) {
                    const r = i[t]
                      , l = r.name;
                    let u = c[l];
                    if (void 0 !== u)
                        ++u.referenceCount,
                        s[t] = u;
                    else {
                        if (u = s[t],
                        void 0 !== u) {
                            null === u._cacheIndex && (++u.referenceCount,
                            this._addInactiveBinding(u, a, l));
                            continue
                        }
                        const i = e && e._propertyBindings[t].binding.parsedPath;
                        u = new rl(hl.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                        ++u.referenceCount,
                        this._addInactiveBinding(u, a, l),
                        s[t] = u
                    }
                    o[t].resultBuffer = u.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid
                          , n = t._clip.uuid
                          , i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]),
                        this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n),
                        n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const i = this._actions
                  , r = this._actionsByClip;
                let s = r[e];
                if (void 0 === s)
                    s = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                    t._byClipCacheIndex = 0,
                    r[e] = s;
                else {
                    const e = s.knownActions;
                    t._byClipCacheIndex = e.length,
                    e.push(t)
                }
                t._cacheIndex = i.length,
                i.push(t),
                s.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions
                  , n = e[e.length - 1]
                  , i = t._cacheIndex;
                n._cacheIndex = i,
                e[i] = n,
                e.pop(),
                t._cacheIndex = null;
                const r = t._clip.uuid
                  , s = this._actionsByClip
                  , o = s[r]
                  , a = o.knownActions
                  , l = a[a.length - 1]
                  , c = t._byClipCacheIndex;
                l._byClipCacheIndex = c,
                a[c] = l,
                a.pop(),
                t._byClipCacheIndex = null,
                delete o.actionByRoot[(t._localRoot || this._root).uuid],
                0 === a.length && delete s[r],
                this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = this._nActiveActions++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = --this._nActiveActions
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _addInactiveBinding(t, e, n) {
                const i = this._bindingsByRootAndName
                  , r = this._bindings;
                let s = i[e];
                void 0 === s && (s = {},
                i[e] = s),
                s[n] = t,
                t._cacheIndex = r.length,
                r.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings
                  , n = t.binding
                  , i = n.rootNode.uuid
                  , r = n.path
                  , s = this._bindingsByRootAndName
                  , o = s[i]
                  , a = e[e.length - 1]
                  , l = t._cacheIndex;
                a._cacheIndex = l,
                e[l] = a,
                e.pop(),
                delete o[r],
                0 === Object.keys(o).length && delete s[i]
            }
            _lendBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = this._nActiveBindings++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = --this._nActiveBindings
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants
                  , e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new ya(new Float32Array(2),new Float32Array(2),1,pl),
                n.__cacheIndex = e,
                t[e] = n),
                n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants
                  , n = t.__cacheIndex
                  , i = --this._nActiveControlInterpolants
                  , r = e[i];
                t.__cacheIndex = i,
                e[i] = t,
                r.__cacheIndex = n,
                e[n] = r
            }
            clipAction(t, e, n) {
                const i = e || this._root
                  , r = i.uuid;
                let s = "string" == typeof t ? Ta.findByName(i, t) : t;
                const o = null !== s ? s.uuid : t
                  , a = this._actionsByClip[o];
                let l = null;
                if (void 0 === n && (n = null !== s ? s.blendMode : 2500),
                void 0 !== a) {
                    const t = a.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n)
                        return t;
                    l = a.knownActions[0],
                    null === s && (s = l._clip)
                }
                if (null === s)
                    return null;
                const c = new dl(this,s,e,n);
                return this._bindAction(c, l),
                this._addInactiveAction(c, o, r),
                c
            }
            existingAction(t, e) {
                const n = e || this._root
                  , i = n.uuid
                  , r = "string" == typeof t ? Ta.findByName(n, t) : t
                  , s = r ? r.uuid : t
                  , o = this._actionsByClip[s];
                return void 0 !== o && o.actionByRoot[i] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e)
                    t[e].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions
                  , n = this._nActiveActions
                  , i = this.time += t
                  , r = Math.sign(t)
                  , s = this._accuIndex ^= 1;
                for (let o = 0; o !== n; ++o)
                    e[o]._update(i, t, r, s);
                const o = this._bindings
                  , a = this._nActiveBindings;
                for (let t = 0; t !== a; ++t)
                    o[t].apply(s);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions
                  , n = t.uuid
                  , i = this._actionsByClip
                  , r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex
                          , s = e[e.length - 1];
                        i._cacheIndex = null,
                        i._byClipCacheIndex = null,
                        s._cacheIndex = r,
                        e[r] = s,
                        e.pop(),
                        this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid
                  , n = this._actionsByClip;
                for (const t in n) {
                    const i = n[t].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i),
                    this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[e];
                if (void 0 !== i)
                    for (const t in i) {
                        const e = i[t];
                        e.restoreOriginalState(),
                        this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
        }
        class Al {
            constructor(t) {
                this.value = t
            }
            clone() {
                return new Al(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        function gl(t, e) {
            return t.distance - e.distance
        }
        function ml(t, e, n, i) {
            if (t.layers.test(e.layers) && t.raycast(e, n),
            !0 === i) {
                const i = t.children;
                for (let t = 0, r = i.length; t < r; t++)
                    ml(i[t], e, n, !0)
            }
        }
        class vl {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.radius = t,
                this.phi = e,
                this.theta = n,
                this
            }
            set(t, e, n) {
                return this.radius = t,
                this.phi = e,
                this.theta = n,
                this
            }
            copy(t) {
                return this.radius = t.radius,
                this.phi = t.phi,
                this.theta = t.theta,
                this
            }
            makeSafe() {
                const t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
                this
            }
            setFromVector3(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            }
            setFromCartesianCoords(t, e, n) {
                return this.radius = Math.sqrt(t * t + e * e + n * n),
                0 === this.radius ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(t, n),
                this.phi = Math.acos(It(e / this.radius, -1, 1))),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: r
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r);
        const yl = window
          , _l = yl.ShadowRoot && (void 0 === yl.ShadyCSS || yl.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
          , El = Symbol()
          , bl = new WeakMap;
        class xl {
            constructor(t, e, n) {
                if (this._$cssResult$ = !0,
                n !== El)
                    throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                this.cssText = t,
                this.t = e
            }
            get styleSheet() {
                let t = this.o;
                const e = this.t;
                if (_l && void 0 === t) {
                    const n = void 0 !== e && 1 === e.length;
                    n && (t = bl.get(e)),
                    void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText),
                    n && bl.set(e, t))
                }
                return t
            }
            toString() {
                return this.cssText
            }
        }
        const wl = _l ? t=>t : t=>t instanceof CSSStyleSheet ? (t=>{
            let e = "";
            for (const n of t.cssRules)
                e += n.cssText;
            return (t=>new xl("string" == typeof t ? t : t + "",void 0,El))(e)
        }
        )(t) : t;
        var Sl;
        const Cl = window
          , Ml = Cl.trustedTypes
          , Il = Ml ? Ml.emptyScript : ""
          , Tl = Cl.reactiveElementPolyfillSupport
          , Bl = {
            toAttribute(t, e) {
                switch (e) {
                case Boolean:
                    t = t ? Il : null;
                    break;
                case Object:
                case Array:
                    t = null == t ? t : JSON.stringify(t)
                }
                return t
            },
            fromAttribute(t, e) {
                let n = t;
                switch (e) {
                case Boolean:
                    n = null !== t;
                    break;
                case Number:
                    n = null === t ? null : Number(t);
                    break;
                case Object:
                case Array:
                    try {
                        n = JSON.parse(t)
                    } catch (t) {
                        n = null
                    }
                }
                return n
            }
        }
          , Rl = (t,e)=>e !== t && (e == e || t == t)
          , Ll = {
            attribute: !0,
            type: String,
            converter: Bl,
            reflect: !1,
            hasChanged: Rl
        }
          , Dl = "finalized";
        class Pl extends HTMLElement {
            constructor() {
                super(),
                this._$Ei = new Map,
                this.isUpdatePending = !1,
                this.hasUpdated = !1,
                this._$El = null,
                this._$Eu()
            }
            static addInitializer(t) {
                var e;
                this.finalize(),
                (null !== (e = this.h) && void 0 !== e ? e : this.h = []).push(t)
            }
            static get observedAttributes() {
                this.finalize();
                const t = [];
                return this.elementProperties.forEach(((e,n)=>{
                    const i = this._$Ep(n, e);
                    void 0 !== i && (this._$Ev.set(i, n),
                    t.push(i))
                }
                )),
                t
            }
            static createProperty(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ll;
                if (e.state && (e.attribute = !1),
                this.finalize(),
                this.elementProperties.set(t, e),
                !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
                    const n = "symbol" == typeof t ? Symbol() : "__" + t
                      , i = this.getPropertyDescriptor(t, n, e);
                    void 0 !== i && Object.defineProperty(this.prototype, t, i)
                }
            }
            static getPropertyDescriptor(t, e, n) {
                return {
                    get() {
                        return this[e]
                    },
                    set(i) {
                        const r = this[t];
                        this[e] = i,
                        this.requestUpdate(t, r, n)
                    },
                    configurable: !0,
                    enumerable: !0
                }
            }
            static getPropertyOptions(t) {
                return this.elementProperties.get(t) || Ll
            }
            static finalize() {
                if (this.hasOwnProperty(Dl))
                    return !1;
                this[Dl] = !0;
                const t = Object.getPrototypeOf(this);
                if (t.finalize(),
                void 0 !== t.h && (this.h = [...t.h]),
                this.elementProperties = new Map(t.elementProperties),
                this._$Ev = new Map,
                this.hasOwnProperty("properties")) {
                    const t = this.properties
                      , e = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
                    for (const n of e)
                        this.createProperty(n, t[n])
                }
                return this.elementStyles = this.finalizeStyles(this.styles),
                !0
            }
            static finalizeStyles(t) {
                const e = [];
                if (Array.isArray(t)) {
                    const n = new Set(t.flat(1 / 0).reverse());
                    for (const t of n)
                        e.unshift(wl(t))
                } else
                    void 0 !== t && e.push(wl(t));
                return e
            }
            static _$Ep(t, e) {
                const n = e.attribute;
                return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof t ? t.toLowerCase() : void 0
            }
            _$Eu() {
                var t;
                this._$E_ = new Promise((t=>this.enableUpdating = t)),
                this._$AL = new Map,
                this._$Eg(),
                this.requestUpdate(),
                null === (t = this.constructor.h) || void 0 === t || t.forEach((t=>t(this)))
            }
            addController(t) {
                var e, n;
                (null !== (e = this._$ES) && void 0 !== e ? e : this._$ES = []).push(t),
                void 0 !== this.renderRoot && this.isConnected && (null === (n = t.hostConnected) || void 0 === n || n.call(t))
            }
            removeController(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.splice(this._$ES.indexOf(t) >>> 0, 1)
            }
            _$Eg() {
                this.constructor.elementProperties.forEach(((t,e)=>{
                    this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]),
                    delete this[e])
                }
                ))
            }
            createRenderRoot() {
                var t;
                const e = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
                return ((t,e)=>{
                    _l ? t.adoptedStyleSheets = e.map((t=>t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach((e=>{
                        const n = document.createElement("style")
                          , i = yl.litNonce;
                        void 0 !== i && n.setAttribute("nonce", i),
                        n.textContent = e.cssText,
                        t.appendChild(n)
                    }
                    ))
                }
                )(e, this.constructor.elementStyles),
                e
            }
            connectedCallback() {
                var t;
                void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()),
                this.enableUpdating(!0),
                null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                    var e;
                    return null === (e = t.hostConnected) || void 0 === e ? void 0 : e.call(t)
                }
                ))
            }
            enableUpdating(t) {}
            disconnectedCallback() {
                var t;
                null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                    var e;
                    return null === (e = t.hostDisconnected) || void 0 === e ? void 0 : e.call(t)
                }
                ))
            }
            attributeChangedCallback(t, e, n) {
                this._$AK(t, n)
            }
            _$EO(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ll;
                var i;
                const r = this.constructor._$Ep(t, n);
                if (void 0 !== r && !0 === n.reflect) {
                    const s = (void 0 !== (null === (i = n.converter) || void 0 === i ? void 0 : i.toAttribute) ? n.converter : Bl).toAttribute(e, n.type);
                    this._$El = t,
                    null == s ? this.removeAttribute(r) : this.setAttribute(r, s),
                    this._$El = null
                }
            }
            _$AK(t, e) {
                var n;
                const i = this.constructor
                  , r = i._$Ev.get(t);
                if (void 0 !== r && this._$El !== r) {
                    const t = i.getPropertyOptions(r)
                      , s = "function" == typeof t.converter ? {
                        fromAttribute: t.converter
                    } : void 0 !== (null === (n = t.converter) || void 0 === n ? void 0 : n.fromAttribute) ? t.converter : Bl;
                    this._$El = r,
                    this[r] = s.fromAttribute(e, t.type),
                    this._$El = null
                }
            }
            requestUpdate(t, e, n) {
                let i = !0;
                void 0 !== t && (((n = n || this.constructor.getPropertyOptions(t)).hasChanged || Rl)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e),
                !0 === n.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map),
                this._$EC.set(t, n))) : i = !1),
                !this.isUpdatePending && i && (this._$E_ = this._$Ej())
            }
            async _$Ej() {
                this.isUpdatePending = !0;
                try {
                    await this._$E_
                } catch (t) {
                    Promise.reject(t)
                }
                const t = this.scheduleUpdate();
                return null != t && await t,
                !this.isUpdatePending
            }
            scheduleUpdate() {
                return this.performUpdate()
            }
            performUpdate() {
                var t;
                if (!this.isUpdatePending)
                    return;
                this.hasUpdated,
                this._$Ei && (this._$Ei.forEach(((t,e)=>this[e] = t)),
                this._$Ei = void 0);
                let e = !1;
                const n = this._$AL;
                try {
                    e = this.shouldUpdate(n),
                    e ? (this.willUpdate(n),
                    null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                        var e;
                        return null === (e = t.hostUpdate) || void 0 === e ? void 0 : e.call(t)
                    }
                    )),
                    this.update(n)) : this._$Ek()
                } catch (t) {
                    throw e = !1,
                    this._$Ek(),
                    t
                }
                e && this._$AE(n)
            }
            willUpdate(t) {}
            _$AE(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.forEach((t=>{
                    var e;
                    return null === (e = t.hostUpdated) || void 0 === e ? void 0 : e.call(t)
                }
                )),
                this.hasUpdated || (this.hasUpdated = !0,
                this.firstUpdated(t)),
                this.updated(t)
            }
            _$Ek() {
                this._$AL = new Map,
                this.isUpdatePending = !1
            }
            get updateComplete() {
                return this.getUpdateComplete()
            }
            getUpdateComplete() {
                return this._$E_
            }
            shouldUpdate(t) {
                return !0
            }
            update(t) {
                void 0 !== this._$EC && (this._$EC.forEach(((t,e)=>this._$EO(e, this[e], t))),
                this._$EC = void 0),
                this._$Ek()
            }
            updated(t) {}
            firstUpdated(t) {}
        }
        var Ul;
        Pl[Dl] = !0,
        Pl.elementProperties = new Map,
        Pl.elementStyles = [],
        Pl.shadowRootOptions = {
            mode: "open"
        },
        null == Tl || Tl({
            ReactiveElement: Pl
        }),
        (null !== (Sl = Cl.reactiveElementVersions) && void 0 !== Sl ? Sl : Cl.reactiveElementVersions = []).push("1.6.3");
        const Ol = window
          , Nl = Ol.trustedTypes
          , Fl = Nl ? Nl.createPolicy("lit-html", {
            createHTML: t=>t
        }) : void 0
          , Ql = "$lit$"
          , kl = `lit$${(Math.random() + "").slice(9)}$`
          , Gl = "?" + kl
          , Hl = `<${Gl}>`
          , zl = document
          , Vl = ()=>zl.createComment("")
          , Wl = t=>null === t || "object" != typeof t && "function" != typeof t
          , ql = Array.isArray
          , jl = "[ \t\n\f\r]"
          , Xl = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
          , Yl = /-->/g
          , Kl = />/g
          , Jl = RegExp(`>|${jl}(?:([^\\s"'>=/]+)(${jl}*=${jl}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`, "g")
          , $l = /'/g
          , Zl = /"/g
          , tc = /^(?:script|style|textarea|title)$/i
          , ec = function(t) {
            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
                n[i - 1] = arguments[i];
            return {
                _$litType$: 1,
                strings: t,
                values: n
            }
        }
          , nc = Symbol.for("lit-noChange")
          , ic = Symbol.for("lit-nothing")
          , rc = new WeakMap
          , sc = zl.createTreeWalker(zl, 129, null, !1);
        function oc(t, e) {
            if (!Array.isArray(t) || !t.hasOwnProperty("raw"))
                throw Error("invalid template strings array");
            return void 0 !== Fl ? Fl.createHTML(e) : e
        }
        class ac {
            constructor(t, e) {
                let n, {strings: i, _$litType$: r} = t;
                this.parts = [];
                let s = 0
                  , o = 0;
                const a = i.length - 1
                  , l = this.parts
                  , [c,u] = ((t,e)=>{
                    const n = t.length - 1
                      , i = [];
                    let r, s = 2 === e ? "<svg>" : "", o = Xl;
                    for (let e = 0; e < n; e++) {
                        const n = t[e];
                        let a, l, c = -1, u = 0;
                        for (; u < n.length && (o.lastIndex = u,
                        l = o.exec(n),
                        null !== l); )
                            u = o.lastIndex,
                            o === Xl ? "!--" === l[1] ? o = Yl : void 0 !== l[1] ? o = Kl : void 0 !== l[2] ? (tc.test(l[2]) && (r = RegExp("</" + l[2], "g")),
                            o = Jl) : void 0 !== l[3] && (o = Jl) : o === Jl ? ">" === l[0] ? (o = null != r ? r : Xl,
                            c = -1) : void 0 === l[1] ? c = -2 : (c = o.lastIndex - l[2].length,
                            a = l[1],
                            o = void 0 === l[3] ? Jl : '"' === l[3] ? Zl : $l) : o === Zl || o === $l ? o = Jl : o === Yl || o === Kl ? o = Xl : (o = Jl,
                            r = void 0);
                        const h = o === Jl && t[e + 1].startsWith("/>") ? " " : "";
                        s += o === Xl ? n + Hl : c >= 0 ? (i.push(a),
                        n.slice(0, c) + Ql + n.slice(c) + kl + h) : n + kl + (-2 === c ? (i.push(void 0),
                        e) : h)
                    }
                    return [oc(t, s + (t[n] || "<?>") + (2 === e ? "</svg>" : "")), i]
                }
                )(i, r);
                if (this.el = ac.createElement(c, e),
                sc.currentNode = this.el.content,
                2 === r) {
                    const t = this.el.content
                      , e = t.firstChild;
                    e.remove(),
                    t.append(...e.childNodes)
                }
                for (; null !== (n = sc.nextNode()) && l.length < a; ) {
                    if (1 === n.nodeType) {
                        if (n.hasAttributes()) {
                            const t = [];
                            for (const e of n.getAttributeNames())
                                if (e.endsWith(Ql) || e.startsWith(kl)) {
                                    const i = u[o++];
                                    if (t.push(e),
                                    void 0 !== i) {
                                        const t = n.getAttribute(i.toLowerCase() + Ql).split(kl)
                                          , e = /([.?@])?(.*)/.exec(i);
                                        l.push({
                                            type: 1,
                                            index: s,
                                            name: e[2],
                                            strings: t,
                                            ctor: "." === e[1] ? dc : "?" === e[1] ? fc : "@" === e[1] ? Ac : hc
                                        })
                                    } else
                                        l.push({
                                            type: 6,
                                            index: s
                                        })
                                }
                            for (const e of t)
                                n.removeAttribute(e)
                        }
                        if (tc.test(n.tagName)) {
                            const t = n.textContent.split(kl)
                              , e = t.length - 1;
                            if (e > 0) {
                                n.textContent = Nl ? Nl.emptyScript : "";
                                for (let i = 0; i < e; i++)
                                    n.append(t[i], Vl()),
                                    sc.nextNode(),
                                    l.push({
                                        type: 2,
                                        index: ++s
                                    });
                                n.append(t[e], Vl())
                            }
                        }
                    } else if (8 === n.nodeType)
                        if (n.data === Gl)
                            l.push({
                                type: 2,
                                index: s
                            });
                        else {
                            let t = -1;
                            for (; -1 !== (t = n.data.indexOf(kl, t + 1)); )
                                l.push({
                                    type: 7,
                                    index: s
                                }),
                                t += kl.length - 1
                        }
                    s++
                }
            }
            static createElement(t, e) {
                const n = zl.createElement("template");
                return n.innerHTML = t,
                n
            }
        }
        function lc(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t
              , i = arguments.length > 3 ? arguments[3] : void 0;
            var r, s, o, a;
            if (e === nc)
                return e;
            let l = void 0 !== i ? null === (r = n._$Co) || void 0 === r ? void 0 : r[i] : n._$Cl;
            const c = Wl(e) ? void 0 : e._$litDirective$;
            return (null == l ? void 0 : l.constructor) !== c && (null === (s = null == l ? void 0 : l._$AO) || void 0 === s || s.call(l, !1),
            void 0 === c ? l = void 0 : (l = new c(t),
            l._$AT(t, n, i)),
            void 0 !== i ? (null !== (o = (a = n)._$Co) && void 0 !== o ? o : a._$Co = [])[i] = l : n._$Cl = l),
            void 0 !== l && (e = lc(t, l._$AS(t, e.values), l, i)),
            e
        }
        class cc {
            constructor(t, e) {
                this._$AV = [],
                this._$AN = void 0,
                this._$AD = t,
                this._$AM = e
            }
            get parentNode() {
                return this._$AM.parentNode
            }
            get _$AU() {
                return this._$AM._$AU
            }
            u(t) {
                var e;
                const {el: {content: n}, parts: i} = this._$AD
                  , r = (null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e ? e : zl).importNode(n, !0);
                sc.currentNode = r;
                let s = sc.nextNode()
                  , o = 0
                  , a = 0
                  , l = i[0];
                for (; void 0 !== l; ) {
                    if (o === l.index) {
                        let e;
                        2 === l.type ? e = new uc(s,s.nextSibling,this,t) : 1 === l.type ? e = new l.ctor(s,l.name,l.strings,this,t) : 6 === l.type && (e = new gc(s,this,t)),
                        this._$AV.push(e),
                        l = i[++a]
                    }
                    o !== (null == l ? void 0 : l.index) && (s = sc.nextNode(),
                    o++)
                }
                return sc.currentNode = zl,
                r
            }
            v(t) {
                let e = 0;
                for (const n of this._$AV)
                    void 0 !== n && (void 0 !== n.strings ? (n._$AI(t, n, e),
                    e += n.strings.length - 2) : n._$AI(t[e])),
                    e++
            }
        }
        class uc {
            constructor(t, e, n, i) {
                var r;
                this.type = 2,
                this._$AH = ic,
                this._$AN = void 0,
                this._$AA = t,
                this._$AB = e,
                this._$AM = n,
                this.options = i,
                this._$Cp = null === (r = null == i ? void 0 : i.isConnected) || void 0 === r || r
            }
            get _$AU() {
                var t, e;
                return null !== (e = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== e ? e : this._$Cp
            }
            get parentNode() {
                let t = this._$AA.parentNode;
                const e = this._$AM;
                return void 0 !== e && 11 === (null == t ? void 0 : t.nodeType) && (t = e.parentNode),
                t
            }
            get startNode() {
                return this._$AA
            }
            get endNode() {
                return this._$AB
            }
            _$AI(t) {
                t = lc(this, t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this),
                Wl(t) ? t === ic || null == t || "" === t ? (this._$AH !== ic && this._$AR(),
                this._$AH = ic) : t !== this._$AH && t !== nc && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : (t=>ql(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]))(t) ? this.T(t) : this._(t)
            }
            k(t) {
                return this._$AA.parentNode.insertBefore(t, this._$AB)
            }
            $(t) {
                this._$AH !== t && (this._$AR(),
                this._$AH = this.k(t))
            }
            _(t) {
                this._$AH !== ic && Wl(this._$AH) ? this._$AA.nextSibling.data = t : this.$(zl.createTextNode(t)),
                this._$AH = t
            }
            g(t) {
                var e;
                const {values: n, _$litType$: i} = t
                  , r = "number" == typeof i ? this._$AC(t) : (void 0 === i.el && (i.el = ac.createElement(oc(i.h, i.h[0]), this.options)),
                i);
                if ((null === (e = this._$AH) || void 0 === e ? void 0 : e._$AD) === r)
                    this._$AH.v(n);
                else {
                    const t = new cc(r,this)
                      , e = t.u(this.options);
                    t.v(n),
                    this.$(e),
                    this._$AH = t
                }
            }
            _$AC(t) {
                let e = rc.get(t.strings);
                return void 0 === e && rc.set(t.strings, e = new ac(t)),
                e
            }
            T(t) {
                ql(this._$AH) || (this._$AH = [],
                this._$AR());
                const e = this._$AH;
                let n, i = 0;
                for (const r of t)
                    i === e.length ? e.push(n = new uc(this.k(Vl()),this.k(Vl()),this,this.options)) : n = e[i],
                    n._$AI(r),
                    i++;
                i < e.length && (this._$AR(n && n._$AB.nextSibling, i),
                e.length = i)
            }
            _$AR() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._$AA.nextSibling
                  , e = arguments.length > 1 ? arguments[1] : void 0;
                var n;
                for (null === (n = this._$AP) || void 0 === n || n.call(this, !1, !0, e); t && t !== this._$AB; ) {
                    const e = t.nextSibling;
                    t.remove(),
                    t = e
                }
            }
            setConnected(t) {
                var e;
                void 0 === this._$AM && (this._$Cp = t,
                null === (e = this._$AP) || void 0 === e || e.call(this, t))
            }
        }
        class hc {
            constructor(t, e, n, i, r) {
                this.type = 1,
                this._$AH = ic,
                this._$AN = void 0,
                this.element = t,
                this.name = e,
                this._$AM = i,
                this.options = r,
                n.length > 2 || "" !== n[0] || "" !== n[1] ? (this._$AH = Array(n.length - 1).fill(new String),
                this.strings = n) : this._$AH = ic
            }
            get tagName() {
                return this.element.tagName
            }
            get _$AU() {
                return this._$AM._$AU
            }
            _$AI(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this
                  , n = arguments.length > 2 ? arguments[2] : void 0
                  , i = arguments.length > 3 ? arguments[3] : void 0;
                const r = this.strings;
                let s = !1;
                if (void 0 === r)
                    t = lc(this, t, e, 0),
                    s = !Wl(t) || t !== this._$AH && t !== nc,
                    s && (this._$AH = t);
                else {
                    const i = t;
                    let o, a;
                    for (t = r[0],
                    o = 0; o < r.length - 1; o++)
                        a = lc(this, i[n + o], e, o),
                        a === nc && (a = this._$AH[o]),
                        s || (s = !Wl(a) || a !== this._$AH[o]),
                        a === ic ? t = ic : t !== ic && (t += (null != a ? a : "") + r[o + 1]),
                        this._$AH[o] = a
                }
                s && !i && this.j(t)
            }
            j(t) {
                t === ic ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "")
            }
        }
        class dc extends hc {
            constructor() {
                super(...arguments),
                this.type = 3
            }
            j(t) {
                this.element[this.name] = t === ic ? void 0 : t
            }
        }
        const pc = Nl ? Nl.emptyScript : "";
        class fc extends hc {
            constructor() {
                super(...arguments),
                this.type = 4
            }
            j(t) {
                t && t !== ic ? this.element.setAttribute(this.name, pc) : this.element.removeAttribute(this.name)
            }
        }
        class Ac extends hc {
            constructor(t, e, n, i, r) {
                super(t, e, n, i, r),
                this.type = 5
            }
            _$AI(t) {
                var e;
                if ((t = null !== (e = lc(this, t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this, 0)) && void 0 !== e ? e : ic) === nc)
                    return;
                const n = this._$AH
                  , i = t === ic && n !== ic || t.capture !== n.capture || t.once !== n.once || t.passive !== n.passive
                  , r = t !== ic && (n === ic || i);
                i && this.element.removeEventListener(this.name, this, n),
                r && this.element.addEventListener(this.name, this, t),
                this._$AH = t
            }
            handleEvent(t) {
                var e, n;
                "function" == typeof this._$AH ? this._$AH.call(null !== (n = null === (e = this.options) || void 0 === e ? void 0 : e.host) && void 0 !== n ? n : this.element, t) : this._$AH.handleEvent(t)
            }
        }
        class gc {
            constructor(t, e, n) {
                this.element = t,
                this.type = 6,
                this._$AN = void 0,
                this._$AM = e,
                this.options = n
            }
            get _$AU() {
                return this._$AM._$AU
            }
            _$AI(t) {
                lc(this, t)
            }
        }
        const mc = Ol.litHtmlPolyfillSupport;
        null == mc || mc(ac, uc),
        (null !== (Ul = Ol.litHtmlVersions) && void 0 !== Ul ? Ul : Ol.litHtmlVersions = []).push("2.8.0");
        const vc = (t,e,n)=>{
            var i, r;
            const s = null !== (i = null == n ? void 0 : n.renderBefore) && void 0 !== i ? i : e;
            let o = s._$litPart$;
            if (void 0 === o) {
                const t = null !== (r = null == n ? void 0 : n.renderBefore) && void 0 !== r ? r : null;
                s._$litPart$ = o = new uc(e.insertBefore(Vl(), t),t,void 0,null != n ? n : {})
            }
            return o._$AI(t),
            o
        }
          , yc = window
          , _c = yc.ShadowRoot && (void 0 === yc.ShadyCSS || yc.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
          , Ec = Symbol()
          , bc = new WeakMap;
        class xc {
            constructor(t, e, n) {
                if (this._$cssResult$ = !0,
                n !== Ec)
                    throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                this.cssText = t,
                this.t = e
            }
            get styleSheet() {
                let t = this.o;
                const e = this.t;
                if (_c && void 0 === t) {
                    const n = void 0 !== e && 1 === e.length;
                    n && (t = bc.get(e)),
                    void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText),
                    n && bc.set(e, t))
                }
                return t
            }
            toString() {
                return this.cssText
            }
        }
        const wc = _c ? t=>t : t=>t instanceof CSSStyleSheet ? (t=>{
            let e = "";
            for (const n of t.cssRules)
                e += n.cssText;
            return (t=>new xc("string" == typeof t ? t : t + "",void 0,Ec))(e)
        }
        )(t) : t;
        var Sc;
        const Cc = window
          , Mc = Cc.trustedTypes
          , Ic = Mc ? Mc.emptyScript : ""
          , Tc = Cc.reactiveElementPolyfillSupport
          , Bc = {
            toAttribute(t, e) {
                switch (e) {
                case Boolean:
                    t = t ? Ic : null;
                    break;
                case Object:
                case Array:
                    t = null == t ? t : JSON.stringify(t)
                }
                return t
            },
            fromAttribute(t, e) {
                let n = t;
                switch (e) {
                case Boolean:
                    n = null !== t;
                    break;
                case Number:
                    n = null === t ? null : Number(t);
                    break;
                case Object:
                case Array:
                    try {
                        n = JSON.parse(t)
                    } catch (t) {
                        n = null
                    }
                }
                return n
            }
        }
          , Rc = (t,e)=>e !== t && (e == e || t == t)
          , Lc = {
            attribute: !0,
            type: String,
            converter: Bc,
            reflect: !1,
            hasChanged: Rc
        }
          , Dc = "finalized";
        class Pc extends HTMLElement {
            constructor() {
                super(),
                this._$Ei = new Map,
                this.isUpdatePending = !1,
                this.hasUpdated = !1,
                this._$El = null,
                this._$Eu()
            }
            static addInitializer(t) {
                var e;
                this.finalize(),
                (null !== (e = this.h) && void 0 !== e ? e : this.h = []).push(t)
            }
            static get observedAttributes() {
                this.finalize();
                const t = [];
                return this.elementProperties.forEach(((e,n)=>{
                    const i = this._$Ep(n, e);
                    void 0 !== i && (this._$Ev.set(i, n),
                    t.push(i))
                }
                )),
                t
            }
            static createProperty(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Lc;
                if (e.state && (e.attribute = !1),
                this.finalize(),
                this.elementProperties.set(t, e),
                !e.noAccessor && !this.prototype.hasOwnProperty(t)) {
                    const n = "symbol" == typeof t ? Symbol() : "__" + t
                      , i = this.getPropertyDescriptor(t, n, e);
                    void 0 !== i && Object.defineProperty(this.prototype, t, i)
                }
            }
            static getPropertyDescriptor(t, e, n) {
                return {
                    get() {
                        return this[e]
                    },
                    set(i) {
                        const r = this[t];
                        this[e] = i,
                        this.requestUpdate(t, r, n)
                    },
                    configurable: !0,
                    enumerable: !0
                }
            }
            static getPropertyOptions(t) {
                return this.elementProperties.get(t) || Lc
            }
            static finalize() {
                if (this.hasOwnProperty(Dc))
                    return !1;
                this[Dc] = !0;
                const t = Object.getPrototypeOf(this);
                if (t.finalize(),
                void 0 !== t.h && (this.h = [...t.h]),
                this.elementProperties = new Map(t.elementProperties),
                this._$Ev = new Map,
                this.hasOwnProperty("properties")) {
                    const t = this.properties
                      , e = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
                    for (const n of e)
                        this.createProperty(n, t[n])
                }
                return this.elementStyles = this.finalizeStyles(this.styles),
                !0
            }
            static finalizeStyles(t) {
                const e = [];
                if (Array.isArray(t)) {
                    const n = new Set(t.flat(1 / 0).reverse());
                    for (const t of n)
                        e.unshift(wc(t))
                } else
                    void 0 !== t && e.push(wc(t));
                return e
            }
            static _$Ep(t, e) {
                const n = e.attribute;
                return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof t ? t.toLowerCase() : void 0
            }
            _$Eu() {
                var t;
                this._$E_ = new Promise((t=>this.enableUpdating = t)),
                this._$AL = new Map,
                this._$Eg(),
                this.requestUpdate(),
                null === (t = this.constructor.h) || void 0 === t || t.forEach((t=>t(this)))
            }
            addController(t) {
                var e, n;
                (null !== (e = this._$ES) && void 0 !== e ? e : this._$ES = []).push(t),
                void 0 !== this.renderRoot && this.isConnected && (null === (n = t.hostConnected) || void 0 === n || n.call(t))
            }
            removeController(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.splice(this._$ES.indexOf(t) >>> 0, 1)
            }
            _$Eg() {
                this.constructor.elementProperties.forEach(((t,e)=>{
                    this.hasOwnProperty(e) && (this._$Ei.set(e, this[e]),
                    delete this[e])
                }
                ))
            }
            createRenderRoot() {
                var t;
                const e = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
                return ((t,e)=>{
                    _c ? t.adoptedStyleSheets = e.map((t=>t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach((e=>{
                        const n = document.createElement("style")
                          , i = yc.litNonce;
                        void 0 !== i && n.setAttribute("nonce", i),
                        n.textContent = e.cssText,
                        t.appendChild(n)
                    }
                    ))
                }
                )(e, this.constructor.elementStyles),
                e
            }
            connectedCallback() {
                var t;
                void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()),
                this.enableUpdating(!0),
                null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                    var e;
                    return null === (e = t.hostConnected) || void 0 === e ? void 0 : e.call(t)
                }
                ))
            }
            enableUpdating(t) {}
            disconnectedCallback() {
                var t;
                null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                    var e;
                    return null === (e = t.hostDisconnected) || void 0 === e ? void 0 : e.call(t)
                }
                ))
            }
            attributeChangedCallback(t, e, n) {
                this._$AK(t, n)
            }
            _$EO(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Lc;
                var i;
                const r = this.constructor._$Ep(t, n);
                if (void 0 !== r && !0 === n.reflect) {
                    const s = (void 0 !== (null === (i = n.converter) || void 0 === i ? void 0 : i.toAttribute) ? n.converter : Bc).toAttribute(e, n.type);
                    this._$El = t,
                    null == s ? this.removeAttribute(r) : this.setAttribute(r, s),
                    this._$El = null
                }
            }
            _$AK(t, e) {
                var n;
                const i = this.constructor
                  , r = i._$Ev.get(t);
                if (void 0 !== r && this._$El !== r) {
                    const t = i.getPropertyOptions(r)
                      , s = "function" == typeof t.converter ? {
                        fromAttribute: t.converter
                    } : void 0 !== (null === (n = t.converter) || void 0 === n ? void 0 : n.fromAttribute) ? t.converter : Bc;
                    this._$El = r,
                    this[r] = s.fromAttribute(e, t.type),
                    this._$El = null
                }
            }
            requestUpdate(t, e, n) {
                let i = !0;
                void 0 !== t && (((n = n || this.constructor.getPropertyOptions(t)).hasChanged || Rc)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e),
                !0 === n.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map),
                this._$EC.set(t, n))) : i = !1),
                !this.isUpdatePending && i && (this._$E_ = this._$Ej())
            }
            async _$Ej() {
                this.isUpdatePending = !0;
                try {
                    await this._$E_
                } catch (t) {
                    Promise.reject(t)
                }
                const t = this.scheduleUpdate();
                return null != t && await t,
                !this.isUpdatePending
            }
            scheduleUpdate() {
                return this.performUpdate()
            }
            performUpdate() {
                var t;
                if (!this.isUpdatePending)
                    return;
                this.hasUpdated,
                this._$Ei && (this._$Ei.forEach(((t,e)=>this[e] = t)),
                this._$Ei = void 0);
                let e = !1;
                const n = this._$AL;
                try {
                    e = this.shouldUpdate(n),
                    e ? (this.willUpdate(n),
                    null === (t = this._$ES) || void 0 === t || t.forEach((t=>{
                        var e;
                        return null === (e = t.hostUpdate) || void 0 === e ? void 0 : e.call(t)
                    }
                    )),
                    this.update(n)) : this._$Ek()
                } catch (t) {
                    throw e = !1,
                    this._$Ek(),
                    t
                }
                e && this._$AE(n)
            }
            willUpdate(t) {}
            _$AE(t) {
                var e;
                null === (e = this._$ES) || void 0 === e || e.forEach((t=>{
                    var e;
                    return null === (e = t.hostUpdated) || void 0 === e ? void 0 : e.call(t)
                }
                )),
                this.hasUpdated || (this.hasUpdated = !0,
                this.firstUpdated(t)),
                this.updated(t)
            }
            _$Ek() {
                this._$AL = new Map,
                this.isUpdatePending = !1
            }
            get updateComplete() {
                return this.getUpdateComplete()
            }
            getUpdateComplete() {
                return this._$E_
            }
            shouldUpdate(t) {
                return !0
            }
            update(t) {
                void 0 !== this._$EC && (this._$EC.forEach(((t,e)=>this._$EO(e, this[e], t))),
                this._$EC = void 0),
                this._$Ek()
            }
            updated(t) {}
            firstUpdated(t) {}
        }
        var Uc, Oc;
        Pc[Dc] = !0,
        Pc.elementProperties = new Map,
        Pc.elementStyles = [],
        Pc.shadowRootOptions = {
            mode: "open"
        },
        null == Tc || Tc({
            ReactiveElement: Pc
        }),
        (null !== (Sc = Cc.reactiveElementVersions) && void 0 !== Sc ? Sc : Cc.reactiveElementVersions = []).push("1.6.3");
        class Nc extends Pc {
            constructor() {
                super(...arguments),
                this.renderOptions = {
                    host: this
                },
                this._$Do = void 0
            }
            createRenderRoot() {
                var t, e;
                const n = super.createRenderRoot();
                return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = n.firstChild),
                n
            }
            update(t) {
                const e = this.render();
                this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
                super.update(t),
                this._$Do = vc(e, this.renderRoot, this.renderOptions)
            }
            connectedCallback() {
                var t;
                super.connectedCallback(),
                null === (t = this._$Do) || void 0 === t || t.setConnected(!0)
            }
            disconnectedCallback() {
                var t;
                super.disconnectedCallback(),
                null === (t = this._$Do) || void 0 === t || t.setConnected(!1)
            }
            render() {
                return nc
            }
        }
        Nc.finalized = !0,
        Nc._$litElement$ = !0,
        null === (Uc = globalThis.litElementHydrateSupport) || void 0 === Uc || Uc.call(globalThis, {
            LitElement: Nc
        });
        const Fc = globalThis.litElementPolyfillSupport;
        null == Fc || Fc({
            LitElement: Nc
        }),
        (null !== (Oc = globalThis.litElementVersions) && void 0 !== Oc ? Oc : globalThis.litElementVersions = []).push("3.3.3");
        const Qc = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported
          , kc = Qc && null != self.XRSession.prototype.requestHitTestSource
          , Gc = null != self.ResizeObserver
          , Hc = null != self.IntersectionObserver
          , zc = kc
          , Vc = (()=>{
            const t = navigator.userAgent || navigator.vendor || self.opera;
            let e = !1;
            return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0),
            e
        }
        )();
        /\bCrOS\b/.test(navigator.userAgent);
        const Wc = /android/i.test(navigator.userAgent)
          , qc = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1
          , jc = /Safari\//.test(navigator.userAgent)
          , Xc = /firefox/i.test(navigator.userAgent)
          , Yc = /OculusBrowser/.test(navigator.userAgent);
        qc && /CriOS\//.test(navigator.userAgent);
        var Kc = Wc && !Yc;
        Kc = Kc || Xc && Vc && !jc;
        const Jc = Boolean(window.webkit && window.webkit.messageHandlers)
          , $c = (()=>{
            if (qc) {
                if (Jc)
                    return Boolean(/CriOS\/|EdgiOS\/|FxiOS\/|YaBrowser\/|Mozilla\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent));
                {
                    const t = document.createElement("a");
                    return Boolean(t.relList && t.relList.supports && t.relList.supports("ar"))
                }
            }
            return !1
        }
        )()
          , Zc = t=>t && "null" !== t ? eu(t) : null
          , tu = ()=>{
            if (zc)
                return;
            const t = [];
            throw Qc || t.push("WebXR Device API"),
            kc || t.push("WebXR Hit Test API"),
            new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(", ")}`)
        }
          , eu = t=>new URL(t,window.location.toString()).toString()
          , nu = (t,e)=>{
            let n = null;
            return function() {
                for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)
                    r[s] = arguments[s];
                null != n && self.clearTimeout(n),
                n = self.setTimeout((()=>{
                    n = null,
                    t(...r)
                }
                ), e)
            }
        }
          , iu = (t,e,n)=>Math.max(e, Math.min(n, t))
          , ru = (()=>{
            const t = (()=>{
                var t;
                if (null === (t = document.documentElement.getAttribute("itemtype")) || void 0 === t ? void 0 : t.includes("schema.org/SearchResultsPage"))
                    return !0;
                const e = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];
                for (const t of e)
                    if ("viewport" === t.name)
                        return !0;
                return !1
            }
            )();
            return t || console.warn('No <meta name="viewport"> detected; <zarbo-widget> will cap pixel density at 1.'),
            ()=>t ? window.devicePixelRatio : 1
        }
        )()
          , su = (()=>{
            const t = new RegExp("[?&]zarbo-widget-debug-mode(&|$)");
            return ()=>self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t)
        }
        )()
          , ou = function(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            return new Promise((i=>{
                t.addEventListener(e, (function r(s) {
                    n && !n(s) || (i(s),
                    t.removeEventListener(e, r))
                }
                ))
            }
            ))
        };
        var au = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const lu = Symbol("currentEnvironmentMap")
          , cu = Symbol("currentBackground")
          , uu = Symbol("updateEnvironment")
          , hu = Symbol("cancelEnvironmentUpdate")
          , du = ec`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
  outline-offset: -1px;
  outline-width: 1px;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/zarbo-widget/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          role="button"
          href="javascript:void(0);"
          aria-label="View in your space">
        ${ec`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${ec`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${ec`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`
          , pu = new WeakMap;
        function fu() {
            let t, e;
            function n(t, e, n, i, r, s) {
                const o = s.num_components()
                  , a = n.num_points() * o
                  , l = a * r.BYTES_PER_ELEMENT
                  , c = function(t, e) {
                    switch (e) {
                    case Float32Array:
                        return t.DT_FLOAT32;
                    case Int8Array:
                        return t.DT_INT8;
                    case Int16Array:
                        return t.DT_INT16;
                    case Int32Array:
                        return t.DT_INT32;
                    case Uint8Array:
                        return t.DT_UINT8;
                    case Uint16Array:
                        return t.DT_UINT16;
                    case Uint32Array:
                        return t.DT_UINT32
                    }
                }(t, r)
                  , u = t._malloc(l);
                e.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                const h = new r(t.HEAPF32.buffer,u,a).slice();
                return t._free(u),
                {
                    name: i,
                    array: h,
                    itemSize: o
                }
            }
            onmessage = function(i) {
                const r = i.data;
                switch (r.type) {
                case "init":
                    t = r.decoderConfig,
                    e = new Promise((function(e) {
                        t.onModuleLoaded = function(t) {
                            e({
                                draco: t
                            })
                        }
                        ,
                        DracoDecoderModule(t)
                    }
                    ));
                    break;
                case "decode":
                    const i = r.buffer
                      , s = r.taskConfig;
                    e.then((t=>{
                        const e = t.draco
                          , o = new e.Decoder;
                        try {
                            const t = function(t, e, i, r) {
                                const s = r.attributeIDs
                                  , o = r.attributeTypes;
                                let a, l;
                                const c = e.GetEncodedGeometryType(i);
                                if (c === t.TRIANGULAR_MESH)
                                    a = new t.Mesh,
                                    l = e.DecodeArrayToMesh(i, i.byteLength, a);
                                else {
                                    if (c !== t.POINT_CLOUD)
                                        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    a = new t.PointCloud,
                                    l = e.DecodeArrayToPointCloud(i, i.byteLength, a)
                                }
                                if (!l.ok() || 0 === a.ptr)
                                    throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const u = {
                                    index: null,
                                    attributes: []
                                };
                                for (const i in s) {
                                    const l = self[o[i]];
                                    let c, h;
                                    if (r.useUniqueIDs)
                                        h = s[i],
                                        c = e.GetAttributeByUniqueId(a, h);
                                    else {
                                        if (h = e.GetAttributeId(a, t[s[i]]),
                                        -1 === h)
                                            continue;
                                        c = e.GetAttribute(a, h)
                                    }
                                    const d = n(t, e, a, i, l, c);
                                    "color" === i && (d.vertexColorSpace = r.vertexColorSpace),
                                    u.attributes.push(d)
                                }
                                return c === t.TRIANGULAR_MESH && (u.index = function(t, e, n) {
                                    const i = 3 * n.num_faces()
                                      , r = 4 * i
                                      , s = t._malloc(r);
                                    e.GetTrianglesUInt32Array(n, r, s);
                                    const o = new Uint32Array(t.HEAPF32.buffer,s,i).slice();
                                    return t._free(s),
                                    {
                                        array: o,
                                        itemSize: 1
                                    }
                                }(t, e, a)),
                                t.destroy(a),
                                u
                            }(e, o, new Int8Array(i), s)
                              , a = t.attributes.map((t=>t.array.buffer));
                            t.index && a.push(t.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: t
                            }, a)
                        } catch (t) {
                            console.error(t),
                            self.postMessage({
                                type: "error",
                                id: r.id,
                                error: t.message
                            })
                        } finally {
                            e.destroy(o)
                        }
                    }
                    ))
                }
            }
        }
        function Au(t, e) {
            if (0 === e)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                t;
            if (2 === e || 1 === e) {
                let n = t.getIndex();
                if (null === n) {
                    const e = []
                      , i = t.getAttribute("position");
                    if (void 0 === i)
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        t;
                    for (let t = 0; t < i.count; t++)
                        e.push(t);
                    t.setIndex(e),
                    n = t.getIndex()
                }
                const i = n.count - 2
                  , r = [];
                if (2 === e)
                    for (let t = 1; t <= i; t++)
                        r.push(n.getX(0)),
                        r.push(n.getX(t)),
                        r.push(n.getX(t + 1));
                else
                    for (let t = 0; t < i; t++)
                        t % 2 == 0 ? (r.push(n.getX(t)),
                        r.push(n.getX(t + 1)),
                        r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)),
                        r.push(n.getX(t + 1)),
                        r.push(n.getX(t)));
                r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const s = t.clone();
                return s.setIndex(r),
                s.clearGroups(),
                s
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
            t
        }
        class gu extends Da {
            constructor(t) {
                super(t),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(t) {
                    return new bu(t)
                }
                )),
                this.register((function(t) {
                    return new Bu(t)
                }
                )),
                this.register((function(t) {
                    return new Ru(t)
                }
                )),
                this.register((function(t) {
                    return new Lu(t)
                }
                )),
                this.register((function(t) {
                    return new wu(t)
                }
                )),
                this.register((function(t) {
                    return new Su(t)
                }
                )),
                this.register((function(t) {
                    return new Cu(t)
                }
                )),
                this.register((function(t) {
                    return new Mu(t)
                }
                )),
                this.register((function(t) {
                    return new Eu(t)
                }
                )),
                this.register((function(t) {
                    return new Iu(t)
                }
                )),
                this.register((function(t) {
                    return new xu(t)
                }
                )),
                this.register((function(t) {
                    return new Tu(t)
                }
                )),
                this.register((function(t) {
                    return new yu(t)
                }
                )),
                this.register((function(t) {
                    return new Du(t)
                }
                )),
                this.register((function(t) {
                    return new Pu(t)
                }
                ))
            }
            load(t, e, n, i) {
                const r = this;
                let s;
                s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : nl.extractUrlBase(t),
                this.manager.itemStart(t);
                const o = function(e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                  , a = new Oa(this.manager);
                a.setPath(this.path),
                a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(t, (function(n) {
                    try {
                        r.parse(n, s, (function(n) {
                            e(n),
                            r.manager.itemEnd(t)
                        }
                        ), o)
                    } catch (t) {
                        o(t)
                    }
                }
                ), n, o)
            }
            setDRACOLoader(t) {
                return this.dracoLoader = t,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(t) {
                return this.ktx2Loader = t,
                this
            }
            setMeshoptDecoder(t) {
                return this.meshoptDecoder = t,
                this
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
                this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                this
            }
            parse(t, e, n, i) {
                let r;
                const s = {}
                  , o = {}
                  , a = new TextDecoder;
                if ("string" == typeof t)
                    r = JSON.parse(t);
                else if (t instanceof ArrayBuffer)
                    if (a.decode(new Uint8Array(t,0,4)) === Uu) {
                        try {
                            s[vu.KHR_BINARY_GLTF] = new Ou(t)
                        } catch (t) {
                            return void (i && i(t))
                        }
                        r = JSON.parse(s[vu.KHR_BINARY_GLTF].content)
                    } else
                        r = JSON.parse(a.decode(t));
                else
                    r = t;
                if (void 0 === r.asset || r.asset.version[0] < 2)
                    return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new sh(r,{
                    path: e || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let t = 0; t < this.pluginCallbacks.length; t++) {
                    const e = this.pluginCallbacks[t](l);
                    o[e.name] = e,
                    s[e.name] = !0
                }
                if (r.extensionsUsed)
                    for (let t = 0; t < r.extensionsUsed.length; ++t) {
                        const e = r.extensionsUsed[t]
                          , n = r.extensionsRequired || [];
                        switch (e) {
                        case vu.KHR_MATERIALS_UNLIT:
                            s[e] = new _u;
                            break;
                        case vu.KHR_DRACO_MESH_COMPRESSION:
                            s[e] = new Nu(r,this.dracoLoader);
                            break;
                        case vu.KHR_TEXTURE_TRANSFORM:
                            s[e] = new Fu;
                            break;
                        case vu.KHR_MESH_QUANTIZATION:
                            s[e] = new Qu;
                            break;
                        default:
                            n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                l.setExtensions(s),
                l.setPlugins(o),
                l.parse(n, i)
            }
            parseAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(t, e, i, r)
                }
                ))
            }
        }
        function mu() {
            let t = {};
            return {
                get: function(e) {
                    return t[e]
                },
                add: function(e, n) {
                    t[e] = n
                },
                remove: function(e) {
                    delete t[e]
                },
                removeAll: function() {
                    t = {}
                }
            }
        }
        const vu = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class yu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser
                  , e = this.parser.json.nodes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser
                  , n = "light:" + t;
                let i = e.cache.get(n);
                if (i)
                    return i;
                const r = e.json
                  , s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
                let o;
                const a = new Ln(16777215);
                void 0 !== s.color && a.setRGB(s.color[0], s.color[1], s.color[2], ct);
                const l = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                case "directional":
                    o = new Za(a),
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                case "point":
                    o = new Ja(a),
                    o.distance = l;
                    break;
                case "spot":
                    o = new qa(a),
                    o.distance = l,
                    s.spot = s.spot || {},
                    s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                    s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                    o.angle = s.spot.outerConeAngle,
                    o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return o.position.set(0, 0, 0),
                o.decay = 2,
                Zu(o, s),
                void 0 !== s.intensity && (o.intensity = s.intensity),
                o.name = e.createUniqueName(s.name || "light_" + t),
                i = Promise.resolve(o),
                e.cache.add(n, i),
                i
            }
            getDependency(t, e) {
                if ("light" === t)
                    return this._loadLight(e)
            }
            createNodeAttachment(t) {
                const e = this
                  , n = this.parser
                  , i = n.json.nodes[t]
                  , r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(t) {
                    return n._getNodeRef(e.cache, r, t)
                }
                ))
            }
        }
        class _u {
            constructor() {
                this.name = vu.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Pn
            }
            extendParams(t, e, n) {
                const i = [];
                t.color = new Ln(1,1,1),
                t.opacity = 1;
                const r = e.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const e = r.baseColorFactor;
                        t.color.setRGB(e[0], e[1], e[2], ct),
                        t.opacity = e[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture, lt))
                }
                return Promise.all(i)
            }
        }
        class Eu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (e.emissiveIntensity = i),
                Promise.resolve()
            }
        }
        class bu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
                void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
                void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)),
                void 0 !== s.clearcoatNormalTexture.scale)) {
                    const t = s.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new Nt(t,t)
                }
                return Promise.all(r)
            }
        }
        class xu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.iridescenceFactor && (e.iridescence = s.iridescenceFactor),
                void 0 !== s.iridescenceTexture && r.push(n.assignTexture(e, "iridescenceMap", s.iridescenceTexture)),
                void 0 !== s.iridescenceIor && (e.iridescenceIOR = s.iridescenceIor),
                void 0 === e.iridescenceThicknessRange && (e.iridescenceThicknessRange = [100, 400]),
                void 0 !== s.iridescenceThicknessMinimum && (e.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
                void 0 !== s.iridescenceThicknessMaximum && (e.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
                void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(e, "iridescenceThicknessMap", s.iridescenceThicknessTexture)),
                Promise.all(r)
            }
        }
        class wu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_SHEEN
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [];
                e.sheenColor = new Ln(0,0,0),
                e.sheenRoughness = 0,
                e.sheen = 1;
                const s = i.extensions[this.name];
                if (void 0 !== s.sheenColorFactor) {
                    const t = s.sheenColorFactor;
                    e.sheenColor.setRGB(t[0], t[1], t[2], ct)
                }
                return void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor),
                void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture, lt)),
                void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)),
                Promise.all(r)
            }
        }
        class Su {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
                void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
                Promise.all(r)
            }
        }
        class Cu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
                void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
                e.attenuationDistance = s.attenuationDistance || 1 / 0;
                const o = s.attenuationColor || [1, 1, 1];
                return e.attenuationColor = (new Ln).setRGB(o[0], o[1], o[2], ct),
                Promise.all(r)
            }
        }
        class Mu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return e.ior = void 0 !== i.ior ? i.ior : 1.5,
                Promise.resolve()
            }
        }
        class Iu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
                void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return e.specularColor = (new Ln).setRGB(o[0], o[1], o[2], ct),
                void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture, lt)),
                Promise.all(r)
            }
        }
        class Tu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? da : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.anisotropyStrength && (e.anisotropy = s.anisotropyStrength),
                void 0 !== s.anisotropyRotation && (e.anisotropyRotation = s.anisotropyRotation),
                void 0 !== s.anisotropyTexture && r.push(n.assignTexture(e, "anisotropyMap", s.anisotropyTexture)),
                Promise.all(r)
            }
        }
        class Bu {
            constructor(t) {
                this.parser = t,
                this.name = vu.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser
                  , n = e.json
                  , i = n.textures[t];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name]
                  , s = e.options.ktx2Loader;
                if (!s) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, r.source, s)
            }
        }
        class Ru {
            constructor(t) {
                this.parser = t,
                this.name = vu.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[t];
                if (!r.extensions || !r.extensions[e])
                    return null;
                const s = r.extensions[e]
                  , o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(t, s.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    e.onload = e.onerror = function() {
                        t(1 === e.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Lu {
            constructor(t) {
                this.parser = t,
                this.name = vu.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[t];
                if (!r.extensions || !r.extensions[e])
                    return null;
                const s = r.extensions[e]
                  , o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(t, s.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(t)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(t) {
                    const e = new Image;
                    e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    e.onload = e.onerror = function() {
                        t(1 === e.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Du {
            constructor(t) {
                this.name = vu.EXT_MESHOPT_COMPRESSION,
                this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json
                  , n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name]
                      , i = this.parser.getDependency("buffer", t.buffer)
                      , r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function(e) {
                        const n = t.byteOffset || 0
                          , i = t.byteLength || 0
                          , s = t.count
                          , o = t.byteStride
                          , a = new Uint8Array(e,n,i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, o, a, t.mode, t.filter).then((function(t) {
                            return t.buffer
                        }
                        )) : r.ready.then((function() {
                            const e = new ArrayBuffer(s * o);
                            return r.decodeGltfBuffer(new Uint8Array(e), s, o, a, t.mode, t.filter),
                            e
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class Pu {
            constructor(t) {
                this.name = vu.EXT_MESH_GPU_INSTANCING,
                this.parser = t
            }
            createNodeMesh(t) {
                const e = this.parser.json
                  , n = e.nodes[t];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const i = e.meshes[n.mesh];
                for (const t of i.primitives)
                    if (t.mode !== zu.TRIANGLES && t.mode !== zu.TRIANGLE_STRIP && t.mode !== zu.TRIANGLE_FAN && void 0 !== t.mode)
                        return null;
                const r = n.extensions[this.name].attributes
                  , s = []
                  , o = {};
                for (const t in r)
                    s.push(this.parser.getDependency("accessor", r[t]).then((e=>(o[t] = e,
                    o[t]))));
                return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(t)),
                Promise.all(s).then((t=>{
                    const e = t.pop()
                      , n = e.isGroup ? e.children : [e]
                      , i = t[0].count
                      , r = [];
                    for (const t of n) {
                        const e = new Ge
                          , n = new he
                          , s = new ue
                          , a = new he(1,1,1)
                          , l = new Go(t.geometry,t.material,i);
                        for (let t = 0; t < i; t++)
                            o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, t),
                            o.ROTATION && s.fromBufferAttribute(o.ROTATION, t),
                            o.SCALE && a.fromBufferAttribute(o.SCALE, t),
                            l.setMatrixAt(t, e.compose(n, s, a));
                        for (const e in o)
                            "TRANSLATION" !== e && "ROTATION" !== e && "SCALE" !== e && t.geometry.setAttribute(e, o[e]);
                        pn.prototype.copy.call(l, t),
                        this.parser.assignFinalMaterial(l),
                        r.push(l)
                    }
                    return e.isGroup ? (e.clear(),
                    e.add(...r),
                    e) : r[0]
                }
                )))
            }
        }
        const Uu = "glTF";
        class Ou {
            constructor(t) {
                this.name = vu.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const e = new DataView(t,0,12)
                  , n = new TextDecoder;
                if (this.header = {
                    magic: n.decode(new Uint8Array(t.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                },
                this.header.magic !== Uu)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12
                  , r = new DataView(t,12);
                let s = 0;
                for (; s < i; ) {
                    const e = r.getUint32(s, !0);
                    s += 4;
                    const i = r.getUint32(s, !0);
                    if (s += 4,
                    1313821514 === i) {
                        const i = new Uint8Array(t,12 + s,e);
                        this.content = n.decode(i)
                    } else if (5130562 === i) {
                        const n = 12 + s;
                        this.body = t.slice(n, n + e)
                    }
                    s += e
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Nu {
            constructor(t, e) {
                if (!e)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = vu.KHR_DRACO_MESH_COMPRESSION,
                this.json = t,
                this.dracoLoader = e,
                this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json
                  , i = this.dracoLoader
                  , r = t.extensions[this.name].bufferView
                  , s = t.extensions[this.name].attributes
                  , o = {}
                  , a = {}
                  , l = {};
                for (const t in s) {
                    const e = Xu[t] || t.toLowerCase();
                    o[e] = s[t]
                }
                for (const e in t.attributes) {
                    const i = Xu[e] || e.toLowerCase();
                    if (void 0 !== s[e]) {
                        const r = n.accessors[t.attributes[e]]
                          , s = Vu[r.componentType];
                        l[i] = s.name,
                        a[i] = !0 === r.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function(t) {
                    return new Promise((function(e) {
                        i.decodeDracoFile(t, (function(t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e]
                                  , i = a[e];
                                void 0 !== i && (n.normalized = i)
                            }
                            e(t)
                        }
                        ), o, l)
                    }
                    ))
                }
                ))
            }
        }
        class Fu {
            constructor() {
                this.name = vu.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && e.texCoord !== t.channel || void 0 !== e.offset || void 0 !== e.rotation || void 0 !== e.scale ? (t = t.clone(),
                void 0 !== e.texCoord && (t.channel = e.texCoord),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                t.needsUpdate = !0,
                t) : t
            }
        }
        class Qu {
            constructor() {
                this.name = vu.KHR_MESH_QUANTIZATION
            }
        }
        class ku extends ma {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i * 3 + i;
                for (let t = 0; t !== i; t++)
                    e[t] = n[r + t];
                return e
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = 2 * o
                  , l = 3 * o
                  , c = i - e
                  , u = (n - e) / c
                  , h = u * u
                  , d = h * u
                  , p = t * l
                  , f = p - l
                  , A = -2 * d + 3 * h
                  , g = d - h
                  , m = 1 - A
                  , v = g - h + u;
                for (let t = 0; t !== o; t++) {
                    const e = s[f + t + o]
                      , n = s[f + t + a] * c
                      , i = s[p + t + o]
                      , l = s[p + t] * c;
                    r[t] = m * e + v * n + A * i + g * l
                }
                return r
            }
        }
        const Gu = new ue;
        class Hu extends ku {
            interpolate_(t, e, n, i) {
                const r = super.interpolate_(t, e, n, i);
                return Gu.fromArray(r).normalize().toArray(r),
                r
            }
        }
        const zu = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , Vu = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , Wu = {
            9728: S,
            9729: I,
            9984: C,
            9985: T,
            9986: M,
            9987: B
        }
          , qu = {
            33071: x,
            33648: w,
            10497: b
        }
          , ju = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , Xu = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , Yu = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , Ku = {
            CUBICSPLINE: void 0,
            LINEAR: et,
            STEP: tt
        };
        function Ju(t) {
            return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new ha({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0
            })),
            t.DefaultMaterial
        }
        function $u(t, e, n) {
            for (const i in n.extensions)
                void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
                e.userData.gltfExtensions[i] = n.extensions[i])
        }
        function Zu(t, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }
        function th(t, e) {
            if (t.updateMorphTargets(),
            void 0 !== e.weights)
                for (let n = 0, i = e.weights.length; n < i; n++)
                    t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, i = n.length; e < i; e++)
                        t.morphTargetDictionary[n[e]] = e
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function eh(t) {
            let e;
            const n = t.extensions && t.extensions[vu.KHR_DRACO_MESH_COMPRESSION];
            if (e = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + nh(n.attributes) : t.indices + ":" + nh(t.attributes) + ":" + t.mode,
            void 0 !== t.targets)
                for (let n = 0, i = t.targets.length; n < i; n++)
                    e += ":" + nh(t.targets[n]);
            return e
        }
        function nh(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let i = 0, r = n.length; i < r; i++)
                e += n[i] + ":" + t[n[i]] + ";";
            return e
        }
        function ih(t) {
            switch (t) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const rh = new Ge;
        class sh {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.json = t,
                this.extensions = {},
                this.plugins = {},
                this.options = e,
                this.cache = new mu,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let n = !1
                  , i = !1
                  , r = -1;
                "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                i = navigator.userAgent.indexOf("Firefox") > -1,
                r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
                "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new Qa(this.options.manager) : this.textureLoader = new il(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new Oa(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this
                  , i = this.json
                  , r = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll((function(t) {
                    return t._markDefs && t._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(t) {
                    return t.beforeRoot && t.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(e) {
                    const s = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return $u(r, s, i),
                    Zu(s, i),
                    Promise.all(n._invokeAll((function(t) {
                        return t.afterRoot && t.afterRoot(s)
                    }
                    ))).then((function() {
                        t(s)
                    }
                    ))
                }
                )).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || []
                  , e = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n].joints;
                    for (let e = 0, n = i.length; e < n; e++)
                        t[i[e]].isBone = !0
                }
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                    void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                    void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1)
                    return n;
                const i = n.clone()
                  , r = (t,e)=>{
                    const n = this.associations.get(t);
                    null != n && this.associations.set(e, n);
                    for (const [n,i] of t.children.entries())
                        r(i, e.children[n])
                }
                ;
                return r(n, i),
                i.name += "_instance_" + t.uses[e]++,
                i
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const i = t(e[n]);
                    if (i)
                        return i
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let i = 0; i < e.length; i++) {
                    const r = t(e[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let i = this.cache.get(n);
                if (!i) {
                    switch (t) {
                    case "scene":
                        i = this.loadScene(e);
                        break;
                    case "node":
                        i = this._invokeOne((function(t) {
                            return t.loadNode && t.loadNode(e)
                        }
                        ));
                        break;
                    case "mesh":
                        i = this._invokeOne((function(t) {
                            return t.loadMesh && t.loadMesh(e)
                        }
                        ));
                        break;
                    case "accessor":
                        i = this.loadAccessor(e);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(t) {
                            return t.loadBufferView && t.loadBufferView(e)
                        }
                        ));
                        break;
                    case "buffer":
                        i = this.loadBuffer(e);
                        break;
                    case "material":
                        i = this._invokeOne((function(t) {
                            return t.loadMaterial && t.loadMaterial(e)
                        }
                        ));
                        break;
                    case "texture":
                        i = this._invokeOne((function(t) {
                            return t.loadTexture && t.loadTexture(e)
                        }
                        ));
                        break;
                    case "skin":
                        i = this.loadSkin(e);
                        break;
                    case "animation":
                        i = this._invokeOne((function(t) {
                            return t.loadAnimation && t.loadAnimation(e)
                        }
                        ));
                        break;
                    case "camera":
                        i = this.loadCamera(e);
                        break;
                    default:
                        if (i = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(t, e)
                        }
                        )),
                        !i)
                            throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this
                      , i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(i.map((function(e, i) {
                        return n.getDependency(t, i)
                    }
                    ))),
                    this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t]
                  , n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type)
                    throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t)
                    return Promise.resolve(this.extensions[vu.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(t, r) {
                    n.load(nl.resolveURL(e.uri, i.path), t, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function(t) {
                    const n = e.byteLength || 0
                      , i = e.byteOffset || 0;
                    return t.slice(i, i + n)
                }
                ))
            }
            loadAccessor(t) {
                const e = this
                  , n = this.json
                  , i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const t = ju[i.type]
                      , e = Vu[i.componentType]
                      , n = !0 === i.normalized
                      , r = new e(i.count * t);
                    return Promise.resolve(new Qn(r,t,n))
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
                void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                Promise.all(r).then((function(t) {
                    const r = t[0]
                      , s = ju[i.type]
                      , o = Vu[i.componentType]
                      , a = o.BYTES_PER_ELEMENT
                      , l = a * s
                      , c = i.byteOffset || 0
                      , u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                      , h = !0 === i.normalized;
                    let d, p;
                    if (u && u !== l) {
                        const t = Math.floor(c / u)
                          , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                        let l = e.cache.get(n);
                        l || (d = new o(r,t * u,i.count * u / a),
                        l = new Ao(d,u / a),
                        e.cache.add(n, l)),
                        p = new mo(l,s,c % u / a,h)
                    } else
                        d = null === r ? new o(i.count * s) : new o(r,c,i.count * s),
                        p = new Qn(d,s,h);
                    if (void 0 !== i.sparse) {
                        const e = ju.SCALAR
                          , n = Vu[i.sparse.indices.componentType]
                          , a = i.sparse.indices.byteOffset || 0
                          , l = i.sparse.values.byteOffset || 0
                          , c = new n(t[1],a,i.sparse.count * e)
                          , u = new o(t[2],l,i.sparse.count * s);
                        null !== r && (p = new Qn(p.array.slice(),p.itemSize,p.normalized));
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            if (p.setX(e, u[t * s]),
                            s >= 2 && p.setY(e, u[t * s + 1]),
                            s >= 3 && p.setZ(e, u[t * s + 2]),
                            s >= 4 && p.setW(e, u[t * s + 3]),
                            s >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }
                ))
            }
            loadTexture(t) {
                const e = this.json
                  , n = this.options
                  , i = e.textures[t].source
                  , r = e.images[i];
                let s = this.textureLoader;
                if (r.uri) {
                    const t = n.manager.getHandler(r.uri);
                    null !== t && (s = t)
                }
                return this.loadTextureImage(t, i, s)
            }
            loadTextureImage(t, e, n) {
                const i = this
                  , r = this.json
                  , s = r.textures[t]
                  , o = r.images[e]
                  , a = (o.uri || o.bufferView) + ":" + s.sampler;
                if (this.textureCache[a])
                    return this.textureCache[a];
                const l = this.loadImageSource(e, n).then((function(e) {
                    e.flipY = !1,
                    e.name = s.name || o.name || "",
                    "" === e.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (e.name = o.uri);
                    const n = (r.samplers || {})[s.sampler] || {};
                    return e.magFilter = Wu[n.magFilter] || I,
                    e.minFilter = Wu[n.minFilter] || B,
                    e.wrapS = qu[n.wrapS] || b,
                    e.wrapT = qu[n.wrapT] || b,
                    i.associations.set(e, {
                        textures: t
                    }),
                    e
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[a] = l,
                l
            }
            loadImageSource(t, e) {
                const n = this.json
                  , i = this.options;
                if (void 0 !== this.sourceCache[t])
                    return this.sourceCache[t].then((t=>t.clone()));
                const r = n.images[t]
                  , s = self.URL || self.webkitURL;
                let o = r.uri || ""
                  , a = !1;
                if (void 0 !== r.bufferView)
                    o = this.getDependency("bufferView", r.bufferView).then((function(t) {
                        a = !0;
                        const e = new Blob([t],{
                            type: r.mimeType
                        });
                        return o = s.createObjectURL(e),
                        o
                    }
                    ));
                else if (void 0 === r.uri)
                    throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const l = Promise.resolve(o).then((function(t) {
                    return new Promise((function(n, r) {
                        let s = n;
                        !0 === e.isImageBitmapLoader && (s = function(t) {
                            const e = new re(t);
                            e.needsUpdate = !0,
                            n(e)
                        }
                        ),
                        e.load(nl.resolveURL(t, i.path), s, void 0, r)
                    }
                    ))
                }
                )).then((function(t) {
                    var e;
                    return !0 === a && s.revokeObjectURL(o),
                    t.userData.mimeType = r.mimeType || ((e = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
                    t
                }
                )).catch((function(t) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", o),
                    t
                }
                ));
                return this.sourceCache[t] = l,
                l
            }
            assignTexture(t, e, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(s) {
                    if (!s)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord),
                    r.extensions[vu.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[vu.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = r.associations.get(s);
                            s = r.extensions[vu.KHR_TEXTURE_TRANSFORM].extendTexture(s, t),
                            r.associations.set(s, e)
                        }
                    }
                    return void 0 !== i && (s.colorSpace = i),
                    t[e] = s,
                    s
                }
                ))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const i = void 0 === e.attributes.tangent
                  , r = void 0 !== e.attributes.color
                  , s = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new Zo,
                    Mn.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    e.map = n.map,
                    e.sizeAttenuation = !1,
                    this.cache.add(t, e)),
                    n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new Ho,
                    Mn.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    e.map = n.map,
                    this.cache.add(t, e)),
                    n = e
                }
                if (i || r || s) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    i && (t += "derivative-tangents:"),
                    r && (t += "vertex-colors:"),
                    s && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(),
                    r && (e.vertexColors = !0),
                    s && (e.flatShading = !0),
                    i && (e.normalScale && (e.normalScale.y *= -1),
                    e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                    this.cache.add(t, e),
                    this.associations.set(e, this.associations.get(n))),
                    n = e
                }
                t.material = n
            }
            getMaterialType() {
                return ha
            }
            loadMaterial(t) {
                const e = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.materials[t];
                let s;
                const o = {}
                  , a = [];
                if ((r.extensions || {})[vu.KHR_MATERIALS_UNLIT]) {
                    const t = i[vu.KHR_MATERIALS_UNLIT];
                    s = t.getMaterialType(),
                    a.push(t.extendParams(o, r, e))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (o.color = new Ln(1,1,1),
                    o.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        o.color.setRGB(t[0], t[1], t[2], ct),
                        o.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && a.push(e.assignTexture(o, "map", n.baseColorTexture, lt)),
                    o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (a.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)),
                    a.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))),
                    s = this._invokeOne((function(e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    }
                    )),
                    a.push(Promise.all(this._invokeAll((function(e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, o)
                    }
                    ))))
                }
                !0 === r.doubleSided && (o.side = 2);
                const l = r.alphaMode || "OPAQUE";
                if ("BLEND" === l ? (o.transparent = !0,
                o.depthWrite = !1) : (o.transparent = !1,
                "MASK" === l && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
                void 0 !== r.normalTexture && s !== Pn && (a.push(e.assignTexture(o, "normalMap", r.normalTexture)),
                o.normalScale = new Nt(1,1),
                void 0 !== r.normalTexture.scale)) {
                    const t = r.normalTexture.scale;
                    o.normalScale.set(t, t)
                }
                if (void 0 !== r.occlusionTexture && s !== Pn && (a.push(e.assignTexture(o, "aoMap", r.occlusionTexture)),
                void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)),
                void 0 !== r.emissiveFactor && s !== Pn) {
                    const t = r.emissiveFactor;
                    o.emissive = (new Ln).setRGB(t[0], t[1], t[2], ct)
                }
                return void 0 !== r.emissiveTexture && s !== Pn && a.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture, lt)),
                Promise.all(a).then((function() {
                    const n = new s(o);
                    return r.name && (n.name = r.name),
                    Zu(n, r),
                    e.associations.set(n, {
                        materials: t
                    }),
                    r.extensions && $u(i, n, r),
                    n
                }
                ))
            }
            createUniqueName(t) {
                const e = hl.sanitizeNodeName(t || "");
                return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0,
                e)
            }
            loadGeometries(t) {
                const e = this
                  , n = this.extensions
                  , i = this.primitiveCache;
                function r(t) {
                    return n[vu.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                        return oh(n, t, e)
                    }
                    ))
                }
                const s = [];
                for (let n = 0, o = t.length; n < o; n++) {
                    const o = t[n]
                      , a = eh(o)
                      , l = i[a];
                    if (l)
                        s.push(l.promise);
                    else {
                        let t;
                        t = o.extensions && o.extensions[vu.KHR_DRACO_MESH_COMPRESSION] ? r(o) : oh(new Kn, o, e),
                        i[a] = {
                            primitive: o,
                            promise: t
                        },
                        s.push(t)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(t) {
                const e = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.meshes[t]
                  , s = r.primitives
                  , o = [];
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = void 0 === s[t].material ? Ju(this.cache) : this.getDependency("material", s[t].material);
                    o.push(e)
                }
                return o.push(e.loadGeometries(s)),
                Promise.all(o).then((function(n) {
                    const o = n.slice(0, n.length - 1)
                      , a = n[n.length - 1]
                      , l = [];
                    for (let n = 0, c = a.length; n < c; n++) {
                        const c = a[n]
                          , u = s[n];
                        let h;
                        const d = o[n];
                        if (u.mode === zu.TRIANGLES || u.mode === zu.TRIANGLE_STRIP || u.mode === zu.TRIANGLE_FAN || void 0 === u.mode)
                            h = !0 === r.isSkinnedMesh ? new Mo(c,d) : new fi(c,d),
                            !0 === h.isSkinnedMesh && h.normalizeSkinWeights(),
                            u.mode === zu.TRIANGLE_STRIP ? h.geometry = Au(h.geometry, 1) : u.mode === zu.TRIANGLE_FAN && (h.geometry = Au(h.geometry, 2));
                        else if (u.mode === zu.LINES)
                            h = new Jo(c,d);
                        else if (u.mode === zu.LINE_STRIP)
                            h = new Xo(c,d);
                        else if (u.mode === zu.LINE_LOOP)
                            h = new $o(c,d);
                        else {
                            if (u.mode !== zu.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                            h = new ra(c,d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && th(h, r),
                        h.name = e.createUniqueName(r.name || "mesh_" + t),
                        Zu(h, r),
                        u.extensions && $u(i, h, u),
                        e.assignFinalMaterial(h),
                        l.push(h)
                    }
                    for (let n = 0, i = l.length; n < i; n++)
                        e.associations.set(l[n], {
                            meshes: t,
                            primitives: n
                        });
                    if (1 === l.length)
                        return r.extensions && $u(i, l[0], r),
                        l[0];
                    const c = new so;
                    r.extensions && $u(i, c, r),
                    e.associations.set(c, {
                        meshes: t
                    });
                    for (let t = 0, e = l.length; t < e; t++)
                        c.add(l[t]);
                    return c
                }
                ))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t]
                  , i = n[n.type];
                if (i)
                    return "perspective" === n.type ? e = new xi(Ot.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (e = new Xi(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                    n.name && (e.name = this.createUniqueName(n.name)),
                    Zu(e, n),
                    Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(t) {
                const e = this.json.skins[t]
                  , n = [];
                for (let t = 0, i = e.joints.length; t < i; t++)
                    n.push(this._loadNodeShallow(e.joints[t]));
                return void 0 !== e.inverseBindMatrices ? n.push(this.getDependency("accessor", e.inverseBindMatrices)) : n.push(null),
                Promise.all(n).then((function(t) {
                    const n = t.pop()
                      , i = t
                      , r = []
                      , s = [];
                    for (let t = 0, o = i.length; t < o; t++) {
                        const o = i[t];
                        if (o) {
                            r.push(o);
                            const e = new Ge;
                            null !== n && e.fromArray(n.array, 16 * t),
                            s.push(e)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                    }
                    return new Lo(r,s)
                }
                ))
            }
            loadAnimation(t) {
                const e = this.json
                  , n = this
                  , i = e.animations[t]
                  , r = i.name ? i.name : "animation_" + t
                  , s = []
                  , o = []
                  , a = []
                  , l = []
                  , c = [];
                for (let t = 0, e = i.channels.length; t < e; t++) {
                    const e = i.channels[t]
                      , n = i.samplers[e.sampler]
                      , r = e.target
                      , u = r.node
                      , h = void 0 !== i.parameters ? i.parameters[n.input] : n.input
                      , d = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (s.push(this.getDependency("node", u)),
                    o.push(this.getDependency("accessor", h)),
                    a.push(this.getDependency("accessor", d)),
                    l.push(n),
                    c.push(r))
                }
                return Promise.all([Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c)]).then((function(t) {
                    const e = t[0]
                      , i = t[1]
                      , s = t[2]
                      , o = t[3]
                      , a = t[4]
                      , l = [];
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t]
                          , c = i[t]
                          , u = s[t]
                          , h = o[t]
                          , d = a[t];
                        if (void 0 === r)
                            continue;
                        r.updateMatrix && r.updateMatrix();
                        const p = n._createAnimationTracks(r, c, u, h, d);
                        if (p)
                            for (let t = 0; t < p.length; t++)
                                l.push(p[t])
                    }
                    return new Ta(r,void 0,l)
                }
                ))
            }
            createNodeMesh(t) {
                const e = this.json
                  , n = this
                  , i = e.nodes[t];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                    const e = n._getNodeRef(n.meshCache, i.mesh, t);
                    return void 0 !== i.weights && e.traverse((function(t) {
                        if (t.isMesh)
                            for (let e = 0, n = i.weights.length; e < n; e++)
                                t.morphTargetInfluences[e] = i.weights[e]
                    }
                    )),
                    e
                }
                ))
            }
            loadNode(t) {
                const e = this
                  , n = this.json.nodes[t]
                  , i = e._loadNodeShallow(t)
                  , r = []
                  , s = n.children || [];
                for (let t = 0, n = s.length; t < n; t++)
                    r.push(e.getDependency("node", s[t]));
                const o = void 0 === n.skin ? Promise.resolve(null) : e.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), o]).then((function(t) {
                    const e = t[0]
                      , n = t[1]
                      , i = t[2];
                    null !== i && e.traverse((function(t) {
                        t.isSkinnedMesh && t.bind(i, rh)
                    }
                    ));
                    for (let t = 0, i = n.length; t < i; t++)
                        e.add(n[t]);
                    return e
                }
                ))
            }
            _loadNodeShallow(t) {
                const e = this.json
                  , n = this.extensions
                  , i = this;
                if (void 0 !== this.nodeCache[t])
                    return this.nodeCache[t];
                const r = e.nodes[t]
                  , s = r.name ? i.createUniqueName(r.name) : ""
                  , o = []
                  , a = i._invokeOne((function(e) {
                    return e.createNodeMesh && e.createNodeMesh(t)
                }
                ));
                return a && o.push(a),
                void 0 !== r.camera && o.push(i.getDependency("camera", r.camera).then((function(t) {
                    return i._getNodeRef(i.cameraCache, r.camera, t)
                }
                ))),
                i._invokeAll((function(e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t)
                }
                )).forEach((function(t) {
                    o.push(t)
                }
                )),
                this.nodeCache[t] = Promise.all(o).then((function(e) {
                    let o;
                    if (o = !0 === r.isBone ? new Io : e.length > 1 ? new so : 1 === e.length ? e[0] : new pn,
                    o !== e[0])
                        for (let t = 0, n = e.length; t < n; t++)
                            o.add(e[t]);
                    if (r.name && (o.userData.name = r.name,
                    o.name = s),
                    Zu(o, r),
                    r.extensions && $u(n, o, r),
                    void 0 !== r.matrix) {
                        const t = new Ge;
                        t.fromArray(r.matrix),
                        o.applyMatrix4(t)
                    } else
                        void 0 !== r.translation && o.position.fromArray(r.translation),
                        void 0 !== r.rotation && o.quaternion.fromArray(r.rotation),
                        void 0 !== r.scale && o.scale.fromArray(r.scale);
                    return i.associations.has(o) || i.associations.set(o, {}),
                    i.associations.get(o).nodes = t,
                    o
                }
                )),
                this.nodeCache[t]
            }
            loadScene(t) {
                const e = this.extensions
                  , n = this.json.scenes[t]
                  , i = this
                  , r = new so;
                n.name && (r.name = i.createUniqueName(n.name)),
                Zu(r, n),
                n.extensions && $u(e, r, n);
                const s = n.nodes || []
                  , o = [];
                for (let t = 0, e = s.length; t < e; t++)
                    o.push(i.getDependency("node", s[t]));
                return Promise.all(o).then((function(t) {
                    for (let e = 0, n = t.length; e < n; e++)
                        r.add(t[e]);
                    return i.associations = (t=>{
                        const e = new Map;
                        for (const [t,n] of i.associations)
                            (t instanceof Mn || t instanceof re) && e.set(t, n);
                        return t.traverse((t=>{
                            const n = i.associations.get(t);
                            null != n && e.set(t, n)
                        }
                        )),
                        e
                    }
                    )(r),
                    r
                }
                ))
            }
            _createAnimationTracks(t, e, n, i, r) {
                const s = []
                  , o = t.name ? t.name : t.uuid
                  , a = [];
                let l;
                switch (Yu[r.path] === Yu.weights ? t.traverse((function(t) {
                    t.morphTargetInfluences && a.push(t.name ? t.name : t.uuid)
                }
                )) : a.push(o),
                Yu[r.path]) {
                case Yu.weights:
                    l = wa;
                    break;
                case Yu.rotation:
                    l = Ca;
                    break;
                case Yu.position:
                case Yu.scale:
                    l = Ia;
                    break;
                default:
                    l = 1 === n.itemSize ? wa : Ia
                }
                const c = void 0 !== i.interpolation ? Ku[i.interpolation] : et
                  , u = this._getArrayFromAccessor(n);
                for (let t = 0, n = a.length; t < n; t++) {
                    const n = new l(a[t] + "." + Yu[r.path],e.array,u,c);
                    "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n),
                    s.push(n)
                }
                return s
            }
            _getArrayFromAccessor(t) {
                let e = t.array;
                if (t.normalized) {
                    const t = ih(e.constructor)
                      , n = new Float32Array(e.length);
                    for (let i = 0, r = e.length; i < r; i++)
                        n[i] = e[i] * t;
                    e = n
                }
                return e
            }
            _createCubicSplineTrackInterpolant(t) {
                t.createInterpolant = function(t) {
                    return new (this instanceof Ca ? Hu : ku)(this.times,this.values,this.getValueSize() / 3,t)
                }
                ,
                t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }
        function oh(t, e, n) {
            const i = e.attributes
              , r = [];
            function s(e, i) {
                return n.getDependency("accessor", e).then((function(e) {
                    t.setAttribute(i, e)
                }
                ))
            }
            for (const e in i) {
                const n = Xu[e] || e.toLowerCase();
                n in t.attributes || r.push(s(i[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const i = n.getDependency("accessor", e.indices).then((function(e) {
                    t.setIndex(e)
                }
                ));
                r.push(i)
            }
            return Yt.workingColorSpace !== ct && "COLOR_0"in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Yt.workingColorSpace}" not supported.`),
            Zu(t, e),
            function(t, e, n) {
                const i = e.attributes
                  , r = new fe;
                if (void 0 === i.POSITION)
                    return;
                {
                    const t = n.json.accessors[i.POSITION]
                      , e = t.min
                      , s = t.max;
                    if (void 0 === e || void 0 === s)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new he(e[0],e[1],e[2]), new he(s[0],s[1],s[2])),
                    t.normalized) {
                        const e = ih(Vu[t.componentType]);
                        r.min.multiplyScalar(e),
                        r.max.multiplyScalar(e)
                    }
                }
                const s = e.targets;
                if (void 0 !== s) {
                    const t = new he
                      , e = new he;
                    for (let i = 0, r = s.length; i < r; i++) {
                        const r = s[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION]
                              , s = i.min
                              , o = i.max;
                            if (void 0 !== s && void 0 !== o) {
                                if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                                e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                                e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                                i.normalized) {
                                    const t = ih(Vu[i.componentType]);
                                    e.multiplyScalar(t)
                                }
                                t.max(e)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(t)
                }
                t.boundingBox = r;
                const o = new Le;
                r.getCenter(o.center),
                o.radius = r.min.distanceTo(r.max) / 2,
                t.boundingSphere = o
            }(t, e, n),
            Promise.all(r).then((function() {
                return void 0 !== e.targets ? function(t, e, n) {
                    let i = !1
                      , r = !1
                      , s = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        if (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (s = !0),
                        i && r && s)
                            break
                    }
                    if (!i && !r && !s)
                        return Promise.resolve(t);
                    const o = []
                      , a = []
                      , l = [];
                    for (let c = 0, u = e.length; c < u; c++) {
                        const u = e[c];
                        if (i) {
                            const e = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : t.attributes.position;
                            o.push(e)
                        }
                        if (r) {
                            const e = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : t.attributes.normal;
                            a.push(e)
                        }
                        if (s) {
                            const e = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : t.attributes.color;
                            l.push(e)
                        }
                    }
                    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function(e) {
                        const n = e[0]
                          , o = e[1]
                          , a = e[2];
                        return i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = o),
                        s && (t.morphAttributes.color = a),
                        t.morphTargetsRelative = !0,
                        t
                    }
                    ))
                }(t, e.targets, n) : t
            }
            ))
        }
        class ah {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4;
                this.pool = t,
                this.queue = [],
                this.workers = [],
                this.workersResolve = [],
                this.workerStatus = 0
            }
            _initWorker(t) {
                if (!this.workers[t]) {
                    const e = this.workerCreator();
                    e.addEventListener("message", this._onMessage.bind(this, t)),
                    this.workers[t] = e
                }
            }
            _getIdleWorker() {
                for (let t = 0; t < this.pool; t++)
                    if (!(this.workerStatus & 1 << t))
                        return t;
                return -1
            }
            _onMessage(t, e) {
                const n = this.workersResolve[t];
                if (n && n(e),
                this.queue.length) {
                    const {resolve: e, msg: n, transfer: i} = this.queue.shift();
                    this.workersResolve[t] = e,
                    this.workers[t].postMessage(n, i)
                } else
                    this.workerStatus ^= 1 << t
            }
            setWorkerCreator(t) {
                this.workerCreator = t
            }
            setWorkerLimit(t) {
                this.pool = t
            }
            postMessage(t, e) {
                return new Promise((n=>{
                    const i = this._getIdleWorker();
                    -1 !== i ? (this._initWorker(i),
                    this.workerStatus |= 1 << i,
                    this.workersResolve[i] = n,
                    this.workers[i].postMessage(t, e)) : this.queue.push({
                        resolve: n,
                        msg: t,
                        transfer: e
                    })
                }
                ))
            }
            dispose() {
                this.workers.forEach((t=>t.terminate())),
                this.workersResolve.length = 0,
                this.workers.length = 0,
                this.queue.length = 0,
                this.workerStatus = 0
            }
        }
        class lh {
            constructor() {
                this.vkFormat = 0,
                this.typeSize = 1,
                this.pixelWidth = 0,
                this.pixelHeight = 0,
                this.pixelDepth = 0,
                this.layerCount = 0,
                this.faceCount = 1,
                this.supercompressionScheme = 0,
                this.levels = [],
                this.dataFormatDescriptor = [{
                    vendorId: 0,
                    descriptorType: 0,
                    descriptorBlockSize: 0,
                    versionNumber: 2,
                    colorModel: 0,
                    colorPrimaries: 1,
                    transferFunction: 2,
                    flags: 0,
                    texelBlockDimension: [0, 0, 0, 0],
                    bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                    samples: []
                }],
                this.keyValue = {},
                this.globalData = null
            }
        }
        class ch {
            constructor(t, e, n, i) {
                this._dataView = new DataView(t.buffer,t.byteOffset + e,n),
                this._littleEndian = i,
                this._offset = 0
            }
            _nextUint8() {
                const t = this._dataView.getUint8(this._offset);
                return this._offset += 1,
                t
            }
            _nextUint16() {
                const t = this._dataView.getUint16(this._offset, this._littleEndian);
                return this._offset += 2,
                t
            }
            _nextUint32() {
                const t = this._dataView.getUint32(this._offset, this._littleEndian);
                return this._offset += 4,
                t
            }
            _nextUint64() {
                const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                return this._offset += 8,
                t
            }
            _nextInt32() {
                const t = this._dataView.getInt32(this._offset, this._littleEndian);
                return this._offset += 4,
                t
            }
            _skip(t) {
                return this._offset += t,
                this
            }
            _scan(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this._offset;
                let i = 0;
                for (; this._dataView.getUint8(this._offset) !== e && i < t; )
                    i++,
                    this._offset++;
                return i < t && this._offset++,
                new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + n,i)
            }
        }
        const uh = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
        function hh(t) {
            return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(t) : Buffer.from(t).toString("utf8")
        }
        let dh, ph, fh;
        const Ah = {
            env: {
                emscripten_notify_memory_growth: function(t) {
                    fh = new Uint8Array(ph.exports.memory.buffer)
                }
            }
        };
        class gh {
            init() {
                return dh || (dh = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + mh).then((t=>t.arrayBuffer())).then((t=>WebAssembly.instantiate(t, Ah))).then(this._init) : WebAssembly.instantiate(Buffer.from(mh, "base64"), Ah).then(this._init),
                dh)
            }
            _init(t) {
                ph = t.instance,
                Ah.env.emscripten_notify_memory_growth(0)
            }
            decode(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!ph)
                    throw new Error("ZSTDDecoder: Await .init() before decoding.");
                const n = t.byteLength
                  , i = ph.exports.malloc(n);
                fh.set(t, i),
                e = e || Number(ph.exports.ZSTD_findDecompressedSize(i, n));
                const r = ph.exports.malloc(e)
                  , s = ph.exports.ZSTD_decompress(r, e, i, n)
                  , o = fh.slice(r, r + s);
                return ph.exports.free(i),
                ph.exports.free(r),
                o
            }
        }
        const mh = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ"
          , vh = new WeakMap;
        let yh, _h = 0;
        class Eh extends Da {
            constructor(t) {
                super(t),
                this.transcoderPath = "",
                this.transcoderBinary = null,
                this.transcoderPending = null,
                this.workerPool = new ah,
                this.workerSourceURL = "",
                this.workerConfig = null,
                "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
            }
            setTranscoderPath(t) {
                return this.transcoderPath = t,
                this
            }
            setWorkerLimit(t) {
                return this.workerPool.setWorkerLimit(t),
                this
            }
            detectSupport(t) {
                return !0 === t.isWebGPURenderer ? this.workerConfig = {
                    astcSupported: t.hasFeature("texture-compression-astc"),
                    etc1Supported: !1,
                    etc2Supported: t.hasFeature("texture-compression-etc2"),
                    dxtSupported: t.hasFeature("texture-compression-bc"),
                    bptcSupported: !1,
                    pvrtcSupported: !1
                } : (this.workerConfig = {
                    astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
                    etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                },
                t.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)),
                this
            }
            init() {
                if (!this.transcoderPending) {
                    const t = new Oa(this.manager);
                    t.setPath(this.transcoderPath),
                    t.setWithCredentials(this.withCredentials);
                    const e = t.loadAsync("basis_transcoder.js")
                      , n = new Oa(this.manager);
                    n.setPath(this.transcoderPath),
                    n.setResponseType("arraybuffer"),
                    n.setWithCredentials(this.withCredentials);
                    const i = n.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([e, i]).then((t=>{
                        let[e,n] = t;
                        const i = Eh.BasisWorker.toString()
                          , r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Eh.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Eh.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Eh.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r])),
                        this.transcoderBinary = n,
                        this.workerPool.setWorkerCreator((()=>{
                            const t = new Worker(this.workerSourceURL)
                              , e = this.transcoderBinary.slice(0);
                            return t.postMessage({
                                type: "init",
                                config: this.workerConfig,
                                transcoderBinary: e
                            }, [e]),
                            t
                        }
                        ))
                    }
                    )),
                    _h > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),
                    _h++
                }
                return this.transcoderPending
            }
            load(t, e, n, i) {
                if (null === this.workerConfig)
                    throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                const r = new Oa(this.manager);
                r.setResponseType("arraybuffer"),
                r.setWithCredentials(this.withCredentials),
                r.load(t, (t=>{
                    if (vh.has(t))
                        return vh.get(t).promise.then(e).catch(i);
                    this._createTexture(t).then((t=>e ? e(t) : null)).catch(i)
                }
                ), n, i)
            }
            _createTextureFrom(t, e) {
                const {faces: n, width: i, height: r, format: s, type: o, error: a, dfdFlags: l} = t;
                if ("error" === o)
                    return Promise.reject(a);
                let c;
                if (6 === e.faceCount)
                    c = new ca(n,s,R);
                else {
                    const t = n[0].mipmaps;
                    c = e.layerCount > 1 ? new la(t,i,r,e.layerCount,s,R) : new aa(t,i,r,s,R)
                }
                return c.minFilter = 1 === n[0].mipmaps.length ? I : B,
                c.magFilter = I,
                c.generateMipmaps = !1,
                c.needsUpdate = !0,
                c.colorSpace = Sh(e),
                c.premultiplyAlpha = !!(1 & l),
                c
            }
            async _createTexture(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const n = function(t) {
                    const e = new Uint8Array(t.buffer,t.byteOffset,uh.length);
                    if (e[0] !== uh[0] || e[1] !== uh[1] || e[2] !== uh[2] || e[3] !== uh[3] || e[4] !== uh[4] || e[5] !== uh[5] || e[6] !== uh[6] || e[7] !== uh[7] || e[8] !== uh[8] || e[9] !== uh[9] || e[10] !== uh[10] || e[11] !== uh[11])
                        throw new Error("Missing KTX 2.0 identifier.");
                    const n = new lh
                      , i = 17 * Uint32Array.BYTES_PER_ELEMENT
                      , r = new ch(t,uh.length,i,!0);
                    n.vkFormat = r._nextUint32(),
                    n.typeSize = r._nextUint32(),
                    n.pixelWidth = r._nextUint32(),
                    n.pixelHeight = r._nextUint32(),
                    n.pixelDepth = r._nextUint32(),
                    n.layerCount = r._nextUint32(),
                    n.faceCount = r._nextUint32();
                    const s = r._nextUint32();
                    n.supercompressionScheme = r._nextUint32();
                    const o = r._nextUint32()
                      , a = r._nextUint32()
                      , l = r._nextUint32()
                      , c = r._nextUint32()
                      , u = r._nextUint64()
                      , h = r._nextUint64()
                      , d = new ch(t,uh.length + i,3 * s * 8,!0);
                    for (let e = 0; e < s; e++)
                        n.levels.push({
                            levelData: new Uint8Array(t.buffer,t.byteOffset + d._nextUint64(),d._nextUint64()),
                            uncompressedByteLength: d._nextUint64()
                        });
                    const p = new ch(t,o,a,!0)
                      , f = {
                        vendorId: p._skip(4)._nextUint16(),
                        descriptorType: p._nextUint16(),
                        versionNumber: p._nextUint16(),
                        descriptorBlockSize: p._nextUint16(),
                        colorModel: p._nextUint8(),
                        colorPrimaries: p._nextUint8(),
                        transferFunction: p._nextUint8(),
                        flags: p._nextUint8(),
                        texelBlockDimension: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                        bytesPlane: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                        samples: []
                    }
                      , A = (f.descriptorBlockSize / 4 - 6) / 4;
                    for (let t = 0; t < A; t++) {
                        const e = {
                            bitOffset: p._nextUint16(),
                            bitLength: p._nextUint8(),
                            channelType: p._nextUint8(),
                            samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()],
                            sampleLower: -1 / 0,
                            sampleUpper: 1 / 0
                        };
                        64 & e.channelType ? (e.sampleLower = p._nextInt32(),
                        e.sampleUpper = p._nextInt32()) : (e.sampleLower = p._nextUint32(),
                        e.sampleUpper = p._nextUint32()),
                        f.samples[t] = e
                    }
                    n.dataFormatDescriptor.length = 0,
                    n.dataFormatDescriptor.push(f);
                    const g = new ch(t,l,c,!0);
                    for (; g._offset < c; ) {
                        const t = g._nextUint32()
                          , e = g._scan(t)
                          , i = hh(e)
                          , r = g._scan(t - e.byteLength);
                        n.keyValue[i] = i.match(/^ktx/i) ? hh(r) : r,
                        g._offset % 4 && g._skip(4 - g._offset % 4)
                    }
                    if (h <= 0)
                        return n;
                    const m = new ch(t,u,h,!0)
                      , v = m._nextUint16()
                      , y = m._nextUint16()
                      , _ = m._nextUint32()
                      , E = m._nextUint32()
                      , b = m._nextUint32()
                      , x = m._nextUint32()
                      , w = [];
                    for (let t = 0; t < s; t++)
                        w.push({
                            imageFlags: m._nextUint32(),
                            rgbSliceByteOffset: m._nextUint32(),
                            rgbSliceByteLength: m._nextUint32(),
                            alphaSliceByteOffset: m._nextUint32(),
                            alphaSliceByteLength: m._nextUint32()
                        });
                    const S = u + m._offset
                      , C = S + _
                      , M = C + E
                      , I = M + b
                      , T = new Uint8Array(t.buffer,t.byteOffset + S,_)
                      , B = new Uint8Array(t.buffer,t.byteOffset + C,E)
                      , R = new Uint8Array(t.buffer,t.byteOffset + M,b)
                      , L = new Uint8Array(t.buffer,t.byteOffset + I,x);
                    return n.globalData = {
                        endpointCount: v,
                        selectorCount: y,
                        imageDescs: w,
                        endpointsData: T,
                        selectorsData: B,
                        tablesData: R,
                        extendedData: L
                    },
                    n
                }(new Uint8Array(t));
                if (0 !== n.vkFormat)
                    return async function(t) {
                        const {vkFormat: e} = t;
                        if (void 0 === xh[e])
                            throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                        let n;
                        2 === t.supercompressionScheme && (yh || (yh = new Promise((async t=>{
                            const e = new gh;
                            await e.init(),
                            t(e)
                        }
                        ))),
                        n = await yh);
                        const i = [];
                        for (let r = 0; r < t.levels.length; r++) {
                            const s = Math.max(1, t.pixelWidth >> r)
                              , o = Math.max(1, t.pixelHeight >> r)
                              , a = t.pixelDepth ? Math.max(1, t.pixelDepth >> r) : 0
                              , l = t.levels[r];
                            let c, u;
                            if (0 === t.supercompressionScheme)
                                c = l.levelData;
                            else {
                                if (2 !== t.supercompressionScheme)
                                    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                                c = n.decode(l.levelData, l.uncompressedByteLength)
                            }
                            u = wh[e] === P ? new Float32Array(c.buffer,c.byteOffset,c.byteLength / Float32Array.BYTES_PER_ELEMENT) : wh[e] === U ? new Uint16Array(c.buffer,c.byteOffset,c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : c,
                            i.push({
                                data: u,
                                width: s,
                                height: o,
                                depth: a
                            })
                        }
                        let r;
                        if (bh.has(xh[e]))
                            r = 0 === t.pixelDepth ? new To(i[0].data,t.pixelWidth,t.pixelHeight) : new ce(i[0].data,t.pixelWidth,t.pixelHeight,t.pixelDepth);
                        else {
                            if (t.pixelDepth > 0)
                                throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                            r = new aa(i,t.pixelWidth,t.pixelHeight)
                        }
                        return r.mipmaps = i,
                        r.type = wh[e],
                        r.format = xh[e],
                        r.colorSpace = Sh(t),
                        r.needsUpdate = !0,
                        Promise.resolve(r)
                    }(n);
                const i = e
                  , r = this.init().then((()=>this.workerPool.postMessage({
                    type: "transcode",
                    buffer: t,
                    taskConfig: i
                }, [t]))).then((t=>this._createTextureFrom(t.data, n)));
                return vh.set(t, {
                    promise: r
                }),
                r
            }
            dispose() {
                return this.workerPool.dispose(),
                this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                _h--,
                this
            }
        }
        Eh.BasisFormat = {
            ETC1S: 0,
            UASTC_4x4: 1
        },
        Eh.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16
        },
        Eh.EngineFormat = {
            RGBAFormat: N,
            RGBA_ASTC_4x4_Format: K,
            RGBA_BPTC_Format: $,
            RGBA_ETC2_EAC_Format: Y,
            RGBA_PVRTC_4BPPV1_Format: j,
            RGBA_S3TC_DXT5_Format: W,
            RGB_ETC1_Format: 36196,
            RGB_ETC2_Format: X,
            RGB_PVRTC_4BPPV1_Format: q,
            RGB_S3TC_DXT1_Format: H
        },
        Eh.BasisWorker = function() {
            let t, e, n;
            const i = _EngineFormat
              , r = _TranscoderFormat
              , s = _BasisFormat;
            self.addEventListener("message", (function(o) {
                const h = o.data;
                switch (h.type) {
                case "init":
                    t = h.config,
                    d = h.transcoderBinary,
                    e = new Promise((t=>{
                        n = {
                            wasmBinary: d,
                            onRuntimeInitialized: t
                        },
                        BASIS(n)
                    }
                    )).then((()=>{
                        n.initializeBasis(),
                        void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                    }
                    ));
                    break;
                case "transcode":
                    e.then((()=>{
                        try {
                            const {faces: e, buffers: o, width: d, height: p, hasAlpha: f, format: A, dfdFlags: g} = function(e) {
                                const o = new n.KTX2File(new Uint8Array(e));
                                function h() {
                                    o.close(),
                                    o.delete()
                                }
                                if (!o.isValid())
                                    throw h(),
                                    new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                const d = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S
                                  , p = o.getWidth()
                                  , f = o.getHeight()
                                  , A = o.getLayers() || 1
                                  , g = o.getLevels()
                                  , m = o.getFaces()
                                  , v = o.getHasAlpha()
                                  , y = o.getDFDFlags()
                                  , {transcoderFormat: _, engineFormat: E} = function(e, n, o, u) {
                                    let h, d;
                                    const p = e === s.ETC1S ? a : l;
                                    for (let i = 0; i < p.length; i++) {
                                        const r = p[i];
                                        if (t[r.if] && r.basisFormat.includes(e) && !(u && r.transcoderFormat.length < 2) && (!r.needsPowerOfTwo || c(n) && c(o)))
                                            return h = r.transcoderFormat[u ? 1 : 0],
                                            d = r.engineFormat[u ? 1 : 0],
                                            {
                                                transcoderFormat: h,
                                                engineFormat: d
                                            }
                                    }
                                    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),
                                    h = r.RGBA32,
                                    d = i.RGBAFormat,
                                    {
                                        transcoderFormat: h,
                                        engineFormat: d
                                    }
                                }(d, p, f, v);
                                if (!p || !f || !g)
                                    throw h(),
                                    new Error("THREE.KTX2Loader:\tInvalid texture");
                                if (!o.startTranscoding())
                                    throw h(),
                                    new Error("THREE.KTX2Loader: .startTranscoding failed");
                                const b = []
                                  , x = [];
                                for (let t = 0; t < m; t++) {
                                    const e = [];
                                    for (let n = 0; n < g; n++) {
                                        const i = [];
                                        let r, s;
                                        for (let e = 0; e < A; e++) {
                                            const a = o.getImageLevelInfo(n, e, t);
                                            0 !== t || 0 !== n || 0 !== e || a.origWidth % 4 == 0 && a.origHeight % 4 == 0 || console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),
                                            g > 1 ? (r = a.origWidth,
                                            s = a.origHeight) : (r = a.width,
                                            s = a.height);
                                            const l = new Uint8Array(o.getImageTranscodedSizeInBytes(n, e, 0, _));
                                            if (!o.transcodeImage(l, n, e, t, _, 0, -1, -1))
                                                throw h(),
                                                new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                            i.push(l)
                                        }
                                        const a = u(i);
                                        e.push({
                                            data: a,
                                            width: r,
                                            height: s
                                        }),
                                        x.push(a.buffer)
                                    }
                                    b.push({
                                        mipmaps: e,
                                        width: p,
                                        height: f,
                                        format: E
                                    })
                                }
                                return h(),
                                {
                                    faces: b,
                                    buffers: x,
                                    width: p,
                                    height: f,
                                    hasAlpha: v,
                                    format: E,
                                    dfdFlags: y
                                }
                            }(h.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: h.id,
                                faces: e,
                                width: d,
                                height: p,
                                hasAlpha: f,
                                format: A,
                                dfdFlags: g
                            }, o)
                        } catch (t) {
                            console.error(t),
                            self.postMessage({
                                type: "error",
                                id: h.id,
                                error: t.message
                            })
                        }
                    }
                    ))
                }
                var d
            }
            ));
            const o = [{
                if: "astcSupported",
                basisFormat: [s.UASTC_4x4],
                transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
                engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1
            }, {
                if: "bptcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [r.BC7_M5, r.BC7_M5],
                engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1
            }, {
                if: "dxtSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [r.BC1, r.BC3],
                engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1
            }, {
                if: "etc2Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [r.ETC1, r.ETC2],
                engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1
            }, {
                if: "etc1Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [r.ETC1],
                engineFormat: [i.RGB_ETC1_Format],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1
            }, {
                if: "pvrtcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
                engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0
            }]
              , a = o.sort((function(t, e) {
                return t.priorityETC1S - e.priorityETC1S
            }
            ))
              , l = o.sort((function(t, e) {
                return t.priorityUASTC - e.priorityUASTC
            }
            ));
            function c(t) {
                return t <= 2 || 0 == (t & t - 1) && 0 !== t
            }
            function u(t) {
                if (1 === t.length)
                    return t[0];
                let e = 0;
                for (let n = 0; n < t.length; n++)
                    e += t[n].byteLength;
                const n = new Uint8Array(e);
                let i = 0;
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    n.set(r, i),
                    i += r.byteLength
                }
                return n
            }
        }
        ;
        const bh = new Set([N, G, k])
          , xh = {
            109: N,
            97: N,
            37: N,
            43: N,
            103: G,
            83: G,
            16: G,
            22: G,
            100: k,
            76: k,
            15: k,
            9: k,
            166: J,
            165: J
        }
          , wh = {
            109: P,
            97: U,
            37: R,
            43: R,
            103: P,
            83: U,
            16: R,
            22: R,
            100: P,
            76: U,
            15: R,
            9: R,
            166: R,
            165: R
        };
        function Sh(t) {
            const e = t.dataFormatDescriptor[0];
            return 1 === e.colorPrimaries ? 2 === e.transferFunction ? lt : ct : 10 === e.colorPrimaries ? 2 === e.transferFunction ? ut : ht : (0 === e.colorPrimaries || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`),
            at)
        }
        var Ch, Mh;
        const Ih = Symbol("retainerCount")
          , Th = Symbol("recentlyUsed")
          , Bh = Symbol("evict")
          , Rh = Symbol("evictionThreshold")
          , Lh = Symbol("cache");
        class Dh {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
                this[Ch] = new Map,
                this[Mh] = [],
                this[Lh] = t,
                this[Rh] = e
            }
            set evictionThreshold(t) {
                this[Rh] = t,
                this[Bh]()
            }
            get evictionThreshold() {
                return this[Rh]
            }
            get cache() {
                return this[Lh]
            }
            retainerCount(t) {
                return this[Ih].get(t) || 0
            }
            reset() {
                this[Ih].clear(),
                this[Th] = []
            }
            retain(t) {
                this[Ih].has(t) || this[Ih].set(t, 0),
                this[Ih].set(t, this[Ih].get(t) + 1);
                const e = this[Th].indexOf(t);
                -1 !== e && this[Th].splice(e, 1),
                this[Th].unshift(t),
                this[Bh]()
            }
            release(t) {
                this[Ih].has(t) && this[Ih].set(t, Math.max(this[Ih].get(t) - 1, 0)),
                this[Bh]()
            }
            [(Ch = Ih,
            Mh = Th,
            Bh)]() {
                if (!(this[Th].length < this[Rh]))
                    for (let t = this[Th].length - 1; t >= this[Rh]; --t) {
                        const e = this[Th][t];
                        0 === this[Ih].get(e) && (this[Lh].delete(e),
                        this[Th].splice(t, 1))
                    }
            }
        }
        const Ph = t=>{
            const e = new Map;
            for (const n of t.mappings)
                for (const t of n.variants)
                    e.set(t, {
                        material: null,
                        gltfMaterialIndex: n.material
                    });
            return e
        }
        ;
        class Uh {
            constructor(t) {
                this.parser = t,
                this.name = "KHR_materials_variants"
            }
            afterRoot(t) {
                const e = this.parser
                  , n = e.json;
                if (void 0 === n.extensions || void 0 === n.extensions[this.name])
                    return null;
                const i = (t=>{
                    const e = []
                      , n = new Set;
                    for (const i of t) {
                        let t = i
                          , r = 0;
                        for (; n.has(t); )
                            t = i + "." + ++r;
                        n.add(t),
                        e.push(t)
                    }
                    return e
                }
                )((n.extensions[this.name].variants || []).map((t=>t.name)));
                for (const i of t.scenes)
                    i.traverse((t=>{
                        const i = t;
                        if (!i.material)
                            return;
                        const r = e.associations.get(i);
                        if (null == r || null == r.meshes || null == r.primitives)
                            return;
                        const s = n.meshes[r.meshes].primitives[r.primitives].extensions;
                        s && s[this.name] && (i.userData.variantMaterials = Ph(s[this.name]))
                    }
                    ));
                return t.userData.variants = i,
                Promise.resolve()
            }
        }
        var Oh, Nh;
        re.DEFAULT_ANISOTROPY = 4;
        const Fh = new Map
          , Qh = new Map;
        let kh;
        const Gh = new class extends Da {
            constructor(t) {
                super(t),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(t) {
                return this.decoderPath = t,
                this
            }
            setDecoderConfig(t) {
                return this.decoderConfig = t,
                this
            }
            setWorkerLimit(t) {
                return this.workerLimit = t,
                this
            }
            load(t, e, n, i) {
                const r = new Oa(this.manager);
                r.setPath(this.path),
                r.setResponseType("arraybuffer"),
                r.setRequestHeader(this.requestHeader),
                r.setWithCredentials(this.withCredentials),
                r.load(t, (t=>{
                    this.parse(t, e, i)
                }
                ), n, i)
            }
            parse(t, e, n) {
                this.decodeDracoFile(t, e, null, null, lt).catch(n)
            }
            decodeDracoFile(t, e, n, i) {
                let r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ct;
                const s = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!n,
                    vertexColorSpace: r
                };
                return this.decodeGeometry(t, s).then(e)
            }
            decodeGeometry(t, e) {
                const n = JSON.stringify(e);
                if (pu.has(t)) {
                    const e = pu.get(t);
                    if (e.key === n)
                        return e.promise;
                    if (0 === t.byteLength)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i;
                const r = this.workerNextTaskID++
                  , s = t.byteLength
                  , o = this._getWorker(r, s).then((n=>(i = n,
                new Promise(((n,s)=>{
                    i._callbacks[r] = {
                        resolve: n,
                        reject: s
                    },
                    i.postMessage({
                        type: "decode",
                        id: r,
                        taskConfig: e,
                        buffer: t
                    }, [t])
                }
                ))))).then((t=>this._createGeometry(t.geometry)));
                return o.catch((()=>!0)).then((()=>{
                    i && r && this._releaseTask(i, r)
                }
                )),
                pu.set(t, {
                    key: n,
                    promise: o
                }),
                o
            }
            _createGeometry(t) {
                const e = new Kn;
                t.index && e.setIndex(new Qn(t.index.array,1));
                for (let n = 0; n < t.attributes.length; n++) {
                    const i = t.attributes[n]
                      , r = i.name
                      , s = i.array
                      , o = i.itemSize
                      , a = new Qn(s,o);
                    "color" === r && (this._assignVertexColorSpace(a, i.vertexColorSpace),
                    a.normalized = s instanceof Float32Array == 0),
                    e.setAttribute(r, a)
                }
                return e
            }
            _assignVertexColorSpace(t, e) {
                if (e !== lt)
                    return;
                const n = new Ln;
                for (let e = 0, i = t.count; e < i; e++)
                    n.fromBufferAttribute(t, e).convertSRGBToLinear(),
                    t.setXYZ(e, n.r, n.g, n.b)
            }
            _loadLibrary(t, e) {
                const n = new Oa(this.manager);
                return n.setPath(this.decoderPath),
                n.setResponseType(e),
                n.setWithCredentials(this.withCredentials),
                new Promise(((e,i)=>{
                    n.load(t, e, void 0, i)
                }
                ))
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                  , e = [];
                return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(e).then((e=>{
                    const n = e[0];
                    t || (this.decoderConfig.wasmBinary = e[1]);
                    const i = fu.toString()
                      , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                }
                )),
                this.decoderPending
            }
            _getWorker(t, e) {
                return this._initDecoder().then((()=>{
                    if (this.workerPool.length < this.workerLimit) {
                        const t = new Worker(this.workerSourceURL);
                        t._callbacks = {},
                        t._taskCosts = {},
                        t._taskLoad = 0,
                        t.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        t.onmessage = function(e) {
                            const n = e.data;
                            switch (n.type) {
                            case "decode":
                                t._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                t._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(t)
                    } else
                        this.workerPool.sort((function(t, e) {
                            return t._taskLoad > e._taskLoad ? -1 : 1
                        }
                        ));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[t] = e,
                    n._taskLoad += e,
                    n
                }
                ))
            }
            _releaseTask(t, e) {
                t._taskLoad -= t._taskCosts[e],
                delete t._callbacks[e],
                delete t._taskCosts[e]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((t=>t._taskLoad)))
            }
            dispose() {
                for (let t = 0; t < this.workerPool.length; ++t)
                    this.workerPool[t].terminate();
                return this.workerPool.length = 0,
                "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                this
            }
        }
        ;
        let Hh;
        const zh = new Eh;
        let Vh, Wh;
        const qh = Symbol("loader")
          , jh = Symbol("evictionPolicy")
          , Xh = Symbol("GLTFInstance");
        class Yh extends bt {
            constructor(t) {
                super(),
                this[Nh] = (new gu).register((t=>new Uh(t))),
                this[Xh] = t,
                this[qh].setDRACOLoader(Gh),
                this[qh].setKTX2Loader(zh)
            }
            static setDRACODecoderLocation(t) {
                kh = t,
                Gh.setDecoderPath(t)
            }
            static getDRACODecoderLocation() {
                return kh
            }
            static setKTX2TranscoderLocation(t) {
                Hh = t,
                zh.setTranscoderPath(t)
            }
            static getKTX2TranscoderLocation() {
                return Hh
            }
            static setMeshoptDecoderLocation(t) {
                var e;
                Vh !== t && (Vh = t,
                Wh = (e = t,
                new Promise(((t,n)=>{
                    const i = document.createElement("script");
                    document.body.appendChild(i),
                    i.onload = t,
                    i.onerror = n,
                    i.async = !0,
                    i.src = e
                }
                ))).then((()=>MeshoptDecoder.ready)).then((()=>MeshoptDecoder)))
            }
            static getMeshoptDecoderLocation() {
                return Vh
            }
            static initializeKTX2Loader(t) {
                zh.detectSupport(t)
            }
            static get cache() {
                return Fh
            }
            static clearCache() {
                Fh.forEach(((t,e)=>{
                    this.delete(e)
                }
                )),
                this[jh].reset()
            }
            static has(t) {
                return Fh.has(t)
            }
            static async delete(t) {
                if (!this.has(t))
                    return;
                const e = Fh.get(t);
                Qh.delete(t),
                Fh.delete(t),
                (await e).dispose()
            }
            static hasFinishedLoading(t) {
                return !!Qh.get(t)
            }
            get[(Oh = jh,
            Nh = qh,
            jh)]() {
                return this.constructor[jh]
            }
            async preload(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ()=>{}
                ;
                if (this[qh].setWithCredentials(Yh.withCredentials),
                this.dispatchEvent({
                    type: "preload",
                    element: e,
                    src: t
                }),
                !Fh.has(t)) {
                    null != Wh && this[qh].setMeshoptDecoder(await Wh);
                    const e = function(t, e) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ()=>{}
                        ;
                        const i = t=>{
                            const e = t.loaded / t.total;
                            n(Math.max(0, Math.min(1, isFinite(e) ? e : 1)))
                        }
                        ;
                        return new Promise(((n,r)=>{
                            e.load(t, n, i, r)
                        }
                        ))
                    }(t, this[qh], (t=>{
                        n(.8 * t)
                    }
                    ))
                      , i = this[Xh]
                      , r = e.then((t=>i.prepare(t))).then((t=>(n(.9),
                    new i(t)))).catch((t=>(console.error(t),
                    new i)));
                    Fh.set(t, r)
                }
                await Fh.get(t),
                Qh.set(t, !0),
                n && n(1)
            }
            async load(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ()=>{}
                ;
                await this.preload(t, e, n);
                const i = await Fh.get(t)
                  , r = await i.clone();
                return this[jh].retain(t),
                r.dispose = ()=>{
                    this[jh].release(t)
                }
                ,
                r
            }
        }
        Yh[Oh] = new Dh(Yh);
        class Kh extends pn {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document.createElement("div");
                super(),
                this.isCSS2DObject = !0,
                this.element = t,
                this.element.style.position = "absolute",
                this.element.style.userSelect = "none",
                this.element.setAttribute("draggable", !1),
                this.center = new Nt(.5,.5),
                this.addEventListener("removed", (function() {
                    this.traverse((function(t) {
                        t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element)
                    }
                    ))
                }
                ))
            }
            copy(t, e) {
                return super.copy(t, e),
                this.element = t.element.cloneNode(!0),
                this.center = t.center,
                this
            }
        }
        const Jh = new he
          , $h = new Ge
          , Zh = new Ge
          , td = new he
          , ed = new he;
        class nd {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const e = this;
                let n, i, r, s;
                const o = {
                    objects: new WeakMap
                }
                  , a = void 0 !== t.element ? t.element : document.createElement("div");
                function l(t, n, i) {
                    if (t.isCSS2DObject) {
                        Jh.setFromMatrixPosition(t.matrixWorld),
                        Jh.applyMatrix4(Zh);
                        const l = !0 === t.visible && Jh.z >= -1 && Jh.z <= 1 && !0 === t.layers.test(i.layers);
                        if (t.element.style.display = !0 === l ? "" : "none",
                        !0 === l) {
                            t.onBeforeRender(e, n, i);
                            const o = t.element;
                            o.style.transform = "translate(" + -100 * t.center.x + "%," + -100 * t.center.y + "%)translate(" + (Jh.x * r + r) + "px," + (-Jh.y * s + s) + "px)",
                            o.parentNode !== a && a.appendChild(o),
                            t.onAfterRender(e, n, i)
                        }
                        const u = {
                            distanceToCameraSquared: c(i, t)
                        };
                        o.objects.set(t, u)
                    }
                    for (let e = 0, r = t.children.length; e < r; e++)
                        l(t.children[e], n, i)
                }
                function c(t, e) {
                    return td.setFromMatrixPosition(t.matrixWorld),
                    ed.setFromMatrixPosition(e.matrixWorld),
                    td.distanceToSquared(ed)
                }
                a.style.overflow = "hidden",
                this.domElement = a,
                this.getSize = function() {
                    return {
                        width: n,
                        height: i
                    }
                }
                ,
                this.render = function(t, e) {
                    !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    $h.copy(e.matrixWorldInverse),
                    Zh.multiplyMatrices(e.projectionMatrix, $h),
                    l(t, t, e),
                    function(t) {
                        const e = function(t) {
                            const e = [];
                            return t.traverse((function(t) {
                                t.isCSS2DObject && e.push(t)
                            }
                            )),
                            e
                        }(t).sort((function(t, e) {
                            return t.renderOrder !== e.renderOrder ? e.renderOrder - t.renderOrder : o.objects.get(t).distanceToCameraSquared - o.objects.get(e).distanceToCameraSquared
                        }
                        ))
                          , n = e.length;
                        for (let t = 0, i = e.length; t < i; t++)
                            e[t].element.style.zIndex = n - t
                    }(t)
                }
                ,
                this.setSize = function(t, e) {
                    n = t,
                    i = e,
                    r = n / 2,
                    s = i / 2,
                    a.style.width = t + "px",
                    a.style.height = e + "px"
                }
            }
        }
        function id(t, e, n) {
            let i = n;
            const r = new he;
            return t.updateWorldMatrix(!0, !0),
            t.traverseVisible((t=>{
                const {geometry: n} = t;
                if (void 0 !== n) {
                    const {position: s} = n.attributes;
                    if (void 0 !== s)
                        for (let n = 0, o = s.count; n < o; n++)
                            t.isMesh ? t.getVertexPosition(n, r) : r.fromBufferAttribute(s, n),
                            t.isSkinnedMesh || r.applyMatrix4(t.matrixWorld),
                            i = e(i, r)
                }
            }
            )),
            i
        }
        let rd, sd, od, ad;
        function ld(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1 / 0
              , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            sd || (sd = new Ni(2,2,1,1)),
            od || (od = new Ei({
                uniforms: {
                    blitTexture: new Al(t)
                },
                vertexShader: "\n            varying vec2 vUv;\n            void main(){\n                vUv = uv;\n                gl_Position = vec4(position.xy * 1.0,0.,.999999);\n            }",
                fragmentShader: "\n            uniform sampler2D blitTexture; \n            varying vec2 vUv;\n\n            void main(){ \n                gl_FragColor = vec4(vUv.xy, 0, 1);\n                \n                #ifdef IS_SRGB\n                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n                #else\n                gl_FragColor = texture2D( blitTexture, vUv);\n                #endif\n            }"
            })),
            od.uniforms.blitTexture.value = t,
            od.defines.IS_SRGB = t.colorSpace == lt,
            od.needsUpdate = !0,
            ad || (ad = new fi(sd,od),
            ad.frustrumCulled = !1);
            const i = new xi
              , r = new fo;
            r.add(ad),
            n || (n = rd = new po({
                antialias: !1
            })),
            n.setSize(Math.min(t.image.width, e), Math.min(t.image.height, e)),
            n.clear(),
            n.render(r, i);
            const s = new re(n.domElement);
            return s.minFilter = t.minFilter,
            s.magFilter = t.magFilter,
            s.wrapS = t.wrapS,
            s.wrapT = t.wrapT,
            s.name = t.name,
            rd && (rd.dispose(),
            rd = null),
            s
        }
        const cd = {
            POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
            NORMAL: ["byte normalized", "short normalized"],
            TANGENT: ["byte normalized", "short normalized"],
            TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
        };
        class ud {
            constructor() {
                this.pluginCallbacks = [],
                this.register((function(t) {
                    return new Sd(t)
                }
                )),
                this.register((function(t) {
                    return new Cd(t)
                }
                )),
                this.register((function(t) {
                    return new Td(t)
                }
                )),
                this.register((function(t) {
                    return new Bd(t)
                }
                )),
                this.register((function(t) {
                    return new Rd(t)
                }
                )),
                this.register((function(t) {
                    return new Ld(t)
                }
                )),
                this.register((function(t) {
                    return new Md(t)
                }
                )),
                this.register((function(t) {
                    return new Id(t)
                }
                )),
                this.register((function(t) {
                    return new Dd(t)
                }
                )),
                this.register((function(t) {
                    return new Pd(t)
                }
                )),
                this.register((function(t) {
                    return new Ud(t)
                }
                ))
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
                this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                this
            }
            parse(t, e, n, i) {
                const r = new wd
                  , s = [];
                for (let t = 0, e = this.pluginCallbacks.length; t < e; t++)
                    s.push(this.pluginCallbacks[t](r));
                r.setPlugins(s),
                r.write(t, e, i).catch(n)
            }
            parseAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(t, i, r, e)
                }
                ))
            }
        }
        const hd = 5120
          , dd = 5121
          , pd = 5122
          , fd = 5123
          , Ad = "KHR_mesh_quantization"
          , gd = {
            1003: 9728,
            1004: 9984,
            1005: 9986,
            1006: 9729,
            1007: 9985,
            1008: 9987,
            1001: 33071,
            1e3: 10497,
            1002: 33648
        }
          , md = {
            scale: "scale",
            position: "translation",
            quaternion: "rotation",
            morphTargetInfluences: "weights"
        }
          , vd = new Ln;
        function yd(t, e) {
            return t.length === e.length && t.every((function(t, n) {
                return t === e[n]
            }
            ))
        }
        function _d(t) {
            return 4 * Math.ceil(t / 4)
        }
        function Ed(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n = _d(t.byteLength);
            if (n !== t.byteLength) {
                const i = new Uint8Array(n);
                if (i.set(new Uint8Array(t)),
                0 !== e)
                    for (let r = t.byteLength; r < n; r++)
                        i[r] = e;
                return i.buffer
            }
            return t
        }
        function bd() {
            return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1,1) : document.createElement("canvas")
        }
        function xd(t, e) {
            if (void 0 !== t.toBlob)
                return new Promise((n=>t.toBlob(n, e)));
            let n;
            return "image/jpeg" === e ? n = .92 : "image/webp" === e && (n = .8),
            t.convertToBlob({
                type: e,
                quality: n
            })
        }
        class wd {
            constructor() {
                this.plugins = [],
                this.options = {},
                this.pending = [],
                this.buffers = [],
                this.byteOffset = 0,
                this.buffers = [],
                this.nodeMap = new Map,
                this.skins = [],
                this.extensionsUsed = {},
                this.extensionsRequired = {},
                this.uids = new Map,
                this.uid = 0,
                this.json = {
                    asset: {
                        version: "2.0",
                        generator: "THREE.GLTFExporter"
                    }
                },
                this.cache = {
                    meshes: new Map,
                    attributes: new Map,
                    attributesNormalized: new Map,
                    materials: new Map,
                    textures: new Map,
                    images: new Map
                }
            }
            setPlugins(t) {
                this.plugins = t
            }
            async write(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                this.options = Object.assign({
                    binary: !1,
                    trs: !1,
                    onlyVisible: !0,
                    maxTextureSize: 1 / 0,
                    animations: [],
                    includeCustomExtensions: !1
                }, n),
                this.options.animations.length > 0 && (this.options.trs = !0),
                this.processInput(t),
                await Promise.all(this.pending);
                const i = this
                  , r = i.buffers
                  , s = i.json;
                n = i.options;
                const o = i.extensionsUsed
                  , a = i.extensionsRequired
                  , l = new Blob(r,{
                    type: "application/octet-stream"
                })
                  , c = Object.keys(o)
                  , u = Object.keys(a);
                if (c.length > 0 && (s.extensionsUsed = c),
                u.length > 0 && (s.extensionsRequired = u),
                s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = l.size),
                !0 === n.binary) {
                    const t = new FileReader;
                    t.readAsArrayBuffer(l),
                    t.onloadend = function() {
                        const n = Ed(t.result)
                          , i = new DataView(new ArrayBuffer(8));
                        i.setUint32(0, n.byteLength, !0),
                        i.setUint32(4, 5130562, !0);
                        const r = Ed((o = JSON.stringify(s),
                        (new TextEncoder).encode(o).buffer), 32);
                        var o;
                        const a = new DataView(new ArrayBuffer(8));
                        a.setUint32(0, r.byteLength, !0),
                        a.setUint32(4, 1313821514, !0);
                        const l = new ArrayBuffer(12)
                          , c = new DataView(l);
                        c.setUint32(0, 1179937895, !0),
                        c.setUint32(4, 2, !0);
                        const u = 12 + a.byteLength + r.byteLength + i.byteLength + n.byteLength;
                        c.setUint32(8, u, !0);
                        const h = new Blob([l, a, r, i, n],{
                            type: "application/octet-stream"
                        })
                          , d = new FileReader;
                        d.readAsArrayBuffer(h),
                        d.onloadend = function() {
                            e(d.result)
                        }
                    }
                } else if (s.buffers && s.buffers.length > 0) {
                    const t = new FileReader;
                    t.readAsDataURL(l),
                    t.onloadend = function() {
                        const n = t.result;
                        s.buffers[0].uri = n,
                        e(s)
                    }
                } else
                    e(s)
            }
            serializeUserData(t, e) {
                if (0 === Object.keys(t.userData).length)
                    return;
                const n = this.options
                  , i = this.extensionsUsed;
                try {
                    const r = JSON.parse(JSON.stringify(t.userData));
                    if (n.includeCustomExtensions && r.gltfExtensions) {
                        void 0 === e.extensions && (e.extensions = {});
                        for (const t in r.gltfExtensions)
                            e.extensions[t] = r.gltfExtensions[t],
                            i[t] = !0;
                        delete r.gltfExtensions
                    }
                    Object.keys(r).length > 0 && (e.extras = r)
                } catch (e) {
                    console.warn("THREE.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + e.message)
                }
            }
            getUID(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!1 === this.uids.has(t)) {
                    const e = new Map;
                    e.set(!0, this.uid++),
                    e.set(!1, this.uid++),
                    this.uids.set(t, e)
                }
                return this.uids.get(t).get(e)
            }
            isNormalizedNormalAttribute(t) {
                if (this.cache.attributesNormalized.has(t))
                    return !1;
                const e = new he;
                for (let n = 0, i = t.count; n < i; n++)
                    if (Math.abs(e.fromBufferAttribute(t, n).length() - 1) > 5e-4)
                        return !1;
                return !0
            }
            createNormalizedNormalAttribute(t) {
                const e = this.cache;
                if (e.attributesNormalized.has(t))
                    return e.attributesNormalized.get(t);
                const n = t.clone()
                  , i = new he;
                for (let t = 0, e = n.count; t < e; t++)
                    i.fromBufferAttribute(n, t),
                    0 === i.x && 0 === i.y && 0 === i.z ? i.setX(1) : i.normalize(),
                    n.setXYZ(t, i.x, i.y, i.z);
                return e.attributesNormalized.set(t, n),
                n
            }
            applyTextureTransform(t, e) {
                let n = !1;
                const i = {};
                0 === e.offset.x && 0 === e.offset.y || (i.offset = e.offset.toArray(),
                n = !0),
                0 !== e.rotation && (i.rotation = e.rotation,
                n = !0),
                1 === e.repeat.x && 1 === e.repeat.y || (i.scale = e.repeat.toArray(),
                n = !0),
                n && (t.extensions = t.extensions || {},
                t.extensions.KHR_texture_transform = i,
                this.extensionsUsed.KHR_texture_transform = !0)
            }
            buildMetalRoughTexture(t, e) {
                if (t === e)
                    return t;
                function n(t) {
                    return t.colorSpace === lt ? function(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }
                    : function(t) {
                        return t
                    }
                }
                console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),
                t instanceof aa && (t = ld(t)),
                e instanceof aa && (e = ld(e));
                const i = t ? t.image : null
                  , r = e ? e.image : null
                  , s = Math.max(i ? i.width : 0, r ? r.width : 0)
                  , o = Math.max(i ? i.height : 0, r ? r.height : 0)
                  , a = bd();
                a.width = s,
                a.height = o;
                const l = a.getContext("2d");
                l.fillStyle = "#00ffff",
                l.fillRect(0, 0, s, o);
                const c = l.getImageData(0, 0, s, o);
                if (i) {
                    l.drawImage(i, 0, 0, s, o);
                    const e = n(t)
                      , r = l.getImageData(0, 0, s, o).data;
                    for (let t = 2; t < r.length; t += 4)
                        c.data[t] = 256 * e(r[t] / 256)
                }
                if (r) {
                    l.drawImage(r, 0, 0, s, o);
                    const t = n(e)
                      , i = l.getImageData(0, 0, s, o).data;
                    for (let e = 1; e < i.length; e += 4)
                        c.data[e] = 256 * t(i[e] / 256)
                }
                l.putImageData(c, 0, 0);
                const u = (t || e).clone();
                return u.source = new ee(a),
                u.colorSpace = at,
                u.channel = (t || e).channel,
                t && e && t.channel !== e.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),
                u
            }
            processBuffer(t) {
                const e = this.json
                  , n = this.buffers;
                return e.buffers || (e.buffers = [{
                    byteLength: 0
                }]),
                n.push(t),
                0
            }
            processBufferView(t, e, n, i, r) {
                const s = this.json;
                let o;
                switch (s.bufferViews || (s.bufferViews = []),
                e) {
                case hd:
                case dd:
                    o = 1;
                    break;
                case pd:
                case fd:
                    o = 2;
                    break;
                default:
                    o = 4
                }
                const a = _d(i * t.itemSize * o)
                  , l = new DataView(new ArrayBuffer(a));
                let c = 0;
                for (let r = n; r < n + i; r++)
                    for (let n = 0; n < t.itemSize; n++) {
                        let i;
                        t.itemSize > 4 ? i = t.array[r * t.itemSize + n] : (0 === n ? i = t.getX(r) : 1 === n ? i = t.getY(r) : 2 === n ? i = t.getZ(r) : 3 === n && (i = t.getW(r)),
                        !0 === t.normalized && (i = Ot.normalize(i, t.array))),
                        5126 === e ? l.setFloat32(c, i, !0) : 5124 === e ? l.setInt32(c, i, !0) : 5125 === e ? l.setUint32(c, i, !0) : e === pd ? l.setInt16(c, i, !0) : e === fd ? l.setUint16(c, i, !0) : e === hd ? l.setInt8(c, i) : e === dd && l.setUint8(c, i),
                        c += o
                    }
                const u = {
                    buffer: this.processBuffer(l.buffer),
                    byteOffset: this.byteOffset,
                    byteLength: a
                };
                return void 0 !== r && (u.target = r),
                34962 === r && (u.byteStride = t.itemSize * o),
                this.byteOffset += a,
                s.bufferViews.push(u),
                {
                    id: s.bufferViews.length - 1,
                    byteLength: 0
                }
            }
            processBufferViewImage(t) {
                const e = this
                  , n = e.json;
                return n.bufferViews || (n.bufferViews = []),
                new Promise((function(i) {
                    const r = new FileReader;
                    r.readAsArrayBuffer(t),
                    r.onloadend = function() {
                        const t = Ed(r.result)
                          , s = {
                            buffer: e.processBuffer(t),
                            byteOffset: e.byteOffset,
                            byteLength: t.byteLength
                        };
                        e.byteOffset += t.byteLength,
                        i(n.bufferViews.push(s) - 1)
                    }
                }
                ))
            }
            processAccessor(t, e, n, i) {
                const r = this.json;
                let s;
                if (t.array.constructor === Float32Array)
                    s = 5126;
                else if (t.array.constructor === Int32Array)
                    s = 5124;
                else if (t.array.constructor === Uint32Array)
                    s = 5125;
                else if (t.array.constructor === Int16Array)
                    s = pd;
                else if (t.array.constructor === Uint16Array)
                    s = fd;
                else if (t.array.constructor === Int8Array)
                    s = hd;
                else {
                    if (t.array.constructor !== Uint8Array)
                        throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + t.array.constructor.name);
                    s = dd
                }
                if (void 0 === n && (n = 0),
                void 0 === i && (i = t.count),
                0 === i)
                    return null;
                const o = function(t, e, n) {
                    const i = {
                        min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
                        max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)
                    };
                    for (let r = e; r < e + n; r++)
                        for (let e = 0; e < t.itemSize; e++) {
                            let n;
                            t.itemSize > 4 ? n = t.array[r * t.itemSize + e] : (0 === e ? n = t.getX(r) : 1 === e ? n = t.getY(r) : 2 === e ? n = t.getZ(r) : 3 === e && (n = t.getW(r)),
                            !0 === t.normalized && (n = Ot.normalize(n, t.array))),
                            i.min[e] = Math.min(i.min[e], n),
                            i.max[e] = Math.max(i.max[e], n)
                        }
                    return i
                }(t, n, i);
                let a;
                void 0 !== e && (a = t === e.index ? 34963 : 34962);
                const l = this.processBufferView(t, s, n, i, a)
                  , c = {
                    bufferView: l.id,
                    byteOffset: l.byteOffset,
                    componentType: s,
                    count: i,
                    max: o.max,
                    min: o.min,
                    type: {
                        1: "SCALAR",
                        2: "VEC2",
                        3: "VEC3",
                        4: "VEC4",
                        9: "MAT3",
                        16: "MAT4"
                    }[t.itemSize]
                };
                return !0 === t.normalized && (c.normalized = !0),
                r.accessors || (r.accessors = []),
                r.accessors.push(c) - 1
            }
            processImage(t, e, n) {
                let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "image/png";
                if (null !== t) {
                    const r = this
                      , s = r.cache
                      , o = r.json
                      , a = r.options
                      , l = r.pending;
                    s.images.has(t) || s.images.set(t, {});
                    const c = s.images.get(t)
                      , u = i + ":flipY/" + n.toString();
                    if (void 0 !== c[u])
                        return c[u];
                    o.images || (o.images = []);
                    const h = {
                        mimeType: i
                    }
                      , d = bd();
                    d.width = Math.min(t.width, a.maxTextureSize),
                    d.height = Math.min(t.height, a.maxTextureSize);
                    const p = d.getContext("2d");
                    if (!0 === n && (p.translate(0, d.height),
                    p.scale(1, -1)),
                    void 0 !== t.data) {
                        e !== N && console.error("GLTFExporter: Only RGBAFormat is supported.", e),
                        (t.width > a.maxTextureSize || t.height > a.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t);
                        const n = new Uint8ClampedArray(t.height * t.width * 4);
                        for (let e = 0; e < n.length; e += 4)
                            n[e + 0] = t.data[e + 0],
                            n[e + 1] = t.data[e + 1],
                            n[e + 2] = t.data[e + 2],
                            n[e + 3] = t.data[e + 3];
                        p.putImageData(new ImageData(n,t.width,t.height), 0, 0)
                    } else
                        p.drawImage(t, 0, 0, d.width, d.height);
                    !0 === a.binary ? l.push(xd(d, i).then((t=>r.processBufferViewImage(t))).then((t=>{
                        h.bufferView = t
                    }
                    ))) : void 0 !== d.toDataURL ? h.uri = d.toDataURL(i) : l.push(xd(d, i).then((t=>(new FileReader).readAsDataURL(t))).then((t=>{
                        h.uri = t
                    }
                    )));
                    const f = o.images.push(h) - 1;
                    return c[u] = f,
                    f
                }
                throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
            }
            processSampler(t) {
                const e = this.json;
                e.samplers || (e.samplers = []);
                const n = {
                    magFilter: gd[t.magFilter],
                    minFilter: gd[t.minFilter],
                    wrapS: gd[t.wrapS],
                    wrapT: gd[t.wrapT]
                };
                return e.samplers.push(n) - 1
            }
            processTexture(t) {
                const e = this.options
                  , n = this.cache
                  , i = this.json;
                if (n.textures.has(t))
                    return n.textures.get(t);
                i.textures || (i.textures = []),
                t instanceof aa && (t = ld(t, e.maxTextureSize));
                let r = t.userData.mimeType;
                "image/webp" === r && (r = "image/png");
                const s = {
                    sampler: this.processSampler(t),
                    source: this.processImage(t.image, t.format, t.flipY, r)
                };
                t.name && (s.name = t.name),
                this._invokeAll((function(e) {
                    e.writeTexture && e.writeTexture(t, s)
                }
                ));
                const o = i.textures.push(s) - 1;
                return n.textures.set(t, o),
                o
            }
            processMaterial(t) {
                const e = this.cache
                  , n = this.json;
                if (e.materials.has(t))
                    return e.materials.get(t);
                if (t.isShaderMaterial)
                    return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),
                    null;
                n.materials || (n.materials = []);
                const i = {
                    pbrMetallicRoughness: {}
                };
                !0 !== t.isMeshStandardMaterial && !0 !== t.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                const r = t.color.toArray().concat([t.opacity]);
                if (yd(r, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = r),
                t.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = t.metalness,
                i.pbrMetallicRoughness.roughnessFactor = t.roughness) : (i.pbrMetallicRoughness.metallicFactor = .5,
                i.pbrMetallicRoughness.roughnessFactor = .5),
                t.metalnessMap || t.roughnessMap) {
                    const e = this.buildMetalRoughTexture(t.metalnessMap, t.roughnessMap)
                      , n = {
                        index: this.processTexture(e),
                        channel: e.channel
                    };
                    this.applyTextureTransform(n, e),
                    i.pbrMetallicRoughness.metallicRoughnessTexture = n
                }
                if (t.map) {
                    const e = {
                        index: this.processTexture(t.map),
                        texCoord: t.map.channel
                    };
                    this.applyTextureTransform(e, t.map),
                    i.pbrMetallicRoughness.baseColorTexture = e
                }
                if (t.emissive) {
                    const e = t.emissive;
                    if (Math.max(e.r, e.g, e.b) > 0 && (i.emissiveFactor = t.emissive.toArray()),
                    t.emissiveMap) {
                        const e = {
                            index: this.processTexture(t.emissiveMap),
                            texCoord: t.emissiveMap.channel
                        };
                        this.applyTextureTransform(e, t.emissiveMap),
                        i.emissiveTexture = e
                    }
                }
                if (t.normalMap) {
                    const e = {
                        index: this.processTexture(t.normalMap),
                        texCoord: t.normalMap.channel
                    };
                    t.normalScale && 1 !== t.normalScale.x && (e.scale = t.normalScale.x),
                    this.applyTextureTransform(e, t.normalMap),
                    i.normalTexture = e
                }
                if (t.aoMap) {
                    const e = {
                        index: this.processTexture(t.aoMap),
                        texCoord: t.aoMap.channel
                    };
                    1 !== t.aoMapIntensity && (e.strength = t.aoMapIntensity),
                    this.applyTextureTransform(e, t.aoMap),
                    i.occlusionTexture = e
                }
                t.transparent ? i.alphaMode = "BLEND" : t.alphaTest > 0 && (i.alphaMode = "MASK",
                i.alphaCutoff = t.alphaTest),
                2 === t.side && (i.doubleSided = !0),
                "" !== t.name && (i.name = t.name),
                this.serializeUserData(t, i),
                this._invokeAll((function(e) {
                    e.writeMaterial && e.writeMaterial(t, i)
                }
                ));
                const s = n.materials.push(i) - 1;
                return e.materials.set(t, s),
                s
            }
            processMesh(t) {
                const e = this.cache
                  , n = this.json
                  , i = [t.geometry.uuid];
                if (Array.isArray(t.material))
                    for (let e = 0, n = t.material.length; e < n; e++)
                        i.push(t.material[e].uuid);
                else
                    i.push(t.material.uuid);
                const r = i.join(":");
                if (e.meshes.has(r))
                    return e.meshes.get(r);
                const s = t.geometry;
                let o;
                o = t.isLineSegments ? 1 : t.isLineLoop ? 2 : t.isLine ? 3 : t.isPoints ? 0 : t.material.wireframe ? 1 : 4;
                const a = {}
                  , l = {}
                  , c = []
                  , u = []
                  , h = {
                    uv: "TEXCOORD_0",
                    uv1: "TEXCOORD_1",
                    color: "COLOR_0",
                    skinWeight: "WEIGHTS_0",
                    skinIndex: "JOINTS_0"
                }
                  , d = s.getAttribute("normal");
                void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),
                s.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
                let p = null;
                for (let t in s.attributes) {
                    if ("morph" === t.slice(0, 5))
                        continue;
                    const n = s.attributes[t];
                    if (t = h[t] || t.toUpperCase(),
                    /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t) || (t = "_" + t),
                    e.attributes.has(this.getUID(n))) {
                        l[t] = e.attributes.get(this.getUID(n));
                        continue
                    }
                    p = null;
                    const i = n.array;
                    "JOINTS_0" !== t || i instanceof Uint16Array || i instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),
                    p = new Qn(new Uint16Array(i),n.itemSize,n.normalized));
                    const r = this.processAccessor(p || n, s);
                    null !== r && (t.startsWith("_") || this.detectMeshQuantization(t, n),
                    l[t] = r,
                    e.attributes.set(this.getUID(n), r))
                }
                if (void 0 !== d && s.setAttribute("normal", d),
                0 === Object.keys(l).length)
                    return null;
                if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
                    const n = []
                      , i = []
                      , r = {};
                    if (void 0 !== t.morphTargetDictionary)
                        for (const e in t.morphTargetDictionary)
                            r[t.morphTargetDictionary[e]] = e;
                    for (let o = 0; o < t.morphTargetInfluences.length; ++o) {
                        const a = {};
                        let l = !1;
                        for (const t in s.morphAttributes) {
                            if ("position" !== t && "normal" !== t) {
                                l || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),
                                l = !0);
                                continue
                            }
                            const n = s.morphAttributes[t][o]
                              , i = t.toUpperCase()
                              , r = s.attributes[t];
                            if (e.attributes.has(this.getUID(n, !0))) {
                                a[i] = e.attributes.get(this.getUID(n, !0));
                                continue
                            }
                            const c = n.clone();
                            if (!s.morphTargetsRelative)
                                for (let t = 0, e = n.count; t < e; t++)
                                    for (let e = 0; e < n.itemSize; e++)
                                        0 === e && c.setX(t, n.getX(t) - r.getX(t)),
                                        1 === e && c.setY(t, n.getY(t) - r.getY(t)),
                                        2 === e && c.setZ(t, n.getZ(t) - r.getZ(t)),
                                        3 === e && c.setW(t, n.getW(t) - r.getW(t));
                            a[i] = this.processAccessor(c, s),
                            e.attributes.set(this.getUID(r, !0), a[i])
                        }
                        u.push(a),
                        n.push(t.morphTargetInfluences[o]),
                        void 0 !== t.morphTargetDictionary && i.push(r[o])
                    }
                    a.weights = n,
                    i.length > 0 && (a.extras = {},
                    a.extras.targetNames = i)
                }
                const f = Array.isArray(t.material);
                if (f && 0 === s.groups.length)
                    return null;
                const A = f ? t.material : [t.material]
                  , g = f ? s.groups : [{
                    materialIndex: 0,
                    start: void 0,
                    count: void 0
                }];
                for (let t = 0, n = g.length; t < n; t++) {
                    const n = {
                        mode: o,
                        attributes: l
                    };
                    if (this.serializeUserData(s, n),
                    u.length > 0 && (n.targets = u),
                    null !== s.index) {
                        let i = this.getUID(s.index);
                        void 0 === g[t].start && void 0 === g[t].count || (i += ":" + g[t].start + ":" + g[t].count),
                        e.attributes.has(i) ? n.indices = e.attributes.get(i) : (n.indices = this.processAccessor(s.index, s, g[t].start, g[t].count),
                        e.attributes.set(i, n.indices)),
                        null === n.indices && delete n.indices
                    }
                    const i = this.processMaterial(A[g[t].materialIndex]);
                    null !== i && (n.material = i),
                    c.push(n)
                }
                a.primitives = c,
                n.meshes || (n.meshes = []),
                this._invokeAll((function(e) {
                    e.writeMesh && e.writeMesh(t, a)
                }
                ));
                const m = n.meshes.push(a) - 1;
                return e.meshes.set(r, m),
                m
            }
            detectMeshQuantization(t, e) {
                if (this.extensionsUsed[Ad])
                    return;
                let n;
                switch (e.array.constructor) {
                case Int8Array:
                    n = "byte";
                    break;
                case Uint8Array:
                    n = "unsigned byte";
                    break;
                case Int16Array:
                    n = "short";
                    break;
                case Uint16Array:
                    n = "unsigned short";
                    break;
                default:
                    return
                }
                e.normalized && (n += " normalized");
                const i = t.split("_", 1)[0];
                cd[i] && cd[i].includes(n) && (this.extensionsUsed[Ad] = !0,
                this.extensionsRequired[Ad] = !0)
            }
            processCamera(t) {
                const e = this.json;
                e.cameras || (e.cameras = []);
                const n = t.isOrthographicCamera
                  , i = {
                    type: n ? "orthographic" : "perspective"
                };
                return n ? i.orthographic = {
                    xmag: 2 * t.right,
                    ymag: 2 * t.top,
                    zfar: t.far <= 0 ? .001 : t.far,
                    znear: t.near < 0 ? 0 : t.near
                } : i.perspective = {
                    aspectRatio: t.aspect,
                    yfov: Ot.degToRad(t.fov),
                    zfar: t.far <= 0 ? .001 : t.far,
                    znear: t.near < 0 ? 0 : t.near
                },
                "" !== t.name && (i.name = t.type),
                e.cameras.push(i) - 1
            }
            processAnimation(t, e) {
                const n = this.json
                  , i = this.nodeMap;
                n.animations || (n.animations = []);
                const r = (t = ud.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks
                  , s = []
                  , o = [];
                for (let t = 0; t < r.length; ++t) {
                    const n = r[t]
                      , a = hl.parseTrackName(n.name);
                    let l = hl.findNode(e, a.nodeName);
                    const c = md[a.propertyName];
                    if ("bones" === a.objectName && (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(a.objectIndex) : void 0),
                    !l || !c)
                        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n.name),
                        null;
                    const u = 1;
                    let h, d = n.values.length / n.times.length;
                    c === md.morphTargetInfluences && (d /= l.morphTargetInfluences.length),
                    !0 === n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (h = "CUBICSPLINE",
                    d /= 3) : h = n.getInterpolation() === tt ? "STEP" : "LINEAR",
                    o.push({
                        input: this.processAccessor(new Qn(n.times,u)),
                        output: this.processAccessor(new Qn(n.values,d)),
                        interpolation: h
                    }),
                    s.push({
                        sampler: o.length - 1,
                        target: {
                            node: i.get(l),
                            path: c
                        }
                    })
                }
                return n.animations.push({
                    name: t.name || "clip_" + n.animations.length,
                    samplers: o,
                    channels: s
                }),
                n.animations.length - 1
            }
            processSkin(t) {
                const e = this.json
                  , n = this.nodeMap
                  , i = e.nodes[n.get(t)]
                  , r = t.skeleton;
                if (void 0 === r)
                    return null;
                const s = t.skeleton.bones[0];
                if (void 0 === s)
                    return null;
                const o = []
                  , a = new Float32Array(16 * r.bones.length)
                  , l = new Ge;
                for (let e = 0; e < r.bones.length; ++e)
                    o.push(n.get(r.bones[e])),
                    l.copy(r.boneInverses[e]),
                    l.multiply(t.bindMatrix).toArray(a, 16 * e);
                return void 0 === e.skins && (e.skins = []),
                e.skins.push({
                    inverseBindMatrices: this.processAccessor(new Qn(a,16)),
                    joints: o,
                    skeleton: n.get(s)
                }),
                i.skin = e.skins.length - 1
            }
            processNode(t) {
                const e = this.json
                  , n = this.options
                  , i = this.nodeMap;
                e.nodes || (e.nodes = []);
                const r = {};
                if (n.trs) {
                    const e = t.quaternion.toArray()
                      , n = t.position.toArray()
                      , i = t.scale.toArray();
                    yd(e, [0, 0, 0, 1]) || (r.rotation = e),
                    yd(n, [0, 0, 0]) || (r.translation = n),
                    yd(i, [1, 1, 1]) || (r.scale = i)
                } else
                    t.matrixAutoUpdate && t.updateMatrix(),
                    !1 === yd(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (r.matrix = t.matrix.elements);
                if ("" !== t.name && (r.name = String(t.name)),
                this.serializeUserData(t, r),
                t.isMesh || t.isLine || t.isPoints) {
                    const e = this.processMesh(t);
                    null !== e && (r.mesh = e)
                } else
                    t.isCamera && (r.camera = this.processCamera(t));
                if (t.isSkinnedMesh && this.skins.push(t),
                t.children.length > 0) {
                    const e = [];
                    for (let i = 0, r = t.children.length; i < r; i++) {
                        const r = t.children[i];
                        if (r.visible || !1 === n.onlyVisible) {
                            const t = this.processNode(r);
                            null !== t && e.push(t)
                        }
                    }
                    e.length > 0 && (r.children = e)
                }
                this._invokeAll((function(e) {
                    e.writeNode && e.writeNode(t, r)
                }
                ));
                const s = e.nodes.push(r) - 1;
                return i.set(t, s),
                s
            }
            processScene(t) {
                const e = this.json
                  , n = this.options;
                e.scenes || (e.scenes = [],
                e.scene = 0);
                const i = {};
                "" !== t.name && (i.name = t.name),
                e.scenes.push(i);
                const r = [];
                for (let e = 0, i = t.children.length; e < i; e++) {
                    const i = t.children[e];
                    if (i.visible || !1 === n.onlyVisible) {
                        const t = this.processNode(i);
                        null !== t && r.push(t)
                    }
                }
                r.length > 0 && (i.nodes = r),
                this.serializeUserData(t, i)
            }
            processObjects(t) {
                const e = new fo;
                e.name = "AuxScene";
                for (let n = 0; n < t.length; n++)
                    e.children.push(t[n]);
                this.processScene(e)
            }
            processInput(t) {
                const e = this.options;
                t = t instanceof Array ? t : [t],
                this._invokeAll((function(e) {
                    e.beforeParse && e.beforeParse(t)
                }
                ));
                const n = [];
                for (let e = 0; e < t.length; e++)
                    t[e]instanceof fo ? this.processScene(t[e]) : n.push(t[e]);
                n.length > 0 && this.processObjects(n);
                for (let t = 0; t < this.skins.length; ++t)
                    this.processSkin(this.skins[t]);
                for (let n = 0; n < e.animations.length; ++n)
                    this.processAnimation(e.animations[n], t[0]);
                this._invokeAll((function(e) {
                    e.afterParse && e.afterParse(t)
                }
                ))
            }
            _invokeAll(t) {
                for (let e = 0, n = this.plugins.length; e < n; e++)
                    t(this.plugins[e])
            }
        }
        class Sd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_lights_punctual"
            }
            writeNode(t, e) {
                if (!t.isLight)
                    return;
                if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight)
                    return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t);
                const n = this.writer
                  , i = n.json
                  , r = n.extensionsUsed
                  , s = {};
                t.name && (s.name = t.name),
                s.color = t.color.toArray(),
                s.intensity = t.intensity,
                t.isDirectionalLight ? s.type = "directional" : t.isPointLight ? (s.type = "point",
                t.distance > 0 && (s.range = t.distance)) : t.isSpotLight && (s.type = "spot",
                t.distance > 0 && (s.range = t.distance),
                s.spot = {},
                s.spot.innerConeAngle = (1 - t.penumbra) * t.angle,
                s.spot.outerConeAngle = t.angle),
                void 0 !== t.decay && 2 !== t.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),
                !t.target || t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && -1 === t.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),
                r[this.name] || (i.extensions = i.extensions || {},
                i.extensions[this.name] = {
                    lights: []
                },
                r[this.name] = !0);
                const o = i.extensions[this.name].lights;
                o.push(s),
                e.extensions = e.extensions || {},
                e.extensions[this.name] = {
                    light: o.length - 1
                }
            }
        }
        class Cd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_unlit"
            }
            writeMaterial(t, e) {
                if (!t.isMeshBasicMaterial)
                    return;
                const n = this.writer.extensionsUsed;
                e.extensions = e.extensions || {},
                e.extensions[this.name] = {},
                n[this.name] = !0,
                e.pbrMetallicRoughness.metallicFactor = 0,
                e.pbrMetallicRoughness.roughnessFactor = .9
            }
        }
        class Md {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_clearcoat"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 === t.clearcoat)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (r.clearcoatFactor = t.clearcoat,
                t.clearcoatMap) {
                    const e = {
                        index: n.processTexture(t.clearcoatMap),
                        texCoord: t.clearcoatMap.channel
                    };
                    n.applyTextureTransform(e, t.clearcoatMap),
                    r.clearcoatTexture = e
                }
                if (r.clearcoatRoughnessFactor = t.clearcoatRoughness,
                t.clearcoatRoughnessMap) {
                    const e = {
                        index: n.processTexture(t.clearcoatRoughnessMap),
                        texCoord: t.clearcoatRoughnessMap.channel
                    };
                    n.applyTextureTransform(e, t.clearcoatRoughnessMap),
                    r.clearcoatRoughnessTexture = e
                }
                if (t.clearcoatNormalMap) {
                    const e = {
                        index: n.processTexture(t.clearcoatNormalMap),
                        texCoord: t.clearcoatNormalMap.channel
                    };
                    n.applyTextureTransform(e, t.clearcoatNormalMap),
                    r.clearcoatNormalTexture = e
                }
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Id {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_iridescence"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 === t.iridescence)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (r.iridescenceFactor = t.iridescence,
                t.iridescenceMap) {
                    const e = {
                        index: n.processTexture(t.iridescenceMap),
                        texCoord: t.iridescenceMap.channel
                    };
                    n.applyTextureTransform(e, t.iridescenceMap),
                    r.iridescenceTexture = e
                }
                if (r.iridescenceIor = t.iridescenceIOR,
                r.iridescenceThicknessMinimum = t.iridescenceThicknessRange[0],
                r.iridescenceThicknessMaximum = t.iridescenceThicknessRange[1],
                t.iridescenceThicknessMap) {
                    const e = {
                        index: n.processTexture(t.iridescenceThicknessMap),
                        texCoord: t.iridescenceThicknessMap.channel
                    };
                    n.applyTextureTransform(e, t.iridescenceThicknessMap),
                    r.iridescenceThicknessTexture = e
                }
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Td {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_transmission"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 === t.transmission)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (r.transmissionFactor = t.transmission,
                t.transmissionMap) {
                    const e = {
                        index: n.processTexture(t.transmissionMap),
                        texCoord: t.transmissionMap.channel
                    };
                    n.applyTextureTransform(e, t.transmissionMap),
                    r.transmissionTexture = e
                }
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Bd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_volume"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 === t.transmission)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (r.thicknessFactor = t.thickness,
                t.thicknessMap) {
                    const e = {
                        index: n.processTexture(t.thicknessMap),
                        texCoord: t.thicknessMap.channel
                    };
                    n.applyTextureTransform(e, t.thicknessMap),
                    r.thicknessTexture = e
                }
                r.attenuationDistance = t.attenuationDistance,
                r.attenuationColor = t.attenuationColor.toArray(),
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Rd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_ior"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 1.5 === t.ior)
                    return;
                const n = this.writer.extensionsUsed
                  , i = {};
                i.ior = t.ior,
                e.extensions = e.extensions || {},
                e.extensions[this.name] = i,
                n[this.name] = !0
            }
        }
        class Ld {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_specular"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 1 === t.specularIntensity && t.specularColor.equals(vd) && !t.specularIntensityMap && !t.specularColorTexture)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (t.specularIntensityMap) {
                    const e = {
                        index: n.processTexture(t.specularIntensityMap),
                        texCoord: t.specularIntensityMap.channel
                    };
                    n.applyTextureTransform(e, t.specularIntensityMap),
                    r.specularTexture = e
                }
                if (t.specularColorMap) {
                    const e = {
                        index: n.processTexture(t.specularColorMap),
                        texCoord: t.specularColorMap.channel
                    };
                    n.applyTextureTransform(e, t.specularColorMap),
                    r.specularColorTexture = e
                }
                r.specularFactor = t.specularIntensity,
                r.specularColorFactor = t.specularColor.toArray(),
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Dd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_sheen"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 == t.sheen)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (t.sheenRoughnessMap) {
                    const e = {
                        index: n.processTexture(t.sheenRoughnessMap),
                        texCoord: t.sheenRoughnessMap.channel
                    };
                    n.applyTextureTransform(e, t.sheenRoughnessMap),
                    r.sheenRoughnessTexture = e
                }
                if (t.sheenColorMap) {
                    const e = {
                        index: n.processTexture(t.sheenColorMap),
                        texCoord: t.sheenColorMap.channel
                    };
                    n.applyTextureTransform(e, t.sheenColorMap),
                    r.sheenColorTexture = e
                }
                r.sheenRoughnessFactor = t.sheenRoughness,
                r.sheenColorFactor = t.sheenColor.toArray(),
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Pd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_anisotropy"
            }
            writeMaterial(t, e) {
                if (!t.isMeshPhysicalMaterial || 0 == t.anisotropy)
                    return;
                const n = this.writer
                  , i = n.extensionsUsed
                  , r = {};
                if (t.anisotropyMap) {
                    const e = {
                        index: n.processTexture(t.anisotropyMap)
                    };
                    n.applyTextureTransform(e, t.anisotropyMap),
                    r.anisotropyTexture = e
                }
                r.anisotropyStrength = t.anisotropy,
                r.anisotropyRotation = t.anisotropyRotation,
                e.extensions = e.extensions || {},
                e.extensions[this.name] = r,
                i[this.name] = !0
            }
        }
        class Ud {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_emissive_strength"
            }
            writeMaterial(t, e) {
                if (!t.isMeshStandardMaterial || 1 === t.emissiveIntensity)
                    return;
                const n = this.writer.extensionsUsed
                  , i = {};
                i.emissiveStrength = t.emissiveIntensity,
                e.extensions = e.extensions || {},
                e.extensions[this.name] = i,
                n[this.name] = !0
            }
        }
        ud.Utils = {
            insertKeyframe: function(t, e) {
                const n = .001
                  , i = t.getValueSize()
                  , r = new t.TimeBufferType(t.times.length + 1)
                  , s = new t.ValueBufferType(t.values.length + i)
                  , o = t.createInterpolant(new t.ValueBufferType(i));
                let a;
                if (0 === t.times.length) {
                    r[0] = e;
                    for (let t = 0; t < i; t++)
                        s[t] = 0;
                    a = 0
                } else if (e < t.times[0]) {
                    if (Math.abs(t.times[0] - e) < n)
                        return 0;
                    r[0] = e,
                    r.set(t.times, 1),
                    s.set(o.evaluate(e), 0),
                    s.set(t.values, i),
                    a = 0
                } else if (e > t.times[t.times.length - 1]) {
                    if (Math.abs(t.times[t.times.length - 1] - e) < n)
                        return t.times.length - 1;
                    r[r.length - 1] = e,
                    r.set(t.times, 0),
                    s.set(t.values, 0),
                    s.set(o.evaluate(e), t.values.length),
                    a = r.length - 1
                } else
                    for (let l = 0; l < t.times.length; l++) {
                        if (Math.abs(t.times[l] - e) < n)
                            return l;
                        if (t.times[l] < e && t.times[l + 1] > e) {
                            r.set(t.times.slice(0, l + 1), 0),
                            r[l + 1] = e,
                            r.set(t.times.slice(l + 1), l + 2),
                            s.set(t.values.slice(0, (l + 1) * i), 0),
                            s.set(o.evaluate(e), (l + 1) * i),
                            s.set(t.values.slice((l + 1) * i), (l + 2) * i),
                            a = l + 1;
                            break
                        }
                    }
                return t.times = r,
                t.values = s,
                a
            },
            mergeMorphTargetTracks: function(t, e) {
                const n = []
                  , i = {}
                  , r = t.tracks;
                for (let t = 0; t < r.length; ++t) {
                    let s = r[t];
                    const o = hl.parseTrackName(s.name)
                      , a = hl.findNode(e, o.nodeName);
                    if ("morphTargetInfluences" !== o.propertyName || void 0 === o.propertyIndex) {
                        n.push(s);
                        continue
                    }
                    if (s.createInterpolant !== s.InterpolantFactoryMethodDiscrete && s.createInterpolant !== s.InterpolantFactoryMethodLinear) {
                        if (s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                            throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),
                        s = s.clone(),
                        s.setInterpolation(et)
                    }
                    const l = a.morphTargetInfluences.length
                      , c = a.morphTargetDictionary[o.propertyIndex];
                    if (void 0 === c)
                        throw new Error("THREE.GLTFExporter: Morph target name not found: " + o.propertyIndex);
                    let u;
                    if (void 0 === i[a.uuid]) {
                        u = s.clone();
                        const t = new u.ValueBufferType(l * u.times.length);
                        for (let e = 0; e < u.times.length; e++)
                            t[e * l + c] = u.values[e];
                        u.name = (o.nodeName || "") + ".morphTargetInfluences",
                        u.values = t,
                        i[a.uuid] = u,
                        n.push(u);
                        continue
                    }
                    const h = s.createInterpolant(new s.ValueBufferType(1));
                    u = i[a.uuid];
                    for (let t = 0; t < u.times.length; t++)
                        u.values[t * l + c] = h.evaluate(u.times[t]);
                    for (let t = 0; t < s.times.length; t++) {
                        const e = this.insertKeyframe(u, s.times[t]);
                        u.values[e * l + c] = s.values[t]
                    }
                }
                return t.tracks = n,
                t
            }
        };
        const Od = t=>void 0 !== t.material && t.userData && t.userData.variantMaterials && !!Array.from(t.userData.variantMaterials.values()).filter((t=>Nd(t.material)))
          , Nd = t=>t && t.isMaterial && !Array.isArray(t);
        class Fd {
            constructor(t) {
                this.writer = t,
                this.name = "KHR_materials_variants",
                this.variantNames = []
            }
            beforeParse(t) {
                const e = new Set;
                for (const n of t)
                    n.traverse((t=>{
                        if (!Od(t))
                            return;
                        const n = t.userData.variantMaterials
                          , i = t.userData.variantData;
                        for (const [t,r] of i) {
                            const i = n.get(r.index);
                            i && Nd(i.material) && e.add(t)
                        }
                    }
                    ));
                e.forEach((t=>this.variantNames.push(t)))
            }
            writeMesh(t, e) {
                if (!Od(t))
                    return;
                const n = t.userData
                  , i = n.variantMaterials
                  , r = n.variantData
                  , s = new Map
                  , o = new Map
                  , a = Array.from(r.values()).sort(((t,e)=>t.index - e.index));
                for (const [t,e] of a.entries())
                    o.set(e.index, t);
                for (const t of r.values()) {
                    const e = i.get(t.index);
                    if (!e || !Nd(e.material))
                        continue;
                    const n = this.writer.processMaterial(e.material);
                    s.has(n) || s.set(n, {
                        material: n,
                        variants: []
                    }),
                    s.get(n).variants.push(o.get(t.index))
                }
                const l = Array.from(s.values()).map((t=>t.variants.sort(((t,e)=>t - e)) && t)).sort(((t,e)=>t.material - e.material));
                if (0 === l.length)
                    return;
                const c = Nd(n.originalMaterial) ? this.writer.processMaterial(n.originalMaterial) : -1;
                for (const t of e.primitives)
                    c >= 0 && (t.material = c),
                    t.extensions = t.extensions || {},
                    t.extensions[this.name] = {
                        mappings: l
                    }
            }
            afterParse() {
                if (0 === this.variantNames.length)
                    return;
                const t = this.writer.json;
                t.extensions = t.extensions || {};
                const e = this.variantNames.map((t=>({
                    name: t
                })));
                t.extensions[this.name] = {
                    variants: e
                },
                this.writer.extensionsUsed[this.name] = !0
            }
        }
        class Qd {
            constructor(t, e, n, i, r) {
                this.xrLight = t,
                this.renderer = e,
                this.lightProbe = n,
                this.xrWebGLBinding = null,
                this.estimationStartCallback = r,
                this.frameCallback = this.onXRFrame.bind(this);
                const s = e.xr.getSession();
                if (i && "XRWebGLBinding"in window) {
                    const n = new Mi(16);
                    t.environment = n.texture;
                    const i = e.getContext();
                    switch (s.preferredReflectionFormat) {
                    case "srgba8":
                        i.getExtension("EXT_sRGB");
                        break;
                    case "rgba16f":
                        i.getExtension("OES_texture_half_float")
                    }
                    this.xrWebGLBinding = new XRWebGLBinding(s,i),
                    this.lightProbe.addEventListener("reflectionchange", (()=>{
                        this.updateReflection()
                    }
                    ))
                }
                s.requestAnimationFrame(this.frameCallback)
            }
            updateReflection() {
                const t = this.renderer.properties.get(this.xrLight.environment);
                if (t) {
                    const e = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
                    e && (t.__webglTexture = e,
                    this.xrLight.environment.needsPMREMUpdate = !0)
                }
            }
            onXRFrame(t, e) {
                if (!this.xrLight)
                    return;
                e.session.requestAnimationFrame(this.frameCallback);
                const n = e.getLightEstimate(this.lightProbe);
                if (n) {
                    this.xrLight.lightProbe.sh.fromArray(n.sphericalHarmonicsCoefficients),
                    this.xrLight.lightProbe.intensity = 1;
                    const t = Math.max(1, Math.max(n.primaryLightIntensity.x, Math.max(n.primaryLightIntensity.y, n.primaryLightIntensity.z)));
                    this.xrLight.directionalLight.color.setRGB(n.primaryLightIntensity.x / t, n.primaryLightIntensity.y / t, n.primaryLightIntensity.z / t),
                    this.xrLight.directionalLight.intensity = t,
                    this.xrLight.directionalLight.position.copy(n.primaryLightDirection),
                    this.estimationStartCallback && (this.estimationStartCallback(),
                    this.estimationStartCallback = null)
                }
            }
            dispose() {
                this.xrLight = null,
                this.renderer = null,
                this.lightProbe = null,
                this.xrWebGLBinding = null
            }
        }
        class kd extends so {
            constructor(t) {
                let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                super(),
                this.lightProbe = new el,
                this.lightProbe.intensity = 0,
                this.add(this.lightProbe),
                this.directionalLight = new Za,
                this.directionalLight.intensity = 0,
                this.add(this.directionalLight),
                this.environment = null;
                let n = null
                  , i = !1;
                t.xr.addEventListener("sessionstart", (()=>{
                    const r = t.xr.getSession();
                    "requestLightProbe"in r && r.requestLightProbe({
                        reflectionFormat: r.preferredReflectionFormat
                    }).then((r=>{
                        n = new Qd(this,t,r,e,(()=>{
                            i = !0,
                            this.dispatchEvent({
                                type: "estimationstart"
                            })
                        }
                        ))
                    }
                    ))
                }
                )),
                t.xr.addEventListener("sessionend", (()=>{
                    n && (n.dispose(),
                    n = null),
                    i && this.dispatchEvent({
                        type: "estimationend"
                    })
                }
                )),
                this.dispose = ()=>{
                    n && (n.dispose(),
                    n = null),
                    this.remove(this.lightProbe),
                    this.lightProbe = null,
                    this.remove(this.directionalLight),
                    this.directionalLight = null,
                    this.environment = null
                }
            }
        }
        class Gd {
            constructor() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50;
                this.velocity = 0,
                this.naturalFrequency = 0,
                this.setDecayTime(t)
            }
            setDecayTime(t) {
                this.naturalFrequency = 1 / Math.max(.001, t)
            }
            update(t, e, n, i) {
                const r = 2e-4 * this.naturalFrequency;
                if (null == t || 0 === i)
                    return e;
                if (t === e && 0 === this.velocity)
                    return e;
                if (n < 0)
                    return t;
                const s = t - e
                  , o = this.velocity + this.naturalFrequency * s
                  , a = s + n * o
                  , l = Math.exp(-this.naturalFrequency * n)
                  , c = (o - this.naturalFrequency * a) * l
                  , u = -this.naturalFrequency * (c + o * l);
                return Math.abs(c) < r * Math.abs(i) && u * s >= 0 ? (this.velocity = 0,
                e) : (this.velocity = c,
                e + a * l)
            }
        }
        const Hd = .2
          , zd = Math.PI / 24
          , Vd = new Nt
          , Wd = (t,e,n)=>{
            let i = e > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;
            for (let r = 0; r <= 12; ++r)
                t.push(e + .17 * Math.cos(i), n + .17 * Math.sin(i), 0, e + Hd * Math.cos(i), n + Hd * Math.sin(i), 0),
                i += zd
        }
        ;
        class qd extends fi {
            constructor(t, e) {
                const n = new Kn
                  , i = []
                  , r = []
                  , {size: s, boundingBox: o} = t
                  , a = s.x / 2
                  , l = ("back" === e ? s.y : s.z) / 2;
                Wd(r, a, l),
                Wd(r, -a, l),
                Wd(r, -a, -l),
                Wd(r, a, -l);
                const c = r.length / 3;
                for (let t = 0; t < c - 2; t += 2)
                    i.push(t, t + 1, t + 3, t, t + 3, t + 2);
                const u = c - 2;
                i.push(u, u + 1, 1, u, 1, 0),
                n.setAttribute("position", new Hn(r,3)),
                n.setIndex(i),
                super(n),
                this.side = e;
                const h = this.material;
                switch (h.side = 2,
                h.transparent = !0,
                h.opacity = 0,
                this.goalOpacity = 0,
                this.opacityDamper = new Gd,
                this.hitPlane = new fi(new Ni(2 * (a + Hd),2 * (l + Hd))),
                this.hitPlane.visible = !1,
                this.hitPlane.material.side = 2,
                this.add(this.hitPlane),
                o.getCenter(this.position),
                e) {
                case "bottom":
                    this.rotateX(-Math.PI / 2),
                    this.shadowHeight = o.min.y,
                    this.position.y = this.shadowHeight;
                    break;
                case "back":
                    this.shadowHeight = o.min.z,
                    this.position.z = this.shadowHeight
                }
                t.target.add(this),
                this.offsetHeight = 0
            }
            getHit(t, e, n) {
                Vd.set(e, -n),
                this.hitPlane.visible = !0;
                const i = t.positionAndNormalFromPoint(Vd, this.hitPlane);
                return this.hitPlane.visible = !1,
                null == i ? null : i.position
            }
            getExpandedHit(t, e, n) {
                this.hitPlane.scale.set(1e3, 1e3, 1e3),
                this.hitPlane.updateMatrixWorld();
                const i = this.getHit(t, e, n);
                return this.hitPlane.scale.set(1, 1, 1),
                i
            }
            set offsetHeight(t) {
                t -= .001,
                "back" === this.side ? this.position.z = this.shadowHeight + t : this.position.y = this.shadowHeight + t
            }
            get offsetHeight() {
                return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
            }
            set show(t) {
                this.goalOpacity = t ? .75 : 0
            }
            updateOpacity(t) {
                const e = this.material;
                e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1),
                this.visible = e.opacity > 0
            }
            dispose() {
                var t;
                const {geometry: e, material: n} = this.hitPlane;
                e.dispose(),
                n.dispose(),
                this.geometry.dispose(),
                this.material.dispose(),
                null === (t = this.parent) || void 0 === t || t.remove(this)
            }
        }
        const jd = (t,e)=>({
            type: "number",
            number: t,
            unit: e
        })
          , Xd = (()=>{
            const t = {};
            return e=>{
                const n = e;
                if (n in t)
                    return t[n];
                const i = [];
                let r = 0;
                for (; e; ) {
                    if (++r > 1e3) {
                        e = "";
                        break
                    }
                    const t = Yd(e)
                      , n = t.nodes[0];
                    if (null == n || 0 === n.terms.length)
                        break;
                    i.push(n),
                    e = t.remainingInput
                }
                return t[n] = i
            }
        }
        )()
          , Yd = (()=>{
            const t = /^(\-\-|[a-z\u0240-\uffff])/i
              , e = /^([\*\+\/]|[\-]\s)/i
              , n = /^[\),]/;
            return i=>{
                const r = [];
                for (; i.length && (i = i.trim(),
                !n.test(i)); )
                    if ("(" === i[0]) {
                        const {nodes: t, remainingInput: e} = Zd(i);
                        i = e,
                        r.push({
                            type: "function",
                            name: {
                                type: "ident",
                                value: "calc"
                            },
                            arguments: t
                        })
                    } else if (t.test(i)) {
                        const t = Kd(i)
                          , e = t.nodes[0];
                        if ("(" === (i = t.remainingInput)[0]) {
                            const {nodes: t, remainingInput: n} = Zd(i);
                            r.push({
                                type: "function",
                                name: e,
                                arguments: t
                            }),
                            i = n
                        } else
                            r.push(e)
                    } else if (e.test(i))
                        r.push({
                            type: "operator",
                            value: i[0]
                        }),
                        i = i.slice(1);
                    else {
                        const {nodes: t, remainingInput: e} = "#" === i[0] ? $d(i) : Jd(i);
                        if (0 === t.length)
                            break;
                        r.push(t[0]),
                        i = e
                    }
                return {
                    nodes: [{
                        type: "expression",
                        terms: r
                    }],
                    remainingInput: i
                }
            }
        }
        )()
          , Kd = (()=>{
            const t = /[^a-z0-9_\-\u0240-\uffff]/i;
            return e=>{
                const n = e.match(t);
                return {
                    nodes: [{
                        type: "ident",
                        value: null == n ? e : e.substr(0, n.index)
                    }],
                    remainingInput: null == n ? "" : e.substr(n.index)
                }
            }
        }
        )()
          , Jd = (()=>{
            const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/
              , e = /^[a-z%]+/i
              , n = /^(m|mm|cm|rad|deg|[%])$/;
            return i=>{
                const r = i.match(t)
                  , s = null == r ? "0" : r[0]
                  , o = (i = null == s ? i : i.slice(s.length)).match(e);
                let a = null != o && "" !== o[0] ? o[0] : null;
                const l = null == o ? i : i.slice(a.length);
                return null == a || n.test(a) || (a = null),
                {
                    nodes: [{
                        type: "number",
                        number: parseFloat(s) || 0,
                        unit: a
                    }],
                    remainingInput: l
                }
            }
        }
        )()
          , $d = (()=>{
            const t = /^[a-f0-9]*/i;
            return e=>{
                const n = (e = e.slice(1).trim()).match(t);
                return {
                    nodes: null == n ? [] : [{
                        type: "hex",
                        value: n[0]
                    }],
                    remainingInput: null == n ? e : e.slice(n[0].length)
                }
            }
        }
        )()
          , Zd = t=>{
            const e = [];
            for (t = t.slice(1).trim(); t.length; ) {
                const n = Yd(t);
                if (e.push(n.nodes[0]),
                "," === (t = n.remainingInput.trim())[0])
                    t = t.slice(1).trim();
                else if (")" === t[0]) {
                    t = t.slice(1);
                    break
                }
            }
            return {
                nodes: e,
                remainingInput: t
            }
        }
          , tp = Symbol("visitedTypes");
        class ep {
            constructor(t) {
                this[tp] = t
            }
            walk(t, e) {
                const n = t.slice();
                for (; n.length; ) {
                    const t = n.shift();
                    switch (this[tp].indexOf(t.type) > -1 && e(t),
                    t.type) {
                    case "expression":
                        n.unshift(...t.terms);
                        break;
                    case "function":
                        n.unshift(t.name, ...t.arguments)
                    }
                }
            }
        }
        const np = Object.freeze({
            type: "number",
            number: 0,
            unit: null
        })
          , ip = function(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
              , {number: n, unit: i} = t;
            if (isFinite(n)) {
                if ("rad" === t.unit || null == t.unit)
                    return t
            } else
                n = e,
                i = "rad";
            return {
                type: "number",
                number: ("deg" === i && null != n ? n : 0) * Math.PI / 180,
                unit: "rad"
            }
        }
          , rp = function(t) {
            let e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, {number: i, unit: r} = t;
            if (isFinite(i)) {
                if ("m" === t.unit)
                    return t
            } else
                i = n,
                r = "m";
            switch (r) {
            default:
                e = 1;
                break;
            case "cm":
                e = .01;
                break;
            case "mm":
                e = .001
            }
            return {
                type: "number",
                number: e * i,
                unit: "m"
            }
        }
          , sp = (()=>{
            const t = t=>t
              , e = {
                rad: t,
                deg: ip,
                m: t,
                mm: rp,
                cm: rp
            };
            return function(t) {
                let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : np;
                isFinite(t.number) || (t.number = n.number,
                t.unit = n.unit);
                const {unit: i} = t;
                if (null == i)
                    return t;
                const r = e[i];
                return null == r ? n : r(t)
            }
        }
        )();
        var op, ap, lp;
        const cp = Symbol("evaluate")
          , up = Symbol("lastValue");
        class hp {
            constructor() {
                this[op] = null
            }
            static evaluatableFor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : np;
                if (t instanceof hp)
                    return t;
                if ("number" === t.type)
                    return "%" === t.unit ? new fp(t,e) : t;
                switch (t.name.value) {
                case "calc":
                    return new yp(t,e);
                case "env":
                    return new gp(t)
                }
                return np
            }
            static evaluate(t) {
                return t instanceof hp ? t.evaluate() : t
            }
            static isConstant(t) {
                return !(t instanceof hp) || t.isConstant
            }
            static applyIntrinsics(t, e) {
                const {basis: n, keywords: i} = e
                  , {auto: r} = i;
                return n.map(((e,n)=>{
                    const s = null == r[n] ? e : r[n];
                    let o = t[n] ? t[n] : s;
                    if ("ident" === o.type) {
                        const t = o.value;
                        t in i && (o = i[t][n])
                    }
                    return null != o && "ident" !== o.type || (o = s),
                    "%" === o.unit ? jd(o.number / 100 * e.number, e.unit) : (o = sp(o, e),
                    o.unit !== e.unit ? e : o)
                }
                ))
            }
            get isConstant() {
                return !1
            }
            evaluate() {
                return this.isConstant && null != this[up] || (this[up] = this[cp]()),
                this[up]
            }
        }
        op = up;
        const dp = Symbol("percentage")
          , pp = Symbol("basis");
        class fp extends hp {
            constructor(t, e) {
                super(),
                this[dp] = t,
                this[pp] = e
            }
            get isConstant() {
                return !0
            }
            [cp]() {
                return jd(this[dp].number / 100 * this[pp].number, this[pp].unit)
            }
        }
        const Ap = Symbol("identNode");
        class gp extends hp {
            constructor(t) {
                super(),
                this[ap] = null;
                const e = t.arguments.length ? t.arguments[0].terms[0] : null;
                null != e && "ident" === e.type && (this[Ap] = e)
            }
            get isConstant() {
                return !1
            }
            [(ap = Ap,
            cp)]() {
                return null != this[Ap] && "window-scroll-y" === this[Ap].value ? {
                    type: "number",
                    number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
                    unit: null
                } : np
            }
        }
        const mp = /[\*\/]/
          , vp = Symbol("evaluator");
        class yp extends hp {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : np;
                if (super(),
                this[lp] = null,
                1 !== t.arguments.length)
                    return;
                const n = t.arguments[0].terms.slice()
                  , i = [];
                for (; n.length; ) {
                    const t = n.shift();
                    if (i.length > 0) {
                        const n = i[i.length - 1];
                        if ("operator" === n.type && mp.test(n.value)) {
                            const n = i.pop()
                              , r = i.pop();
                            if (null == r)
                                return;
                            i.push(new xp(n,hp.evaluatableFor(r, e),hp.evaluatableFor(t, e)));
                            continue
                        }
                    }
                    i.push("operator" === t.type ? t : hp.evaluatableFor(t, e))
                }
                for (; i.length > 2; ) {
                    const [t,n,r] = i.splice(0, 3);
                    if ("operator" !== n.type)
                        return;
                    i.unshift(new xp(n,hp.evaluatableFor(t, e),hp.evaluatableFor(r, e)))
                }
                1 === i.length && (this[vp] = i[0])
            }
            get isConstant() {
                return null == this[vp] || hp.isConstant(this[vp])
            }
            [(lp = vp,
            cp)]() {
                return null != this[vp] ? hp.evaluate(this[vp]) : np
            }
        }
        const _p = Symbol("operator")
          , Ep = Symbol("left")
          , bp = Symbol("right");
        class xp extends hp {
            constructor(t, e, n) {
                super(),
                this[_p] = t,
                this[Ep] = e,
                this[bp] = n
            }
            get isConstant() {
                return hp.isConstant(this[Ep]) && hp.isConstant(this[bp])
            }
            [cp]() {
                const t = sp(hp.evaluate(this[Ep]))
                  , e = sp(hp.evaluate(this[bp]))
                  , {number: n, unit: i} = t
                  , {number: r, unit: s} = e;
                if (null != s && null != i && s != i)
                    return np;
                const o = i || s;
                let a;
                switch (this[_p].value) {
                case "+":
                    a = n + r;
                    break;
                case "-":
                    a = n - r;
                    break;
                case "/":
                    a = n / r;
                    break;
                case "*":
                    a = n * r;
                    break;
                default:
                    return np
                }
                return {
                    type: "number",
                    number: a,
                    unit: o
                }
            }
        }
        const wp = Symbol("evaluatables")
          , Sp = Symbol("intrinsics");
        class Cp extends hp {
            constructor(t, e) {
                super(),
                this[Sp] = e;
                const n = t[0]
                  , i = null != n ? n.terms : [];
                this[wp] = e.basis.map(((t,e)=>{
                    const n = i[e];
                    return null == n ? {
                        type: "ident",
                        value: "auto"
                    } : "ident" === n.type ? n : hp.evaluatableFor(n, t)
                }
                ))
            }
            get isConstant() {
                for (const t of this[wp])
                    if (!hp.isConstant(t))
                        return !1;
                return !0
            }
            [cp]() {
                const t = this[wp].map((t=>hp.evaluate(t)));
                return hp.applyIntrinsics(t, this[Sp]).map((t=>t.number))
            }
        }
        var Mp, Ip, Tp, Bp;
        const Rp = Symbol("instances")
          , Lp = Symbol("activateListener")
          , Dp = Symbol("deactivateListener")
          , Pp = Symbol("notifyInstances")
          , Up = Symbol("notify")
          , Op = Symbol("callback");
        class Np {
            constructor(t) {
                this[Op] = t
            }
            static[Pp]() {
                for (const t of Np[Rp])
                    t[Up]()
            }
            static[(Mp = Rp,
            Lp)]() {
                window.addEventListener("scroll", this[Pp], {
                    passive: !0
                })
            }
            static[Dp]() {
                window.removeEventListener("scroll", this[Pp])
            }
            observe() {
                0 === Np[Rp].size && Np[Lp](),
                Np[Rp].add(this)
            }
            disconnect() {
                Np[Rp].delete(this),
                0 === Np[Rp].size && Np[Dp]()
            }
            [Up]() {
                this[Op]()
            }
        }
        Np[Mp] = new Set;
        const Fp = Symbol("computeStyleCallback")
          , Qp = Symbol("astWalker")
          , kp = Symbol("dependencies")
          , Gp = Symbol("onScroll");
        class Hp {
            constructor(t) {
                this[Ip] = {},
                this[Tp] = new ep(["function"]),
                this[Bp] = ()=>{
                    this[Fp]({
                        relatedState: "window-scroll"
                    })
                }
                ,
                this[Fp] = t
            }
            observeEffectsFor(t) {
                const e = {}
                  , n = this[kp];
                this[Qp].walk(t, (t=>{
                    const {name: i} = t
                      , r = t.arguments[0].terms[0];
                    if ("env" === i.value && null != r && "ident" === r.type && "window-scroll-y" === r.value && null == e["window-scroll"]) {
                        const t = "window-scroll"in n ? n["window-scroll"] : new Np(this[Gp]);
                        t.observe(),
                        delete n["window-scroll"],
                        e["window-scroll"] = t
                    }
                }
                ));
                for (const t in n)
                    n[t].disconnect();
                this[kp] = e
            }
            dispose() {
                for (const t in this[kp])
                    this[kp][t].disconnect()
            }
        }
        Ip = kp,
        Tp = Qp,
        Bp = Gp;
        const zp = t=>{
            const e = t.observeEffects || !1
              , n = t.intrinsics instanceof Function ? t.intrinsics : ()=>t.intrinsics;
            return (i,r)=>{
                const s = i.updated
                  , o = i.connectedCallback
                  , a = i.disconnectedCallback
                  , l = Symbol(`${r}StyleEffector`)
                  , c = Symbol(`${r}StyleEvaluator`)
                  , u = Symbol(`${r}UpdateEvaluator`)
                  , h = Symbol(`${r}EvaluateAndSync`);
                Object.defineProperties(i, {
                    [l]: {
                        value: null,
                        writable: !0
                    },
                    [c]: {
                        value: null,
                        writable: !0
                    },
                    [u]: {
                        value: function() {
                            const t = Xd(this[r]);
                            this[c] = new Cp(t,n(this)),
                            null == this[l] && e && (this[l] = new Hp((()=>this[h]()))),
                            null != this[l] && this[l].observeEffectsFor(t)
                        }
                    },
                    [h]: {
                        value: function() {
                            if (null == this[c])
                                return;
                            const e = this[c].evaluate();
                            this[t.updateHandler](e)
                        }
                    },
                    updated: {
                        value: function(t) {
                            t.has(r) && (this[u](),
                            this[h]()),
                            s.call(this, t)
                        }
                    },
                    connectedCallback: {
                        value: function() {
                            o.call(this),
                            this.requestUpdate(r, this[r])
                        }
                    },
                    disconnectedCallback: {
                        value: function() {
                            a.call(this),
                            null != this[l] && (this[l].dispose(),
                            this[l] = null)
                        }
                    }
                })
            }
        }
          , Vp = t=>t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1
          , Wp = function(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Vp;
            return i=>t + (e - t) * n(i)
        }
          , qp = t=>{
            const e = []
              , n = [];
            let i = t.initialValue;
            for (let r = 0; r < t.keyframes.length; ++r) {
                const s = t.keyframes[r]
                  , {value: o, frames: a} = s
                  , l = s.ease || Vp
                  , c = Wp(i, o, l);
                e.push(c),
                n.push(a),
                i = o
            }
            return ((t,e)=>{
                const n = e.map((i = 0,
                t=>i += t));
                var i;
                return e=>{
                    e = iu(e, 0, 1),
                    e *= n[n.length - 1];
                    const i = n.findIndex((t=>t >= e))
                      , r = i < 1 ? 0 : n[i - 1]
                      , s = n[i];
                    return t[i]((e - r) / (s - r))
                }
            }
            )(e, n)
        }
        ;
        var jp = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const Xp = qp({
            initialValue: 0,
            keyframes: [{
                frames: 5,
                value: -1
            }, {
                frames: 1,
                value: -1
            }, {
                frames: 8,
                value: 1
            }, {
                frames: 1,
                value: 1
            }, {
                frames: 5,
                value: 0
            }, {
                frames: 18,
                value: 0
            }]
        })
          , Yp = qp({
            initialValue: 0,
            keyframes: [{
                frames: 1,
                value: 1
            }, {
                frames: 5,
                value: 1
            }, {
                frames: 1,
                value: 0
            }, {
                frames: 6,
                value: 0
            }]
        })
          , Kp = "0deg 75deg 105%"
          , Jp = ["front", "right", "back", "left"]
          , $p = ["upper-", "", "lower-"]
          , Zp = "auto"
          , tf = "wiggle"
          , ef = ()=>({
            basis: [ip(jd(30, "deg"))],
            keywords: {
                auto: [null]
            }
        })
          , nf = ()=>({
            basis: [ip(jd(12, "deg"))],
            keywords: {
                auto: [null]
            }
        })
          , rf = (()=>{
            const t = Xd(Kp)[0].terms
              , e = sp(t[0])
              , n = sp(t[1]);
            return t=>{
                const i = t[gv].idealCameraDistance();
                return {
                    basis: [e, n, jd(i, "m")],
                    keywords: {
                        auto: [null, null, jd(105, "%")]
                    }
                }
            }
        }
        )()
          , sf = t=>{
            const e = 2.2 * t[gv].boundingSphere.radius;
            return {
                basis: [jd(-1 / 0, "rad"), jd(Math.PI / 8, "rad"), jd(e, "m")],
                keywords: {
                    auto: [null, null, null]
                }
            }
        }
          , of = t=>{
            const e = rf(t)
              , n = new Cp([],e).evaluate()[2];
            return {
                basis: [jd(1 / 0, "rad"), jd(Math.PI - Math.PI / 8, "rad"), jd(n, "m")],
                keywords: {
                    auto: [null, null, null]
                }
            }
        }
          , af = t=>{
            const e = t[gv].boundingBox.getCenter(new he);
            return {
                basis: [jd(e.x, "m"), jd(e.y, "m"), jd(e.z, "m")],
                keywords: {
                    auto: [null, null, null]
                }
            }
        }
          , lf = Math.PI / 2
          , cf = Math.PI / 3
          , uf = lf / 2
          , hf = 2 * Math.PI
          , df = Symbol("controls")
          , pf = Symbol("panElement")
          , ff = Symbol("promptElement")
          , Af = Symbol("promptAnimatedContainer")
          , gf = Symbol("fingerAnimatedContainers")
          , mf = Symbol("deferInteractionPrompt")
          , vf = Symbol("updateAria")
          , yf = Symbol("updateCameraForRadius")
          , _f = Symbol("cancelPrompts")
          , Ef = Symbol("onChange")
          , bf = Symbol("onPointerChange")
          , xf = Symbol("waitingToPromptUser")
          , wf = Symbol("userHasInteracted")
          , Sf = Symbol("promptElementVisibleTime")
          , Cf = Symbol("lastPromptOffset")
          , Mf = Symbol("cancellationSource")
          , If = Symbol("lastSpherical")
          , Tf = Symbol("jumpCamera")
          , Bf = Symbol("initialized")
          , Rf = Symbol("maintainThetaPhi")
          , Lf = Symbol("syncCameraOrbit")
          , Df = Symbol("syncFieldOfView")
          , Pf = Symbol("syncCameraTarget")
          , Uf = Symbol("syncMinCameraOrbit")
          , Of = Symbol("syncMaxCameraOrbit")
          , Nf = Symbol("syncMinFieldOfView")
          , Ff = Symbol("syncMaxFieldOfView")
          , Qf = new Nt
          , kf = new he
          , Gf = Object.freeze({
            minimumRadius: 0,
            maximumRadius: 1 / 0,
            minimumPolarAngle: Math.PI / 8,
            maximumPolarAngle: Math.PI - Math.PI / 8,
            minimumAzimuthalAngle: -1 / 0,
            maximumAzimuthalAngle: 1 / 0,
            minimumFieldOfView: 10,
            maximumFieldOfView: 45,
            touchAction: "none"
        })
          , Hf = Math.PI / 8
          , zf = .04
          , Vf = "user-interaction"
          , Wf = "none"
          , qf = "automatic";
        class jf extends bt {
            constructor(t, e, n) {
                super(),
                this.camera = t,
                this.element = e,
                this.scene = n,
                this.orbitSensitivity = 1,
                this.zoomSensitivity = 1,
                this.panSensitivity = 1,
                this.inputSensitivity = 1,
                this.changeSource = Wf,
                this._interactionEnabled = !1,
                this._disableZoom = !1,
                this.isUserPointing = !1,
                this.enablePan = !0,
                this.enableTap = !0,
                this.panProjection = new Ft,
                this.panPerPixel = 0,
                this.spherical = new vl,
                this.goalSpherical = new vl,
                this.thetaDamper = new Gd,
                this.phiDamper = new Gd,
                this.radiusDamper = new Gd,
                this.logFov = Math.log(Gf.maximumFieldOfView),
                this.goalLogFov = this.logFov,
                this.fovDamper = new Gd,
                this.touchMode = null,
                this.pointers = [],
                this.startTime = 0,
                this.startPointerPosition = {
                    clientX: 0,
                    clientY: 0
                },
                this.lastSeparation = 0,
                this.touchDecided = !1,
                this.onContext = t=>{
                    if (this.enablePan)
                        t.preventDefault();
                    else
                        for (const t of this.pointers)
                            this.onPointerUp(new PointerEvent("pointercancel",Object.assign(Object.assign({}, this.startPointerPosition), {
                                pointerId: t.id
                            })))
                }
                ,
                this.touchModeZoom = (t,e)=>{
                    if (!this._disableZoom) {
                        const t = this.twoTouchDistance(this.pointers[0], this.pointers[1])
                          , e = zf * this.zoomSensitivity * (this.lastSeparation - t) * 50 / this.scene.height;
                        this.lastSeparation = t,
                        this.userAdjustOrbit(0, 0, e)
                    }
                    this.panPerPixel > 0 && this.movePan(t, e)
                }
                ,
                this.disableScroll = t=>{
                    t.preventDefault()
                }
                ,
                this.touchModeRotate = (t,e)=>{
                    const {touchAction: n} = this._options;
                    if (!this.touchDecided && "none" !== n) {
                        this.touchDecided = !0;
                        const i = Math.abs(t)
                          , r = Math.abs(e);
                        if (this.changeSource === Vf && ("pan-y" === n && r > i || "pan-x" === n && i > r))
                            return void (this.touchMode = null);
                        this.element.addEventListener("touchmove", this.disableScroll, {
                            passive: !1
                        })
                    }
                    this.handleSinglePointerMove(t, e)
                }
                ,
                this.onPointerDown = t=>{
                    if (this.pointers.length > 2)
                        return;
                    const {element: e} = this;
                    0 === this.pointers.length && (e.addEventListener("pointermove", this.onPointerMove),
                    e.addEventListener("pointerup", this.onPointerUp),
                    this.touchMode = null,
                    this.touchDecided = !1,
                    this.startPointerPosition.clientX = t.clientX,
                    this.startPointerPosition.clientY = t.clientY,
                    this.startTime = performance.now());
                    try {
                        e.setPointerCapture(t.pointerId)
                    } catch (t) {}
                    this.pointers.push({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        id: t.pointerId
                    }),
                    this.isUserPointing = !1,
                    "touch" === t.pointerType ? (this.changeSource = t.altKey ? qf : Vf,
                    this.onTouchChange(t)) : (this.changeSource = Vf,
                    this.onMouseDown(t)),
                    this.changeSource === Vf && this.dispatchEvent({
                        type: "user-interaction"
                    })
                }
                ,
                this.onPointerMove = t=>{
                    const e = this.pointers.find((e=>e.id === t.pointerId));
                    if (null == e)
                        return;
                    if ("mouse" === t.pointerType && 0 === t.buttons)
                        return void this.onPointerUp(t);
                    const n = this.pointers.length
                      , i = (t.clientX - e.clientX) / n
                      , r = (t.clientY - e.clientY) / n;
                    0 === i && 0 === r || (e.clientX = t.clientX,
                    e.clientY = t.clientY,
                    "touch" === t.pointerType ? (this.changeSource = t.altKey ? qf : Vf,
                    null !== this.touchMode && this.touchMode(i, r)) : (this.changeSource = Vf,
                    this.panPerPixel > 0 ? this.movePan(i, r) : this.handleSinglePointerMove(i, r)))
                }
                ,
                this.onPointerUp = t=>{
                    const {element: e} = this
                      , n = this.pointers.findIndex((e=>e.id === t.pointerId));
                    -1 !== n && this.pointers.splice(n, 1),
                    this.panPerPixel > 0 && !t.altKey && this.resetRadius(),
                    0 === this.pointers.length ? (e.removeEventListener("pointermove", this.onPointerMove),
                    e.removeEventListener("pointerup", this.onPointerUp),
                    e.removeEventListener("touchmove", this.disableScroll),
                    this.enablePan && this.enableTap && this.recenter(t)) : null !== this.touchMode && this.onTouchChange(t),
                    this.scene.element[pf].style.opacity = 0,
                    e.style.cursor = "grab",
                    this.panPerPixel = 0,
                    this.isUserPointing && this.dispatchEvent({
                        type: "pointer-change-end"
                    })
                }
                ,
                this.onWheel = t=>{
                    this.changeSource = Vf;
                    const e = t.deltaY * (1 == t.deltaMode ? 18 : 1) * zf * this.zoomSensitivity / 30;
                    this.userAdjustOrbit(0, 0, e),
                    t.preventDefault(),
                    this.dispatchEvent({
                        type: "user-interaction"
                    })
                }
                ,
                this.onKeyDown = t=>{
                    const {changeSource: e} = this;
                    this.changeSource = Vf,
                    (t.shiftKey && this.enablePan ? this.panKeyCodeHandler(t) : this.orbitZoomKeyCodeHandler(t)) ? (t.preventDefault(),
                    this.dispatchEvent({
                        type: "user-interaction"
                    })) : this.changeSource = e
                }
                ,
                this._options = Object.assign({}, Gf),
                this.setOrbit(0, Math.PI / 2, 1),
                this.setFieldOfView(100),
                this.jumpToGoal()
            }
            get interactionEnabled() {
                return this._interactionEnabled
            }
            enableInteraction() {
                if (!1 === this._interactionEnabled) {
                    const {element: t} = this;
                    t.addEventListener("pointerdown", this.onPointerDown),
                    t.addEventListener("pointercancel", this.onPointerUp),
                    this._disableZoom || t.addEventListener("wheel", this.onWheel),
                    t.addEventListener("keydown", this.onKeyDown),
                    t.addEventListener("touchmove", (()=>{}
                    ), {
                        passive: !1
                    }),
                    t.addEventListener("contextmenu", this.onContext),
                    this.element.style.cursor = "grab",
                    this._interactionEnabled = !0,
                    this.updateTouchActionStyle()
                }
            }
            disableInteraction() {
                if (!0 === this._interactionEnabled) {
                    const {element: t} = this;
                    t.removeEventListener("pointerdown", this.onPointerDown),
                    t.removeEventListener("pointermove", this.onPointerMove),
                    t.removeEventListener("pointerup", this.onPointerUp),
                    t.removeEventListener("pointercancel", this.onPointerUp),
                    t.removeEventListener("wheel", this.onWheel),
                    t.removeEventListener("keydown", this.onKeyDown),
                    t.removeEventListener("contextmenu", this.onContext),
                    t.style.cursor = "",
                    this.touchMode = null,
                    this._interactionEnabled = !1,
                    this.updateTouchActionStyle()
                }
            }
            get options() {
                return this._options
            }
            set disableZoom(t) {
                this._disableZoom != t && (this._disableZoom = t,
                !0 === t ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel),
                this.updateTouchActionStyle())
            }
            getCameraSpherical() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new vl).copy(this.spherical)
            }
            getFieldOfView() {
                return this.camera.fov
            }
            applyOptions(t) {
                Object.assign(this._options, t),
                this.setOrbit(),
                this.setFieldOfView(Math.exp(this.goalLogFov))
            }
            updateNearFar(t, e) {
                this.camera.far = 0 === e ? 2 : e,
                this.camera.near = Math.max(t, this.camera.far / 1e3),
                this.camera.updateProjectionMatrix()
            }
            updateAspect(t) {
                this.camera.aspect = t,
                this.camera.updateProjectionMatrix()
            }
            setOrbit() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.goalSpherical.theta
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.goalSpherical.phi
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.goalSpherical.radius;
                const {minimumAzimuthalAngle: i, maximumAzimuthalAngle: r, minimumPolarAngle: s, maximumPolarAngle: o, minimumRadius: a, maximumRadius: l} = this._options
                  , {theta: c, phi: u, radius: h} = this.goalSpherical
                  , d = iu(t, i, r);
                isFinite(i) || isFinite(r) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d);
                const p = iu(e, s, o)
                  , f = iu(n, a, l);
                return !(d === c && p === u && f === h || !(isFinite(d) && isFinite(p) && isFinite(f)) || (this.goalSpherical.theta = d,
                this.goalSpherical.phi = p,
                this.goalSpherical.radius = f,
                this.goalSpherical.makeSafe(),
                0))
            }
            setRadius(t) {
                this.goalSpherical.radius = t,
                this.setOrbit()
            }
            setFieldOfView(t) {
                const {minimumFieldOfView: e, maximumFieldOfView: n} = this._options;
                t = iu(t, e, n),
                this.goalLogFov = Math.log(t)
            }
            setDamperDecayTime(t) {
                this.thetaDamper.setDecayTime(t),
                this.phiDamper.setDecayTime(t),
                this.radiusDamper.setDecayTime(t),
                this.fovDamper.setDecayTime(t)
            }
            adjustOrbit(t, e, n) {
                const {theta: i, phi: r, radius: s} = this.goalSpherical
                  , {minimumRadius: o, maximumRadius: a, minimumFieldOfView: l, maximumFieldOfView: c} = this._options
                  , u = this.spherical.theta - i
                  , h = Math.PI - .001
                  , d = i - iu(t, -h - u, h - u)
                  , p = r - e
                  , f = 0 === n ? 0 : ((n > 0 ? a : o) - s) / (Math.log(n > 0 ? c : l) - this.goalLogFov)
                  , A = s + n * (isFinite(f) ? f : 2 * (a - o));
                if (this.setOrbit(d, p, A),
                0 !== n) {
                    const t = this.goalLogFov + n;
                    this.setFieldOfView(Math.exp(t))
                }
            }
            jumpToGoal() {
                this.update(0, 1e4)
            }
            update(t, e) {
                if (this.isStationary())
                    return !1;
                const {maximumPolarAngle: n, maximumRadius: i} = this._options
                  , r = this.spherical.theta - this.goalSpherical.theta;
                return Math.abs(r) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r) * Math.PI),
                this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e, Math.PI),
                this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, n),
                this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e, i),
                this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1),
                this.moveCamera(),
                !0
            }
            updateTouchActionStyle() {
                const {style: t} = this.element;
                if (this._interactionEnabled) {
                    const {touchAction: e} = this._options;
                    this._disableZoom && "none" !== e ? t.touchAction = "manipulation" : t.touchAction = e
                } else
                    t.touchAction = ""
            }
            isStationary() {
                return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov
            }
            moveCamera() {
                this.spherical.makeSafe(),
                this.camera.position.setFromSpherical(this.spherical),
                this.camera.setRotationFromEuler(new Je(this.spherical.phi - Math.PI / 2,this.spherical.theta,0,"YXZ")),
                this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov),
                this.camera.updateProjectionMatrix())
            }
            userAdjustOrbit(t, e, n) {
                this.adjustOrbit(t * this.orbitSensitivity * this.inputSensitivity, e * this.orbitSensitivity * this.inputSensitivity, n * this.inputSensitivity)
            }
            wrapAngle(t) {
                const e = (t + Math.PI) / (2 * Math.PI);
                return 2 * (e - Math.floor(e)) * Math.PI - Math.PI
            }
            pixelLengthToSphericalAngle(t) {
                return 2 * Math.PI * t / this.scene.height
            }
            twoTouchDistance(t, e) {
                const {clientX: n, clientY: i} = t
                  , {clientX: r, clientY: s} = e
                  , o = r - n
                  , a = s - i;
                return Math.sqrt(o * o + a * a)
            }
            handleSinglePointerMove(t, e) {
                const n = this.pixelLengthToSphericalAngle(t)
                  , i = this.pixelLengthToSphericalAngle(e);
                !1 === this.isUserPointing && (this.isUserPointing = !0,
                this.dispatchEvent({
                    type: "pointer-change-start"
                })),
                this.userAdjustOrbit(n, i, 0)
            }
            initializePan() {
                const {theta: t, phi: e} = this.spherical
                  , n = t - this.scene.yaw;
                this.panPerPixel = .018 * this.panSensitivity / this.scene.height,
                this.panProjection.set(-Math.cos(n), -Math.cos(e) * Math.sin(n), 0, 0, Math.sin(e), 0, Math.sin(n), -Math.cos(e) * Math.cos(n), 0)
            }
            movePan(t, e) {
                const {scene: n} = this
                  , i = kf.set(t, e, 0).multiplyScalar(this.inputSensitivity)
                  , r = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
                i.multiplyScalar(r);
                const s = n.getTarget();
                s.add(i.applyMatrix3(this.panProjection)),
                n.boundingSphere.clampPoint(s, s),
                n.setTarget(s.x, s.y, s.z)
            }
            recenter(t) {
                if (performance.now() > this.startTime + 300 || Math.abs(t.clientX - this.startPointerPosition.clientX) > 2 || Math.abs(t.clientY - this.startPointerPosition.clientY) > 2)
                    return;
                const {scene: e} = this
                  , n = e.positionAndNormalFromPoint(e.getNDC(t.clientX, t.clientY));
                if (null == n) {
                    const {cameraTarget: t} = e.element;
                    e.element.cameraTarget = "",
                    e.element.cameraTarget = t,
                    this.userAdjustOrbit(0, 0, 1)
                } else
                    e.target.worldToLocal(n.position),
                    e.setTarget(n.position.x, n.position.y, n.position.z)
            }
            resetRadius() {
                const {scene: t} = this
                  , e = t.positionAndNormalFromPoint(Qf.set(0, 0));
                if (null == e)
                    return;
                t.target.worldToLocal(e.position);
                const n = t.getTarget()
                  , {theta: i, phi: r} = this.spherical
                  , s = i - t.yaw
                  , o = kf.set(Math.sin(r) * Math.sin(s), Math.cos(r), Math.sin(r) * Math.cos(s))
                  , a = o.dot(e.position.sub(n));
                n.add(o.multiplyScalar(a)),
                t.setTarget(n.x, n.y, n.z),
                this.setOrbit(void 0, void 0, this.goalSpherical.radius - a)
            }
            onTouchChange(t) {
                if (1 === this.pointers.length)
                    this.touchMode = this.touchModeRotate;
                else {
                    if (this._disableZoom)
                        return this.touchMode = null,
                        void this.element.removeEventListener("touchmove", this.disableScroll);
                    this.touchMode = this.touchDecided && null === this.touchMode ? null : this.touchModeZoom,
                    this.touchDecided = !0,
                    this.element.addEventListener("touchmove", this.disableScroll, {
                        passive: !1
                    }),
                    this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]),
                    this.enablePan && null != this.touchMode && (this.initializePan(),
                    t.altKey || (this.scene.element[pf].style.opacity = 1))
                }
            }
            onMouseDown(t) {
                this.panPerPixel = 0,
                this.enablePan && (2 === t.button || t.ctrlKey || t.metaKey || t.shiftKey) && (this.initializePan(),
                this.scene.element[pf].style.opacity = 1),
                this.element.style.cursor = "grabbing"
            }
            orbitZoomKeyCodeHandler(t) {
                let e = !0;
                switch (t.key) {
                case "PageUp":
                    this.userAdjustOrbit(0, 0, zf * this.zoomSensitivity);
                    break;
                case "PageDown":
                    this.userAdjustOrbit(0, 0, -.04 * this.zoomSensitivity);
                    break;
                case "ArrowUp":
                    this.userAdjustOrbit(0, -Hf, 0);
                    break;
                case "ArrowDown":
                    this.userAdjustOrbit(0, Hf, 0);
                    break;
                case "ArrowLeft":
                    this.userAdjustOrbit(-Hf, 0, 0);
                    break;
                case "ArrowRight":
                    this.userAdjustOrbit(Hf, 0, 0);
                    break;
                default:
                    e = !1
                }
                return e
            }
            panKeyCodeHandler(t) {
                this.initializePan();
                let e = !0;
                switch (t.key) {
                case "ArrowUp":
                    this.movePan(0, -10);
                    break;
                case "ArrowDown":
                    this.movePan(0, 10);
                    break;
                case "ArrowLeft":
                    this.movePan(-10, 0);
                    break;
                case "ArrowRight":
                    this.movePan(10, 0);
                    break;
                default:
                    e = !1
                }
                return e
            }
        }
        const Xf = "not-presenting"
          , Yf = "session-started"
          , Kf = "tracking"
          , Jf = new he
          , $f = new Ge
          , Zf = new he
          , tA = new xi(45,1,.1,100);
        class eA extends bt {
            constructor(t) {
                super(),
                this.renderer = t,
                this.currentSession = null,
                this.placeOnWall = !1,
                this.placementBox = null,
                this.lastTick = null,
                this.turntableRotation = null,
                this.oldShadowIntensity = null,
                this.frame = null,
                this.initialHitSource = null,
                this.transientHitTestSource = null,
                this.inputSource = null,
                this._presentedScene = null,
                this.resolveCleanup = null,
                this.exitWebXRButtonContainer = null,
                this.overlay = null,
                this.xrLight = null,
                this.tracking = !0,
                this.frames = 0,
                this.initialized = !1,
                this.oldTarget = new he,
                this.placementComplete = !1,
                this.isTranslating = !1,
                this.isRotating = !1,
                this.isTwoFingering = !1,
                this.lastDragPosition = new he,
                this.firstRatio = 0,
                this.lastAngle = 0,
                this.goalPosition = new he,
                this.goalYaw = 0,
                this.goalScale = 1,
                this.xDamper = new Gd,
                this.yDamper = new Gd,
                this.zDamper = new Gd,
                this.yawDamper = new Gd,
                this.scaleDamper = new Gd,
                this.onExitWebXRButtonContainerClick = ()=>this.stopPresenting(),
                this.onUpdateScene = ()=>{
                    null != this.placementBox && this.isPresenting && (this.placementBox.dispose(),
                    this.placementBox = new qd(this.presentedScene,this.placeOnWall ? "back" : "bottom"))
                }
                ,
                this.onSelectStart = t=>{
                    const e = this.transientHitTestSource;
                    if (null == e)
                        return;
                    const n = this.frame.getHitTestResultsForTransientInput(e)
                      , i = this.presentedScene
                      , r = this.placementBox;
                    if (1 === n.length) {
                        this.inputSource = t.inputSource;
                        const {axes: e} = this.inputSource.gamepad
                          , n = r.getHit(this.presentedScene, e[0], e[1]);
                        r.show = !0,
                        null != n ? (this.isTranslating = !0,
                        this.lastDragPosition.copy(n)) : !1 === this.placeOnWall && (this.isRotating = !0,
                        this.lastAngle = 1.5 * e[0])
                    } else if (2 === n.length) {
                        r.show = !0,
                        this.isTwoFingering = !0;
                        const {separation: t} = this.fingerPolar(n);
                        this.firstRatio = t / i.scale.x
                    }
                }
                ,
                this.onSelectEnd = ()=>{
                    this.isTranslating = !1,
                    this.isRotating = !1,
                    this.isTwoFingering = !1,
                    this.inputSource = null,
                    this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x,
                    this.placementBox.show = !1
                }
                ,
                this.threeRenderer = t.threeRenderer,
                this.threeRenderer.xr.enabled = !0
            }
            async resolveARSession() {
                tu();
                const t = await navigator.xr.requestSession("immersive-ar", {
                    requiredFeatures: ["hit-test"],
                    optionalFeatures: ["dom-overlay", "light-estimation"],
                    domOverlay: this.overlay ? {
                        root: this.overlay
                    } : void 0
                });
                return this.threeRenderer.xr.setReferenceSpaceType("local"),
                await this.threeRenderer.xr.setSession(t),
                this.threeRenderer.xr.cameraAutoUpdate = !1,
                t
            }
            get presentedScene() {
                return this._presentedScene
            }
            async supportsPresentation() {
                try {
                    return tu(),
                    await navigator.xr.isSessionSupported("immersive-ar")
                } catch (t) {
                    return console.warn("Request to present in WebXR denied:"),
                    console.warn(t),
                    console.warn("Falling back to next ar-mode"),
                    !1
                }
            }
            async present(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                this.isPresenting && console.warn("Cannot present while a model is already presenting");
                let n = new Promise(((t,e)=>{
                    requestAnimationFrame((()=>t()))
                }
                ));
                t.setHotspotsVisibility(!1),
                t.queueRender(),
                await n,
                this._presentedScene = t,
                this.overlay = t.element.shadowRoot.querySelector("div.default"),
                !0 === e && (this.xrLight = new kd(this.threeRenderer),
                this.xrLight.addEventListener("estimationstart", (()=>{
                    if (!this.isPresenting || null == this.xrLight)
                        return;
                    const t = this.presentedScene;
                    t.add(this.xrLight),
                    t.environment = this.xrLight.environment
                }
                )));
                const i = await this.resolveARSession();
                i.addEventListener("end", (()=>{
                    this.dispatchEvent({
                        type: "status",
                        status: "session-end"
                    }),
                    this.postSessionCleanup()
                }
                ), {
                    once: !0
                });
                const r = t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
                r.classList.add("enabled"),
                r.addEventListener("click", this.onExitWebXRButtonContainerClick),
                this.exitWebXRButtonContainer = r;
                const s = await i.requestReferenceSpace("viewer");
                this.tracking = !0,
                this.frames = 0,
                this.initialized = !1,
                this.turntableRotation = t.yaw,
                this.goalYaw = t.yaw,
                this.goalScale = 1,
                t.background = null,
                this.oldShadowIntensity = t.shadowIntensity,
                t.setShadowIntensity(.01),
                this.oldTarget.copy(t.getTarget()),
                t.element.addEventListener("load", this.onUpdateScene);
                const o = 20 * Math.PI / 180
                  , a = !0 === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0,0,0),{
                    x: 0,
                    y: -Math.sin(o),
                    z: -Math.cos(o)
                });
                i.requestHitTestSource({
                    space: s,
                    offsetRay: a
                }).then((t=>{
                    this.initialHitSource = t
                }
                )),
                this.currentSession = i,
                this.placementBox = new qd(t,this.placeOnWall ? "back" : "bottom"),
                this.placementComplete = !1,
                this.lastTick = performance.now(),
                this.dispatchEvent({
                    type: "status",
                    status: Yf
                })
            }
            async stopPresenting() {
                if (!this.isPresenting)
                    return;
                const t = new Promise((t=>{
                    this.resolveCleanup = t
                }
                ));
                try {
                    await this.currentSession.end(),
                    await t
                } catch (t) {
                    console.warn("Error while trying to end WebXR AR session"),
                    console.warn(t),
                    this.postSessionCleanup()
                }
            }
            get isPresenting() {
                return null != this.presentedScene
            }
            get target() {
                return this.oldTarget
            }
            updateTarget() {
                const t = this.presentedScene;
                if (null != t) {
                    const e = t.getTarget();
                    this.oldTarget.copy(e),
                    this.placeOnWall ? e.z = t.boundingBox.min.z : e.y = t.boundingBox.min.y,
                    t.setTarget(e.x, e.y, e.z)
                }
            }
            postSessionCleanup() {
                const t = this.currentSession;
                null != t && (t.removeEventListener("selectstart", this.onSelectStart),
                t.removeEventListener("selectend", this.onSelectEnd),
                this.currentSession = null);
                const e = this.presentedScene;
                if (this._presentedScene = null,
                null != e) {
                    const {element: t} = e;
                    null != this.xrLight && (e.remove(this.xrLight),
                    this.xrLight.dispose(),
                    this.xrLight = null),
                    e.position.set(0, 0, 0),
                    e.scale.set(1, 1, 1),
                    e.setShadowOffset(0);
                    const n = this.turntableRotation;
                    null != n && (e.yaw = n);
                    const i = this.oldShadowIntensity;
                    null != i && e.setShadowIntensity(i),
                    e.setEnvironmentAndSkybox(t[lu], t[cu]);
                    const r = this.oldTarget;
                    e.setTarget(r.x, r.y, r.z),
                    e.xrCamera = null,
                    e.element.removeEventListener("load", this.onUpdateScene),
                    e.orientHotspots(0),
                    t.requestUpdate("cameraTarget"),
                    t.requestUpdate("maxCameraOrbit"),
                    t[_v](t.getBoundingClientRect()),
                    requestAnimationFrame((()=>{
                        e.element.dispatchEvent(new CustomEvent("camera-change",{
                            detail: {
                                source: Wf
                            }
                        }))
                    }
                    ))
                }
                this.renderer.height = 0;
                const n = this.exitWebXRButtonContainer;
                null != n && (n.classList.remove("enabled"),
                n.removeEventListener("click", this.onExitWebXRButtonContainerClick),
                this.exitWebXRButtonContainer = null);
                const i = this.transientHitTestSource;
                null != i && (i.cancel(),
                this.transientHitTestSource = null);
                const r = this.initialHitSource;
                null != r && (r.cancel(),
                this.initialHitSource = null),
                null != this.placementBox && (this.placementBox.dispose(),
                this.placementBox = null),
                this.lastTick = null,
                this.turntableRotation = null,
                this.oldShadowIntensity = null,
                this.frame = null,
                this.inputSource = null,
                this.overlay = null,
                null != this.resolveCleanup && this.resolveCleanup(),
                this.dispatchEvent({
                    type: "status",
                    status: Xf
                })
            }
            updateView(t) {
                const e = this.presentedScene
                  , n = this.threeRenderer.xr;
                n.updateCamera(tA),
                e.xrCamera = n.getCamera();
                const {elements: i} = e.getCamera().matrixWorld;
                if (e.orientHotspots(Math.atan2(i[1], i[5])),
                this.initialized || (this.placeInitially(),
                this.initialized = !0),
                t.requestViewportScale && t.recommendedViewportScale) {
                    const e = t.recommendedViewportScale;
                    t.requestViewportScale(Math.max(e, .25))
                }
                const r = n.getBaseLayer();
                if (null != r) {
                    const e = r instanceof XRWebGLLayer ? r.getViewport(t) : n.getBinding().getViewSubImage(r, t).viewport;
                    this.threeRenderer.setViewport(e.x, e.y, e.width, e.height)
                }
            }
            placeInitially() {
                const t = this.presentedScene
                  , {position: e, element: n} = t
                  , i = t.getCamera()
                  , {width: r, height: s} = this.overlay.getBoundingClientRect();
                t.setSize(r, s),
                i.projectionMatrixInverse.copy(i.projectionMatrix).invert();
                const {theta: o, radius: a} = n.getCameraOrbit()
                  , l = i.getWorldDirection(Jf);
                t.yaw = Math.atan2(-l.x, -l.z) - o,
                this.goalYaw = t.yaw,
                e.copy(i.position).add(l.multiplyScalar(a)),
                this.updateTarget();
                const c = t.getTarget();
                e.add(c).sub(this.oldTarget),
                this.goalPosition.copy(e),
                t.setHotspotsVisibility(!0);
                const {session: u} = this.frame;
                u.addEventListener("selectstart", this.onSelectStart),
                u.addEventListener("selectend", this.onSelectEnd),
                u.requestHitTestSourceForTransientInput({
                    profile: "generic-touchscreen"
                }).then((t=>{
                    this.transientHitTestSource = t
                }
                ))
            }
            getTouchLocation() {
                const {axes: t} = this.inputSource.gamepad;
                let e = this.placementBox.getExpandedHit(this.presentedScene, t[0], t[1]);
                return null != e && (Jf.copy(e).sub(this.presentedScene.getCamera().position),
                Jf.length() > 10) ? null : e
            }
            getHitPoint(t) {
                const e = this.threeRenderer.xr.getReferenceSpace()
                  , n = t.getPose(e);
                if (null == n)
                    return null;
                const i = $f.fromArray(n.transform.matrix);
                return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(i.elements[4], i.elements[6])),
                i.elements[5] > .75 !== this.placeOnWall ? Zf.setFromMatrixPosition(i) : null
            }
            moveToFloor(t) {
                const e = this.initialHitSource;
                if (null == e)
                    return;
                const n = t.getHitTestResults(e);
                if (0 == n.length)
                    return;
                const i = n[0]
                  , r = this.getHitPoint(i);
                null != r && (this.placementBox.show = !0,
                this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(r) : this.goalPosition.y = r.y),
                e.cancel(),
                this.initialHitSource = null,
                this.dispatchEvent({
                    type: "status",
                    status: "object-placed"
                }))
            }
            fingerPolar(t) {
                const e = t[0].inputSource.gamepad.axes
                  , n = t[1].inputSource.gamepad.axes
                  , i = n[0] - e[0]
                  , r = n[1] - e[1]
                  , s = Math.atan2(r, i);
                let o = this.lastAngle - s;
                return o > Math.PI ? o -= 2 * Math.PI : o < -Math.PI && (o += 2 * Math.PI),
                this.lastAngle = s,
                {
                    separation: Math.sqrt(i * i + r * r),
                    deltaYaw: o
                }
            }
            processInput(t) {
                const e = this.transientHitTestSource;
                if (null == e)
                    return;
                if (!this.isTranslating && !this.isTwoFingering && !this.isRotating)
                    return;
                const n = t.getHitTestResultsForTransientInput(e)
                  , i = this.presentedScene
                  , r = i.scale.x;
                if (this.isTwoFingering)
                    if (n.length < 2)
                        this.isTwoFingering = !1;
                    else {
                        const {separation: t, deltaYaw: e} = this.fingerPolar(n);
                        if (!1 === this.placeOnWall && (this.goalYaw += e),
                        i.canScale) {
                            const e = t / this.firstRatio;
                            this.goalScale = e < 1.3 && e > .7692307692307692 ? 1 : e
                        }
                    }
                else if (2 !== n.length)
                    if (this.isRotating) {
                        const t = 1.5 * this.inputSource.gamepad.axes[0];
                        this.goalYaw += t - this.lastAngle,
                        this.lastAngle = t
                    } else
                        this.isTranslating && n.forEach((t=>{
                            if (t.inputSource !== this.inputSource)
                                return;
                            let e = null;
                            if (t.results.length > 0 && (e = this.getHitPoint(t.results[0])),
                            null == e && (e = this.getTouchLocation()),
                            null != e) {
                                if (this.goalPosition.sub(this.lastDragPosition),
                                !1 === this.placeOnWall) {
                                    const t = e.y - this.lastDragPosition.y;
                                    if (t < 0) {
                                        this.placementBox.offsetHeight = t / r,
                                        this.presentedScene.setShadowOffset(t);
                                        const n = Jf.copy(i.getCamera().position)
                                          , s = -t / (n.y - e.y);
                                        n.multiplyScalar(s),
                                        e.multiplyScalar(1 - s).add(n)
                                    }
                                }
                                this.goalPosition.add(e),
                                this.lastDragPosition.copy(e)
                            }
                        }
                        ));
                else {
                    this.isTranslating = !1,
                    this.isRotating = !1,
                    this.isTwoFingering = !0;
                    const {separation: t} = this.fingerPolar(n);
                    this.firstRatio = t / r
                }
            }
            moveScene(t) {
                const e = this.presentedScene
                  , {position: n, yaw: i} = e
                  , r = e.boundingSphere.radius
                  , s = this.goalPosition
                  , o = e.scale.x
                  , a = this.placementBox;
                let l = Wf;
                if (!s.equals(n) || this.goalScale !== o) {
                    l = Vf;
                    let {x: i, y: c, z: u} = n;
                    i = this.xDamper.update(i, s.x, t, r),
                    c = this.yDamper.update(c, s.y, t, r),
                    u = this.zDamper.update(u, s.z, t, r),
                    n.set(i, c, u);
                    const h = this.scaleDamper.update(o, this.goalScale, t, 1);
                    if (e.scale.set(h, h, h),
                    !this.isTranslating) {
                        const t = s.y - c;
                        this.placementComplete && !1 === this.placeOnWall ? (a.offsetHeight = t / h,
                        e.setShadowOffset(t)) : 0 === t && (this.placementComplete = !0,
                        a.show = !1,
                        e.setShadowIntensity(.8))
                    }
                }
                a.updateOpacity(t),
                e.updateTarget(t),
                e.yaw = this.yawDamper.update(i, this.goalYaw, t, Math.PI),
                e.element.dispatchEvent(new CustomEvent("camera-change",{
                    detail: {
                        source: l
                    }
                }))
            }
            onWebXRFrame(t, e) {
                this.frame = e,
                ++this.frames;
                const n = this.threeRenderer.xr.getReferenceSpace()
                  , i = e.getViewerPose(n);
                null == i && !0 === this.tracking && this.frames > 30 && (this.tracking = !1,
                this.dispatchEvent({
                    type: "tracking",
                    status: "not-tracking"
                }));
                const r = this.presentedScene;
                if (null == i || null == r || !r.element.loaded)
                    return void this.threeRenderer.clear();
                !1 === this.tracking && (this.tracking = !0,
                this.dispatchEvent({
                    type: "tracking",
                    status: Kf
                }));
                let s = !0;
                for (const n of i.views) {
                    if (this.updateView(n),
                    s) {
                        this.moveToFloor(e),
                        this.processInput(e);
                        const n = t - this.lastTick;
                        this.moveScene(n),
                        this.renderer.preRender(r, t, n),
                        this.lastTick = t,
                        r.renderShadow(this.threeRenderer)
                    }
                    this.threeRenderer.render(r, r.getCamera()),
                    s = !1
                }
            }
        }
        function nA(t) {
            const e = new Map
              , n = new Map
              , i = t.clone();
            return iA(t, i, (function(t, i) {
                e.set(i, t),
                n.set(t, i)
            }
            )),
            i.traverse((function(t) {
                if (!t.isSkinnedMesh)
                    return;
                const i = t
                  , r = e.get(t)
                  , s = r.skeleton.bones;
                i.skeleton = r.skeleton.clone(),
                i.bindMatrix.copy(r.bindMatrix),
                i.skeleton.bones = s.map((function(t) {
                    return n.get(t)
                }
                )),
                i.bind(i.skeleton, i.bindMatrix)
            }
            )),
            i
        }
        function iA(t, e, n) {
            n(t, e);
            for (let i = 0; i < t.children.length; i++)
                iA(t.children[i], e.children[i], n)
        }
        const rA = Symbol("prepared")
          , sA = Symbol("prepare")
          , oA = Symbol("preparedGLTF")
          , aA = Symbol("clone");
        class lA {
            constructor(t) {
                this[oA] = t
            }
            static prepare(t) {
                if (null == t.scene)
                    throw new Error("Model does not have a scene");
                if (t[rA])
                    return t;
                const e = this[sA](t);
                return e[rA] = !0,
                e
            }
            static[sA](t) {
                const {scene: e} = t
                  , n = [e];
                return Object.assign(Object.assign({}, t), {
                    scene: e,
                    scenes: n
                })
            }
            get parser() {
                return this[oA].parser
            }
            get animations() {
                return this[oA].animations
            }
            get scene() {
                return this[oA].scene
            }
            get scenes() {
                return this[oA].scenes
            }
            get cameras() {
                return this[oA].cameras
            }
            get asset() {
                return this[oA].asset
            }
            get userData() {
                return this[oA].userData
            }
            clone() {
                return new (0,
                this.constructor)(this[aA]())
            }
            dispose() {
                this.scenes.forEach((t=>{
                    t.traverse((t=>{
                        const e = t;
                        e.material && ((Array.isArray(e.material) ? e.material : [e.material]).forEach((t=>{
                            for (const e in t) {
                                const n = t[e];
                                if (n instanceof re) {
                                    const t = n.source.data;
                                    null != t.close && t.close(),
                                    n.dispose()
                                }
                            }
                            t.dispose()
                        }
                        )),
                        e.geometry.dispose())
                    }
                    ))
                }
                ))
            }
            [aA]() {
                const t = this[oA]
                  , e = nA(this.scene);
                cA(e, this.scene);
                const n = [e]
                  , i = t.userData ? Object.assign({}, t.userData) : {};
                return Object.assign(Object.assign({}, t), {
                    scene: e,
                    scenes: n,
                    userData: i
                })
            }
        }
        const cA = (t,e)=>{
            uA(t, e, ((t,e)=>{
                void 0 !== e.userData.variantMaterials && (t.userData.variantMaterials = new Map(e.userData.variantMaterials)),
                void 0 !== e.userData.variantData && (t.userData.variantData = e.userData.variantData),
                void 0 !== e.userData.originalMaterial && (t.userData.originalMaterial = e.userData.originalMaterial)
            }
            ))
        }
          , uA = (t,e,n)=>{
            n(t, e);
            for (let i = 0; i < t.children.length; i++)
                uA(t.children[i], e.children[i], n)
        }
          , hA = Symbol("threeGLTF")
          , dA = Symbol("gltf")
          , pA = Symbol("gltfElementMap")
          , fA = Symbol("threeObjectMap")
          , AA = Symbol("parallelTraverseThreeScene")
          , gA = Symbol("correlateOriginalThreeGLTF")
          , mA = Symbol("correlateCloneThreeGLTF");
        class vA {
            constructor(t, e, n, i) {
                this[hA] = t,
                this[dA] = e,
                this[pA] = i,
                this[fA] = n
            }
            static from(t, e) {
                return null != e ? this[mA](t, e) : this[gA](t)
            }
            static[gA](t) {
                const e = t.parser.json
                  , n = t.parser.associations
                  , i = new Map
                  , r = {
                    name: "Default"
                }
                  , s = {
                    type: "materials",
                    index: -1
                };
                for (const t of n.keys())
                    t instanceof Mn && null == n.get(t) && (s.index < 0 && (null == e.materials && (e.materials = []),
                    s.index = e.materials.length,
                    e.materials.push(r)),
                    t.name = r.name,
                    n.set(t, {
                        materials: s.index
                    }));
                for (const [t,r] of n) {
                    if (r) {
                        const e = t;
                        e.userData = e.userData || {},
                        e.userData.associations = r
                    }
                    for (const n in r)
                        if (null != n && "primitives" !== n) {
                            const s = n
                              , o = (e[s] || [])[r[s]];
                            if (null == o)
                                continue;
                            let a = i.get(o);
                            null == a && (a = new Set,
                            i.set(o, a)),
                            a.add(t)
                        }
                }
                return new vA(t,e,n,i)
            }
            static[mA](t, e) {
                const n = e.threeGLTF
                  , i = e.gltf
                  , r = JSON.parse(JSON.stringify(i))
                  , s = new Map
                  , o = new Map;
                for (let i = 0; i < n.scenes.length; i++)
                    this[AA](n.scenes[i], t.scenes[i], ((t,n)=>{
                        const i = e.threeObjectMap.get(t);
                        if (null != i)
                            for (const t in i)
                                if (null != t && "primitives" !== t) {
                                    const e = t
                                      , a = i[e]
                                      , l = r[e][a]
                                      , c = s.get(n) || {};
                                    c[e] = a,
                                    s.set(n, c);
                                    const u = o.get(l) || new Set;
                                    u.add(n),
                                    o.set(l, u)
                                }
                    }
                    ));
                return new vA(t,r,s,o)
            }
            static[AA](t, e, n) {
                const i = (t,e)=>{
                    if (n(t, e),
                    t.isObject3D) {
                        const r = t
                          , s = e;
                        if (r.material)
                            if (Array.isArray(r.material))
                                for (let t = 0; t < r.material.length; ++t)
                                    n(r.material[t], s.material[t]);
                            else
                                n(r.material, s.material);
                        for (let n = 0; n < t.children.length; ++n)
                            i(t.children[n], e.children[n])
                    }
                }
                ;
                i(t, e)
            }
            get threeGLTF() {
                return this[hA]
            }
            get gltf() {
                return this[dA]
            }
            get gltfElementMap() {
                return this[pA]
            }
            get threeObjectMap() {
                return this[fA]
            }
        }
        const yA = Symbol("correlatedSceneGraph");
        class _A extends lA {
            static[sA](t) {
                const e = super[sA](t);
                null == e[yA] && (e[yA] = vA.from(e));
                const {scene: n} = e
                  , i = new Le(void 0,1 / 0);
                return n.traverse((t=>{
                    t.renderOrder = 1e3,
                    t.frustumCulled = !1,
                    t.name || (t.name = t.uuid);
                    const n = t;
                    if (n.material) {
                        const {geometry: t} = n;
                        n.castShadow = !0,
                        n.isSkinnedMesh && (t.boundingSphere = i,
                        t.boundingBox = null);
                        const r = n.material;
                        if (!0 === r.isMeshBasicMaterial && (r.toneMapped = !1),
                        r.shadowSide = 0,
                        r.aoMap) {
                            const {gltf: n, threeObjectMap: i} = e[yA]
                              , s = i.get(r);
                            if (null != n.materials && null != s && null != s.materials) {
                                const e = n.materials[s.materials];
                                e.occlusionTexture && 0 === e.occlusionTexture.texCoord && null != t.attributes.uv && t.setAttribute("uv2", t.attributes.uv)
                            }
                        }
                    }
                }
                )),
                e
            }
            get correlatedSceneGraph() {
                return this[oA][yA]
            }
            [aA]() {
                const t = super[aA]()
                  , e = new Map;
                return t.scene.traverse((t=>{
                    const n = t;
                    if (n.material) {
                        const t = n.material;
                        if (null != t) {
                            if (e.has(t.uuid))
                                return void (n.material = e.get(t.uuid));
                            n.material = t.clone(),
                            e.set(t.uuid, n.material)
                        }
                    }
                    const i = t;
                    void 0 !== i.target && i.add(i.target)
                }
                )),
                t[yA] = vA.from(t, this.correlatedSceneGraph),
                t
            }
        }
        class EA extends Fa {
            constructor(t) {
                super(t),
                this.type = U
            }
            parse(t) {
                const e = function(t, e) {
                    switch (t) {
                    case 1:
                        throw new Error("THREE.RGBELoader: Read Error: " + (e || ""));
                    case 2:
                        throw new Error("THREE.RGBELoader: Write Error: " + (e || ""));
                    case 3:
                        throw new Error("THREE.RGBELoader: Bad File Format: " + (e || ""));
                    default:
                        throw new Error("THREE.RGBELoader: Memory Error: " + (e || ""))
                    }
                }
                  , n = function(t, e, n) {
                    e = e || 1024;
                    let i = t.pos
                      , r = -1
                      , s = 0
                      , o = ""
                      , a = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                    for (; 0 > (r = a.indexOf("\n")) && s < e && i < t.byteLength; )
                        o += a,
                        s += a.length,
                        i += 128,
                        a += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                    return -1 < r && (!1 !== n && (t.pos += s + r + 1),
                    o + a.slice(0, r))
                }
                  , i = function(t, e, n, i) {
                    const r = t[e + 3]
                      , s = Math.pow(2, r - 128) / 255;
                    n[i + 0] = t[e + 0] * s,
                    n[i + 1] = t[e + 1] * s,
                    n[i + 2] = t[e + 2] * s,
                    n[i + 3] = 1
                }
                  , r = function(t, e, n, i) {
                    const r = t[e + 3]
                      , s = Math.pow(2, r - 128) / 255;
                    n[i + 0] = On(Math.min(t[e + 0] * s, 65504)),
                    n[i + 1] = On(Math.min(t[e + 1] * s, 65504)),
                    n[i + 2] = On(Math.min(t[e + 2] * s, 65504)),
                    n[i + 3] = On(1)
                }
                  , s = new Uint8Array(t);
                s.pos = 0;
                const o = function(t) {
                    const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
                      , r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
                      , s = /^\s*FORMAT=(\S+)\s*$/
                      , o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
                      , a = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                    let l, c;
                    for ((t.pos >= t.byteLength || !(l = n(t))) && e(1, "no header found"),
                    (c = l.match(/^#\?(\S+)/)) || e(3, "bad initial token"),
                    a.valid |= 1,
                    a.programtype = c[1],
                    a.string += l + "\n"; l = n(t),
                    !1 !== l; )
                        if (a.string += l + "\n",
                        "#" !== l.charAt(0)) {
                            if ((c = l.match(i)) && (a.gamma = parseFloat(c[1])),
                            (c = l.match(r)) && (a.exposure = parseFloat(c[1])),
                            (c = l.match(s)) && (a.valid |= 2,
                            a.format = c[1]),
                            (c = l.match(o)) && (a.valid |= 4,
                            a.height = parseInt(c[1], 10),
                            a.width = parseInt(c[2], 10)),
                            2 & a.valid && 4 & a.valid)
                                break
                        } else
                            a.comments += l + "\n";
                    return 2 & a.valid || e(3, "missing format specifier"),
                    4 & a.valid || e(3, "missing image size specifier"),
                    a
                }(s)
                  , a = o.width
                  , l = o.height
                  , c = function(t, n, i) {
                    const r = n;
                    if (r < 8 || r > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2])
                        return new Uint8Array(t);
                    r !== (t[2] << 8 | t[3]) && e(3, "wrong scanline width");
                    const s = new Uint8Array(4 * n * i);
                    s.length || e(4, "unable to allocate buffer space");
                    let o = 0
                      , a = 0;
                    const l = 4 * r
                      , c = new Uint8Array(4)
                      , u = new Uint8Array(l);
                    let h = i;
                    for (; h > 0 && a < t.byteLength; ) {
                        a + 4 > t.byteLength && e(1),
                        c[0] = t[a++],
                        c[1] = t[a++],
                        c[2] = t[a++],
                        c[3] = t[a++],
                        2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == r || e(3, "bad rgbe scanline format");
                        let n, i = 0;
                        for (; i < l && a < t.byteLength; ) {
                            n = t[a++];
                            const r = n > 128;
                            if (r && (n -= 128),
                            (0 === n || i + n > l) && e(3, "bad scanline data"),
                            r) {
                                const e = t[a++];
                                for (let t = 0; t < n; t++)
                                    u[i++] = e
                            } else
                                u.set(t.subarray(a, a + n), i),
                                i += n,
                                a += n
                        }
                        const d = r;
                        for (let t = 0; t < d; t++) {
                            let e = 0;
                            s[o] = u[t + e],
                            e += r,
                            s[o + 1] = u[t + e],
                            e += r,
                            s[o + 2] = u[t + e],
                            e += r,
                            s[o + 3] = u[t + e],
                            o += 4
                        }
                        h--
                    }
                    return s
                }(s.subarray(s.pos), a, l);
                let u, h, d;
                switch (this.type) {
                case P:
                    d = c.length / 4;
                    const t = new Float32Array(4 * d);
                    for (let e = 0; e < d; e++)
                        i(c, 4 * e, t, 4 * e);
                    u = t,
                    h = P;
                    break;
                case U:
                    d = c.length / 4;
                    const e = new Uint16Array(4 * d);
                    for (let t = 0; t < d; t++)
                        r(c, 4 * t, e, 4 * t);
                    u = e,
                    h = U;
                    break;
                default:
                    throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                }
                return {
                    width: a,
                    height: l,
                    data: u,
                    header: o.string,
                    gamma: o.gamma,
                    exposure: o.exposure,
                    type: h
                }
            }
            setDataType(t) {
                return this.type = t,
                this
            }
            load(t, e, n, i) {
                return super.load(t, (function(t, n) {
                    switch (t.type) {
                    case P:
                    case U:
                        t.colorSpace = ct,
                        t.minFilter = I,
                        t.magFilter = I,
                        t.generateMipmaps = !1,
                        t.flipY = !0
                    }
                    e && e(t, n)
                }
                ), n, i)
            }
        }
        class bA extends fo {
            constructor() {
                super(),
                this.position.y = -3.5;
                const t = new gi;
                t.deleteAttribute("uv");
                const e = new ha({
                    metalness: 0,
                    side: 1
                })
                  , n = new ha({
                    metalness: 0
                })
                  , i = new Ja(16777215,500,28,2);
                i.position.set(.418, 16.199, .3),
                this.add(i);
                const r = new fi(t,e);
                r.position.set(-.757, 13.219, .717),
                r.scale.set(31.713, 28.305, 28.591),
                this.add(r);
                const s = new fi(t,n);
                s.position.set(-10.906, 2.009, 1.846),
                s.rotation.set(0, -.195, 0),
                s.scale.set(2.328, 7.905, 4.651),
                this.add(s);
                const o = new fi(t,n);
                o.position.set(-5.607, -.754, -.758),
                o.rotation.set(0, .994, 0),
                o.scale.set(1.97, 1.534, 3.955),
                this.add(o);
                const a = new fi(t,n);
                a.position.set(6.167, .857, 7.803),
                a.rotation.set(0, .561, 0),
                a.scale.set(3.927, 6.285, 3.687),
                this.add(a);
                const l = new fi(t,n);
                l.position.set(-2.017, .018, 6.124),
                l.rotation.set(0, .333, 0),
                l.scale.set(2.002, 4.566, 2.064),
                this.add(l);
                const c = new fi(t,n);
                c.position.set(2.291, -.756, -2.621),
                c.rotation.set(0, -.286, 0),
                c.scale.set(1.546, 1.552, 1.496),
                this.add(c);
                const u = new fi(t,n);
                u.position.set(-2.193, -.369, -5.547),
                u.rotation.set(0, .516, 0),
                u.scale.set(3.875, 3.487, 2.986),
                this.add(u);
                const h = new fi(t,this.createAreaLightMaterial(50));
                h.position.set(-16.116, 14.37, 8.208),
                h.scale.set(.1, 2.428, 2.739),
                this.add(h);
                const d = new fi(t,this.createAreaLightMaterial(50));
                d.position.set(-16.109, 18.021, -8.207),
                d.scale.set(.1, 2.425, 2.751),
                this.add(d);
                const p = new fi(t,this.createAreaLightMaterial(17));
                p.position.set(14.904, 12.198, -1.832),
                p.scale.set(.15, 4.265, 6.331),
                this.add(p);
                const f = new fi(t,this.createAreaLightMaterial(43));
                f.position.set(-.462, 8.89, 14.52),
                f.scale.set(4.38, 5.441, .088),
                this.add(f);
                const A = new fi(t,this.createAreaLightMaterial(20));
                A.position.set(3.235, 11.486, -12.541),
                A.scale.set(2.5, 2, .1),
                this.add(A);
                const g = new fi(t,this.createAreaLightMaterial(100));
                g.position.set(0, 20, 0),
                g.scale.set(1, .1, 1),
                this.add(g)
            }
            createAreaLightMaterial(t) {
                const e = new Pn;
                return e.color.setScalar(t),
                e
            }
        }
        class xA extends fo {
            constructor() {
                super(),
                this.position.y = -3.5;
                const t = new gi;
                t.deleteAttribute("uv");
                const e = new ha({
                    metalness: 0,
                    side: 1
                })
                  , n = new ha({
                    metalness: 0
                })
                  , i = new Ja(16777215,400,28,2);
                i.position.set(.5, 14, .5),
                this.add(i);
                const r = new fi(t,e);
                r.position.set(0, 13.2, 0),
                r.scale.set(31.5, 28.5, 31.5),
                this.add(r);
                const s = new fi(t,n);
                s.position.set(-10.906, -1, 1.846),
                s.rotation.set(0, -.195, 0),
                s.scale.set(2.328, 7.905, 4.651),
                this.add(s);
                const o = new fi(t,n);
                o.position.set(-5.607, -.754, -.758),
                o.rotation.set(0, .994, 0),
                o.scale.set(1.97, 1.534, 3.955),
                this.add(o);
                const a = new fi(t,n);
                a.position.set(6.167, -.16, 7.803),
                a.rotation.set(0, .561, 0),
                a.scale.set(3.927, 6.285, 3.687),
                this.add(a);
                const l = new fi(t,n);
                l.position.set(-2.017, .018, 6.124),
                l.rotation.set(0, .333, 0),
                l.scale.set(2.002, 4.566, 2.064),
                this.add(l);
                const c = new fi(t,n);
                c.position.set(2.291, -.756, -2.621),
                c.rotation.set(0, -.286, 0),
                c.scale.set(1.546, 1.552, 1.496),
                this.add(c);
                const u = new fi(t,n);
                u.position.set(-2.193, -.369, -5.547),
                u.rotation.set(0, .516, 0),
                u.scale.set(3.875, 3.487, 2.986),
                this.add(u);
                const h = new fi(t,this.createAreaLightMaterial(80));
                h.position.set(-14, 10, 8),
                h.scale.set(.1, 2.5, 2.5),
                this.add(h);
                const d = new fi(t,this.createAreaLightMaterial(80));
                d.position.set(-14, 14, -4),
                d.scale.set(.1, 2.5, 2.5),
                this.add(d);
                const p = new fi(t,this.createAreaLightMaterial(23));
                p.position.set(14, 12, 0),
                p.scale.set(.1, 5, 5),
                this.add(p);
                const f = new fi(t,this.createAreaLightMaterial(16));
                f.position.set(0, 9, 14),
                f.scale.set(5, 5, .1),
                this.add(f);
                const A = new fi(t,this.createAreaLightMaterial(80));
                A.position.set(7, 8, -14),
                A.scale.set(2.5, 2.5, .1),
                this.add(A);
                const g = new fi(t,this.createAreaLightMaterial(80));
                g.position.set(-7, 16, -14),
                g.scale.set(2.5, 2.5, .1),
                this.add(g);
                const m = new fi(t,this.createAreaLightMaterial(1));
                m.position.set(0, 20, 0),
                m.scale.set(.1, .1, .1),
                this.add(m)
            }
            createAreaLightMaterial(t) {
                const e = new Pn;
                return e.color.setScalar(t),
                e
            }
        }
        const wA = /\.hdr(\.js)?$/;
        class SA {
            constructor(t) {
                this.threeRenderer = t,
                this.lottieLoaderUrl = "",
                this.withCredentials = !1,
                this._ldrLoader = null,
                this._hdrLoader = null,
                this._lottieLoader = null,
                this.generatedEnvironmentMap = null,
                this.generatedEnvironmentMapAlt = null,
                this.skyboxCache = new Map,
                this.blurMaterial = null,
                this.blurScene = null
            }
            get ldrLoader() {
                return null == this._ldrLoader && (this._ldrLoader = new Qa),
                this._ldrLoader.setWithCredentials(this.withCredentials),
                this._ldrLoader
            }
            get hdrLoader() {
                return null == this._hdrLoader && (this._hdrLoader = new EA,
                this._hdrLoader.setDataType(U)),
                this._hdrLoader.setWithCredentials(this.withCredentials),
                this._hdrLoader
            }
            async getLottieLoader() {
                if (null == this._lottieLoader) {
                    const {LottieLoader: t} = await n(7340)(this.lottieLoaderUrl);
                    this._lottieLoader = new t
                }
                return this._lottieLoader.setWithCredentials(this.withCredentials),
                this._lottieLoader
            }
            async loadImage(t) {
                const e = await new Promise(((e,n)=>this.ldrLoader.load(t, e, (()=>{}
                ), n)));
                return e.name = t,
                e.flipY = !1,
                e
            }
            async loadLottie(t, e) {
                const n = await this.getLottieLoader();
                n.setQuality(e);
                const i = await new Promise(((e,i)=>n.load(t, e, (()=>{}
                ), i)));
                return i.name = t,
                i
            }
            async loadEquirect(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ()=>{}
                ;
                try {
                    const n = wA.test(t)
                      , i = n ? this.hdrLoader : this.ldrLoader
                      , r = await new Promise(((n,r)=>i.load(t, n, (t=>{
                        e(t.loaded / t.total * .9)
                    }
                    ), r)));
                    return e(1),
                    r.name = t,
                    r.mapping = _,
                    n || (r.colorSpace = lt),
                    r
                } finally {
                    e && e(1)
                }
            }
            async generateEnvironmentMapAndSkybox() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ()=>{}
                ;
                const i = "legacy" !== e;
                "legacy" !== e && "neutral" !== e || (e = null),
                e = Zc(e);
                let r, s = Promise.resolve(null);
                t && (s = this.loadEquirectFromUrl(t, n)),
                r = e ? this.loadEquirectFromUrl(e, n) : t ? this.loadEquirectFromUrl(t, n) : i ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
                const [o,a] = await Promise.all([r, s]);
                if (null == o)
                    throw new Error("Failed to load environment map.");
                return {
                    environmentMap: o,
                    skybox: a
                }
            }
            async loadEquirectFromUrl(t, e) {
                if (!this.skyboxCache.has(t)) {
                    const n = this.loadEquirect(t, e);
                    this.skyboxCache.set(t, n)
                }
                return this.skyboxCache.get(t)
            }
            async GenerateEnvironmentMap(t, e) {
                await function() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    return new Promise((e=>setTimeout(e, t)))
                }();
                const n = this.threeRenderer
                  , i = new Mi(256,{
                    generateMipmaps: !1,
                    type: U,
                    format: N,
                    colorSpace: ct,
                    depthBuffer: !0
                })
                  , r = new Si(.1,100,i)
                  , s = r.renderTarget.texture;
                s.name = e;
                const o = n.outputColorSpace
                  , a = n.toneMapping;
                return n.toneMapping = d,
                n.outputColorSpace = ct,
                r.update(n, t),
                this.blurCubemap(i, .04),
                n.toneMapping = a,
                n.outputColorSpace = o,
                s
            }
            async loadGeneratedEnvironmentMap() {
                return null == this.generatedEnvironmentMap && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new bA, "legacy")),
                this.generatedEnvironmentMap
            }
            async loadGeneratedEnvironmentMapAlt() {
                return null == this.generatedEnvironmentMapAlt && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new xA, "neutral")),
                this.generatedEnvironmentMapAlt
            }
            blurCubemap(t, e) {
                if (null == this.blurMaterial) {
                    this.blurMaterial = this.getBlurShader(20);
                    const t = new gi
                      , e = new fi(t,this.blurMaterial);
                    this.blurScene = new fo,
                    this.blurScene.add(e)
                }
                const n = t.clone();
                this.halfblur(t, n, e, "latitudinal"),
                this.halfblur(n, t, e, "longitudinal")
            }
            halfblur(t, e, n, i) {
                const r = t.width
                  , s = isFinite(n) ? Math.PI / (2 * r) : 2 * Math.PI / 39
                  , o = n / s
                  , a = isFinite(n) ? 1 + Math.floor(3 * o) : 20;
                a > 20 && console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${a} samples when the maximum is set to 20`);
                const l = [];
                let c = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / o
                      , n = Math.exp(-e * e / 2);
                    l.push(n),
                    0 == t ? c += n : t < a && (c += 2 * n)
                }
                for (let t = 0; t < l.length; t++)
                    l[t] = l[t] / c;
                const u = this.blurMaterial.uniforms;
                u.envMap.value = t.texture,
                u.samples.value = a,
                u.weights.value = l,
                u.latitudinal.value = "latitudinal" === i,
                u.dTheta.value = s,
                new Si(.1,100,e).update(this.threeRenderer, this.blurScene)
            }
            getBlurShader(t) {
                const e = new Float32Array(t)
                  , n = new he(0,1,0);
                return new Ei({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: t
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: e
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        poleAxis: {
                            value: n
                        }
                    },
                    vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ",
                    fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    side: 1
                })
            }
            async dispose() {
                for (const [,t] of this.skyboxCache)
                    (await t).dispose();
                null != this.generatedEnvironmentMap && ((await this.generatedEnvironmentMap).dispose(),
                this.generatedEnvironmentMap = null),
                null != this.generatedEnvironmentMapAlt && ((await this.generatedEnvironmentMapAlt).dispose(),
                this.generatedEnvironmentMapAlt = null),
                null != this.blurMaterial && this.blurMaterial.dispose()
            }
        }
        const CA = [1, .79, .62, .5, .4, .31, .25]
          , MA = "high-performance";
        class IA extends bt {
            constructor(t) {
                super(),
                this.loader = new Yh(_A),
                this.width = 0,
                this.height = 0,
                this.dpr = 1,
                this.scenes = new Set,
                this.multipleScenesVisible = !1,
                this.lastTick = performance.now(),
                this.renderedLastFrame = !1,
                this.scaleStep = 0,
                this.lastStep = 3,
                this.avgFrameDuration = 50,
                this.onWebGLContextLost = t=>{
                    this.dispatchEvent({
                        type: "contextlost",
                        sourceEvent: t
                    })
                }
                ,
                this.onWebGLContextRestored = ()=>{
                    var t;
                    null === (t = this.textureUtils) || void 0 === t || t.dispose(),
                    this.textureUtils = new SA(this.threeRenderer);
                    for (const t of this.scenes)
                        t.element[uu]()
                }
                ,
                this.dpr = ru(),
                this.canvas3D = document.createElement("canvas"),
                this.canvas3D.id = "webgl-canvas",
                this.canvas3D.classList.add("show"),
                Fi.tonemapping_pars_fragment = Fi.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n      float startCompression = 0.8;\n      float desaturation = 0.5;\n      vec3 CustomToneMapping( vec3 color ) {\n        color *= toneMappingExposure;\n        \n        float d = 1. - startCompression;\n\n        float peak = max(color.r, max(color.g, color.b));\n        if (peak < startCompression) return color;\n\n        float newPeak = 1. - d * d / (peak + d - startCompression);\n        float invPeak = 1. / peak;\n        \n        float extraBrightness = dot(color * (1. - startCompression * invPeak), vec3(1, 1, 1));\n        \n        color *= newPeak * invPeak;\n        float g = 1. - 3. / (desaturation * extraBrightness + 3.);\n        return mix(color, vec3(1, 1, 1), g);\n      }");
                try {
                    this.threeRenderer = new po({
                        canvas: this.canvas3D,
                        alpha: !0,
                        antialias: !0,
                        powerPreference: t.powerPreference,
                        preserveDrawingBuffer: !0
                    }),
                    this.threeRenderer.autoClear = !0,
                    this.threeRenderer.setPixelRatio(1),
                    this.threeRenderer.debug = {
                        checkShaderErrors: !!t.debug,
                        onShaderError: null
                    },
                    this.threeRenderer.toneMapping = g
                } catch (t) {
                    console.warn(t)
                }
                this.arRenderer = new eA(this),
                this.textureUtils = this.canRender ? new SA(this.threeRenderer) : null,
                Yh.initializeKTX2Loader(this.threeRenderer),
                this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost),
                this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored),
                this.updateRendererSize()
            }
            static get singleton() {
                return this._singleton
            }
            static resetSingleton() {
                const t = this._singleton.dispose();
                for (const e of t)
                    e.disconnectedCallback();
                this._singleton = new IA({
                    powerPreference: (self.ModelViewerElement || {}).powerPreference || MA,
                    debug: su()
                });
                for (const e of t)
                    e.connectedCallback()
            }
            get canRender() {
                return null != this.threeRenderer
            }
            get scaleFactor() {
                return CA[this.scaleStep]
            }
            set minScale(t) {
                let e = 1;
                for (; e < CA.length && !(CA[e] < t); )
                    ++e;
                this.lastStep = e - 1
            }
            registerScene(t) {
                this.scenes.add(t),
                t.forceRescale();
                const e = new Nt;
                this.threeRenderer.getSize(e),
                t.canvas.width = e.x,
                t.canvas.height = e.y,
                this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop(((t,e)=>this.render(t, e)))
            }
            unregisterScene(t) {
                this.scenes.delete(t),
                this.canvas3D.parentElement === t.canvas.parentElement && t.canvas.parentElement.removeChild(this.canvas3D),
                this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null)
            }
            displayCanvas(t) {
                return this.multipleScenesVisible ? t.element[Av] : this.canvas3D
            }
            countVisibleScenes() {
                const {canvas3D: t} = this;
                let e = 0
                  , n = null;
                for (const i of this.scenes) {
                    const {element: r} = i;
                    r.modelIsVisible && null == i.externalRenderer && ++e,
                    t.parentElement === i.canvas.parentElement && (n = i)
                }
                const i = e > 1;
                if (null != n) {
                    const e = i && !this.multipleScenesVisible
                      , r = !n.element.modelIsVisible;
                    if (e || r) {
                        const {width: e, height: i} = this.sceneSize(n);
                        this.copyPixels(n, e, i),
                        t.parentElement.removeChild(t)
                    }
                }
                this.multipleScenesVisible = i
            }
            updateRendererSize() {
                var t;
                const e = ru();
                if (e !== this.dpr)
                    for (const t of this.scenes) {
                        const {element: e} = t;
                        e[nv](e.getBoundingClientRect())
                    }
                let n = 0
                  , i = 0;
                for (const t of this.scenes)
                    n = Math.max(n, t.width),
                    i = Math.max(i, t.height);
                if (n !== this.width || i !== this.height || e !== this.dpr) {
                    this.width = n,
                    this.height = i,
                    this.dpr = e,
                    n = Math.ceil(n * e),
                    i = Math.ceil(i * e),
                    this.canRender && this.threeRenderer.setSize(n, i, !1);
                    for (const e of this.scenes) {
                        const {canvas: r} = e;
                        r.width = n,
                        r.height = i,
                        e.forceRescale(),
                        null === (t = e.effectRenderer) || void 0 === t || t.setSize(n, i)
                    }
                }
            }
            updateRendererScale(t) {
                const e = this.scaleStep;
                this.avgFrameDuration += iu(.2 * (t - this.avgFrameDuration), -5, 5),
                this.avgFrameDuration > 60 ? ++this.scaleStep : this.avgFrameDuration < 40 && this.scaleStep > 0 && --this.scaleStep,
                this.scaleStep = Math.min(this.scaleStep, this.lastStep),
                e !== this.scaleStep && (this.avgFrameDuration = 50)
            }
            shouldRender(t) {
                if (t.shouldRender())
                    t.scaleStep != this.scaleStep && (t.scaleStep = this.scaleStep,
                    this.rescaleCanvas(t));
                else {
                    if (0 == t.scaleStep)
                        return !1;
                    t.scaleStep = 0,
                    this.rescaleCanvas(t)
                }
                return !0
            }
            rescaleCanvas(t) {
                const e = CA[t.scaleStep]
                  , n = Math.ceil(this.width / e)
                  , i = Math.ceil(this.height / e)
                  , {style: r} = t.canvas;
                r.width = `${n}px`,
                r.height = `${i}px`,
                this.canvas3D.style.width = `${n}px`,
                this.canvas3D.style.height = `${i}px`;
                const s = this.dpr * e
                  , o = e < 1 ? "GPU throttling" : this.dpr !== window.devicePixelRatio ? "No meta viewport tag" : "";
                t.element.dispatchEvent(new CustomEvent("render-scale",{
                    detail: {
                        reportedDpr: window.devicePixelRatio,
                        renderedDpr: s,
                        minimumDpr: this.dpr * CA[this.lastStep],
                        pixelWidth: Math.ceil(t.width * s),
                        pixelHeight: Math.ceil(t.height * s),
                        reason: o
                    }
                }))
            }
            sceneSize(t) {
                const {dpr: e} = this
                  , n = CA[t.scaleStep];
                return {
                    width: Math.min(Math.ceil(t.width * n * e), this.canvas3D.width),
                    height: Math.min(Math.ceil(t.height * n * e), this.canvas3D.height)
                }
            }
            copyPixels(t, e, n) {
                const i = t.context;
                null != i ? (i.clearRect(0, 0, e, n),
                i.drawImage(this.canvas3D, 0, 0, e, n, 0, 0, e, n),
                t.canvas.classList.add("show")) : console.log("could not acquire 2d context")
            }
            orderedScenes() {
                const t = [];
                for (const e of [!1, !0])
                    for (const n of this.scenes)
                        n.element.modelIsVisible === e && t.push(n);
                return t
            }
            get isPresenting() {
                return this.arRenderer.isPresenting
            }
            preRender(t, e, n) {
                const {element: i, exposure: r} = t;
                i[vv](e, n);
                const s = "number" == typeof r && !Number.isNaN(r);
                this.threeRenderer.toneMappingExposure = s ? r : 1
            }
            render(t, e) {
                if (null != e)
                    return void this.arRenderer.onWebXRFrame(t, e);
                const n = t - this.lastTick;
                if (this.lastTick = t,
                !this.canRender || this.isPresenting)
                    return;
                this.countVisibleScenes(),
                this.updateRendererSize(),
                this.renderedLastFrame && (this.updateRendererScale(n),
                this.renderedLastFrame = !1);
                const {canvas3D: i} = this;
                for (const e of this.orderedScenes()) {
                    const {element: r} = e;
                    if (!r.loaded || !r.modelIsVisible && e.renderCount > 0)
                        continue;
                    if (this.preRender(e, t, n),
                    !this.shouldRender(e))
                        continue;
                    if (null != e.externalRenderer) {
                        const t = e.getCamera();
                        t.updateMatrix();
                        const {matrix: n, projectionMatrix: i} = t
                          , r = n.elements.slice()
                          , s = e.getTarget();
                        r[12] += s.x,
                        r[13] += s.y,
                        r[14] += s.z,
                        e.externalRenderer.render({
                            viewMatrix: r,
                            projectionMatrix: i.elements
                        });
                        continue
                    }
                    if (!r.modelIsVisible && !this.multipleScenesVisible)
                        for (const t of this.scenes)
                            t.element.modelIsVisible && t.queueRender();
                    const {width: s, height: o} = this.sceneSize(e);
                    e.renderShadow(this.threeRenderer),
                    this.threeRenderer.setRenderTarget(null),
                    this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - o, s, o),
                    null != e.effectRenderer ? e.effectRenderer.render(n) : (this.threeRenderer.autoClear = !0,
                    this.threeRenderer.toneMapping = "commerce" === e.toneMapping ? m : g,
                    this.threeRenderer.render(e, e.camera)),
                    this.multipleScenesVisible || !e.element.modelIsVisible && 0 === e.renderCount ? this.copyPixels(e, s, o) : i.parentElement !== e.canvas.parentElement && (e.canvas.parentElement.appendChild(i),
                    e.canvas.classList.remove("show")),
                    e.hasRendered(),
                    ++e.renderCount,
                    this.renderedLastFrame = !0
                }
            }
            dispose() {
                null != this.textureUtils && this.textureUtils.dispose(),
                null != this.threeRenderer && this.threeRenderer.dispose(),
                this.textureUtils = null,
                this.threeRenderer = null;
                const t = [];
                for (const e of this.scenes)
                    t.push(e.element);
                return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost),
                this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored),
                t
            }
        }
        IA._singleton = new IA({
            powerPreference: (self.ModelViewerElement || {}).powerPreference || MA,
            debug: su()
        });
        const TA = Symbol("correlatedObjects")
          , BA = Symbol("onUpdate");
        class RA {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                this[BA] = t,
                this[TA] = e
            }
        }
        const LA = new Pn
          , DA = new Ni(2,2);
        let PA = 0;
        const UA = Symbol("threeTexture")
          , OA = Symbol("threeTextures");
        class NA extends RA {
            get[UA]() {
                var t;
                return null === (t = this[TA]) || void 0 === t ? void 0 : t.values().next().value
            }
            get[OA]() {
                return this[TA]
            }
            constructor(t, e) {
                super(t, new Set(e ? [e] : [])),
                this[UA].image.src || (this[UA].image.src = "adhoc_image" + PA++),
                this[UA].image.name || (this[UA].image.name = e && e.image && e.image.src ? e.image.src.split("/").pop() : "adhoc_image")
            }
            get name() {
                return this[UA].image.name || ""
            }
            get uri() {
                return this[UA].image.src
            }
            get bufferView() {
                return this[UA].image.bufferView
            }
            get element() {
                const t = this[UA];
                if (t && (t.isCanvasTexture || t.isVideoTexture))
                    return t.image
            }
            get animation() {
                const t = this[UA];
                if (t && t.isCanvasTexture && t.animation)
                    return t.animation
            }
            get type() {
                return null != this.uri ? "external" : "embedded"
            }
            set name(t) {
                for (const e of this[OA])
                    e.image.name = t
            }
            update() {
                const t = this[UA];
                t && t.isCanvasTexture && !t.animation && (this[UA].needsUpdate = !0,
                this[BA]())
            }
            async createThumbnail(t, e) {
                const n = new fo;
                LA.map = this[UA];
                const i = new fi(DA,LA);
                n.add(i);
                const r = new Xi(-1,1,1,-1,0,1)
                  , {threeRenderer: s} = IA.singleton
                  , o = new ae(t,e);
                s.setRenderTarget(o),
                s.render(n, r),
                s.setRenderTarget(null);
                const a = new Uint8Array(t * e * 4);
                s.readRenderTargetPixels(o, 0, 0, t, e, a),
                qm.width = t,
                qm.height = e;
                const l = qm.getContext("2d")
                  , c = l.createImageData(t, e);
                return c.data.set(a),
                l.putImageData(c, 0, 0),
                new Promise((async(t,e)=>{
                    qm.toBlob((n=>{
                        if (!n)
                            return e("Failed to capture thumbnail.");
                        t(URL.createObjectURL(n))
                    }
                    ), "image/png")
                }
                ))
            }
        }
        var FA, QA;
        !function(t) {
            t[t.Nearest = 9728] = "Nearest",
            t[t.Linear = 9729] = "Linear",
            t[t.NearestMipmapNearest = 9984] = "NearestMipmapNearest",
            t[t.LinearMipmapNearest = 9985] = "LinearMipmapNearest",
            t[t.NearestMipmapLinear = 9986] = "NearestMipmapLinear",
            t[t.LinearMipmapLinear = 9987] = "LinearMipmapLinear"
        }(FA || (FA = {})),
        function(t) {
            t[t.ClampToEdge = 33071] = "ClampToEdge",
            t[t.MirroredRepeat = 33648] = "MirroredRepeat",
            t[t.Repeat = 10497] = "Repeat"
        }(QA || (QA = {}));
        const kA = new Map([[QA.Repeat, b], [QA.ClampToEdge, x], [QA.MirroredRepeat, w]])
          , GA = new Map([[b, QA.Repeat], [x, QA.ClampToEdge], [w, QA.MirroredRepeat]])
          , HA = new Map([[FA.Nearest, S], [FA.Linear, I], [FA.NearestMipmapNearest, C], [FA.LinearMipmapNearest, T], [FA.NearestMipmapLinear, M], [FA.LinearMipmapLinear, B]])
          , zA = new Map([[S, FA.Nearest], [I, FA.Linear], [C, FA.NearestMipmapNearest], [T, FA.LinearMipmapNearest], [M, FA.NearestMipmapLinear], [B, FA.LinearMipmapLinear]])
          , VA = new Map([[FA.Nearest, S], [FA.Linear, I]])
          , WA = new Map([[S, FA.Nearest], [I, FA.Linear]])
          , qA = Symbol("threeTexture")
          , jA = Symbol("threeTextures")
          , XA = Symbol("setProperty");
        class YA extends RA {
            get[qA]() {
                var t;
                return null === (t = this[TA]) || void 0 === t ? void 0 : t.values().next().value
            }
            get[jA]() {
                return this[TA]
            }
            constructor(t, e) {
                super(t, new Set(e ? [e] : []))
            }
            get name() {
                return this[qA].name || ""
            }
            get minFilter() {
                return zA.get(this[qA].minFilter)
            }
            get magFilter() {
                return WA.get(this[qA].magFilter)
            }
            get wrapS() {
                return GA.get(this[qA].wrapS)
            }
            get wrapT() {
                return GA.get(this[qA].wrapT)
            }
            get rotation() {
                return this[qA].rotation
            }
            get scale() {
                return Mv(this[qA].repeat)
            }
            get offset() {
                return Mv(this[qA].offset)
            }
            setMinFilter(t) {
                this[XA]("minFilter", HA.get(t))
            }
            setMagFilter(t) {
                this[XA]("magFilter", VA.get(t))
            }
            setWrapS(t) {
                this[XA]("wrapS", kA.get(t))
            }
            setWrapT(t) {
                this[XA]("wrapT", kA.get(t))
            }
            setRotation(t) {
                null == t && (t = 0),
                this[XA]("rotation", t)
            }
            setScale(t) {
                null == t && (t = {
                    u: 1,
                    v: 1
                }),
                this[XA]("repeat", new Nt(t.u,t.v))
            }
            setOffset(t) {
                null == t && (t = {
                    u: 0,
                    v: 0
                }),
                this[XA]("offset", new Nt(t.u,t.v))
            }
            [XA](t, e) {
                if (((t,e)=>{
                    switch (t) {
                    case "minFilter":
                        return (t=>zA.has(t))(e);
                    case "magFilter":
                        return (t=>WA.has(t))(e);
                    case "wrapS":
                    case "wrapT":
                        return (t=>GA.has(t))(e);
                    case "rotation":
                    case "repeat":
                    case "offset":
                        return !0;
                    default:
                        throw new Error(`Cannot configure property "${t}" on Sampler`)
                    }
                }
                )(t, e))
                    for (const n of this[jA])
                        n[t] = e,
                        n.needsUpdate = !0;
                this[BA]()
            }
        }
        const KA = Symbol("image")
          , JA = Symbol("sampler")
          , $A = Symbol("threeTexture");
        class ZA extends RA {
            constructor(t, e) {
                super(t, new Set(e ? [e] : [])),
                this[JA] = new YA(t,e),
                this[KA] = new NA(t,e)
            }
            get[$A]() {
                var t;
                return null === (t = this[TA]) || void 0 === t ? void 0 : t.values().next().value
            }
            get name() {
                return this[$A].name || ""
            }
            set name(t) {
                for (const e of this[TA])
                    e.name = t
            }
            get sampler() {
                return this[JA]
            }
            get source() {
                return this[KA]
            }
        }
        var tg, eg, ng;
        const ig = Symbol("texture")
          , rg = Symbol("transform")
          , sg = Symbol("materials")
          , og = Symbol("usage")
          , ag = Symbol("onUpdate")
          , lg = Symbol("activeVideo");
        var cg;
        !function(t) {
            t[t.Base = 0] = "Base",
            t[t.MetallicRoughness = 1] = "MetallicRoughness",
            t[t.Normal = 2] = "Normal",
            t[t.Occlusion = 3] = "Occlusion",
            t[t.Emissive = 4] = "Emissive",
            t[t.Clearcoat = 5] = "Clearcoat",
            t[t.ClearcoatRoughness = 6] = "ClearcoatRoughness",
            t[t.ClearcoatNormal = 7] = "ClearcoatNormal",
            t[t.SheenColor = 8] = "SheenColor",
            t[t.SheenRoughness = 9] = "SheenRoughness",
            t[t.Transmission = 10] = "Transmission",
            t[t.Thickness = 11] = "Thickness",
            t[t.Specular = 12] = "Specular",
            t[t.SpecularColor = 13] = "SpecularColor",
            t[t.Iridescence = 14] = "Iridescence",
            t[t.IridescenceThickness = 15] = "IridescenceThickness",
            t[t.Anisotropy = 16] = "Anisotropy"
        }(cg || (cg = {}));
        class ug {
            constructor(t, e, n, i) {
                this[tg] = null,
                this[eg] = {
                    rotation: 0,
                    scale: new Nt(1,1),
                    offset: new Nt(0,0)
                },
                this[ng] = !1,
                n && (this[rg].rotation = n.rotation,
                this[rg].scale.copy(n.repeat),
                this[rg].offset.copy(n.offset),
                this[ig] = new ZA(t,n)),
                this[ag] = t,
                this[sg] = i,
                this[og] = e
            }
            get texture() {
                return this[ig]
            }
            setTexture(t) {
                var e, n;
                const i = null != t ? t.source[UA] : null
                  , r = null === (e = this[ig]) || void 0 === e ? void 0 : e.source[UA];
                if (null != r && r.isVideoTexture ? this[lg] = !1 : (null === (n = this[ig]) || void 0 === n ? void 0 : n.source.animation) && this[ig].source.animation.removeEventListener("enterFrame", this[ag]),
                this[ig] = t,
                null != i && i.isVideoTexture) {
                    const t = i.image;
                    if (this[lg] = !0,
                    null != t.requestVideoFrameCallback) {
                        const e = ()=>{
                            this[lg] && (this[ag](),
                            t.requestVideoFrameCallback(e))
                        }
                        ;
                        t.requestVideoFrameCallback(e)
                    } else {
                        const t = ()=>{
                            this[lg] && (this[ag](),
                            requestAnimationFrame(t))
                        }
                        ;
                        requestAnimationFrame(t)
                    }
                } else
                    null != (null == t ? void 0 : t.source.animation) && t.source.animation.addEventListener("enterFrame", this[ag]);
                let s = lt;
                if (this[sg])
                    for (const t of this[sg]) {
                        switch (this[og]) {
                        case cg.Base:
                            t.map = i;
                            break;
                        case cg.MetallicRoughness:
                            s = ct,
                            t.metalnessMap = i,
                            t.roughnessMap = i;
                            break;
                        case cg.Normal:
                            s = ct,
                            t.normalMap = i;
                            break;
                        case cg.Occlusion:
                            s = ct,
                            t.aoMap = i;
                            break;
                        case cg.Emissive:
                            t.emissiveMap = i;
                            break;
                        case cg.Clearcoat:
                            t.clearcoatMap = i;
                            break;
                        case cg.ClearcoatRoughness:
                            t.clearcoatRoughnessMap = i;
                            break;
                        case cg.ClearcoatNormal:
                            t.clearcoatNormalMap = i;
                            break;
                        case cg.SheenColor:
                            t.sheenColorMap = i;
                            break;
                        case cg.SheenRoughness:
                            t.sheenRoughnessMap = i;
                            break;
                        case cg.Transmission:
                            t.transmissionMap = i;
                            break;
                        case cg.Thickness:
                            t.thicknessMap = i;
                            break;
                        case cg.Specular:
                            t.specularIntensityMap = i;
                            break;
                        case cg.SpecularColor:
                            t.specularColorMap = i;
                            break;
                        case cg.Iridescence:
                            t.iridescenceMap = i;
                            break;
                        case cg.IridescenceThickness:
                            t.iridescenceThicknessMap = i;
                            break;
                        case cg.Anisotropy:
                            t.anisotropyMap = i
                        }
                        t.needsUpdate = !0
                    }
                i && (i.colorSpace = s,
                i.rotation = this[rg].rotation,
                i.repeat = this[rg].scale,
                i.offset = this[rg].offset),
                this[ag]()
            }
        }
        tg = ig,
        eg = rg,
        ng = lg;
        const hg = Symbol("threeMaterial")
          , dg = Symbol("threeMaterials")
          , pg = Symbol("baseColorTexture")
          , fg = Symbol("metallicRoughnessTexture");
        class Ag extends RA {
            constructor(t, e) {
                super(t, e);
                const {map: n, metalnessMap: i} = e.values().next().value;
                this[pg] = new ug(t,cg.Base,n,e),
                this[fg] = new ug(t,cg.MetallicRoughness,i,e)
            }
            get[dg]() {
                return this[TA]
            }
            get[hg]() {
                var t;
                return null === (t = this[TA]) || void 0 === t ? void 0 : t.values().next().value
            }
            get baseColorFactor() {
                const t = [0, 0, 0, this[hg].opacity];
                return this[hg].color.toArray(t),
                t
            }
            get metallicFactor() {
                return this[hg].metalness
            }
            get roughnessFactor() {
                return this[hg].roughness
            }
            get baseColorTexture() {
                return this[pg]
            }
            get metallicRoughnessTexture() {
                return this[fg]
            }
            setBaseColorFactor(t) {
                const e = new Ln;
                t instanceof Array ? e.fromArray(t) : e.set(t);
                for (const n of this[dg])
                    n.color.set(e),
                    t instanceof Array ? n.opacity = t[3] : (t = [0, 0, 0, n.opacity],
                    e.toArray(t));
                this[BA]()
            }
            setMetallicFactor(t) {
                for (const e of this[dg])
                    e.metalness = t;
                this[BA]()
            }
            setRoughnessFactor(t) {
                for (const e of this[dg])
                    e.roughness = t;
                this[BA]()
            }
        }
        var gg, mg;
        const vg = Symbol("pbrMetallicRoughness")
          , yg = Symbol("normalTexture")
          , _g = Symbol("occlusionTexture")
          , Eg = Symbol("emissiveTexture")
          , bg = Symbol("backingThreeMaterial")
          , xg = Symbol("applyAlphaCutoff")
          , wg = Symbol("getAlphaMode")
          , Sg = Symbol("lazyLoadGLTFInfo")
          , Cg = Symbol("initialize")
          , Mg = Symbol("getLoadedMaterial")
          , Ig = Symbol("ensureMaterialIsLoaded")
          , Tg = Symbol("gltfIndex")
          , Bg = Symbol("setActive")
          , Rg = Symbol("variantIndices")
          , Lg = Symbol("isActive")
          , Dg = Symbol("variantSet")
          , Pg = Symbol("modelVariants")
          , Ug = Symbol("name")
          , Og = Symbol("pbrTextures");
        class Ng extends RA {
            constructor(t, e, n, i, r, s) {
                let o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : void 0;
                super(t, r),
                this[gg] = new Set,
                this[mg] = new Map,
                this[Tg] = e,
                this[Lg] = n,
                this[Pg] = i,
                this[Ug] = s,
                null == o ? this[Cg]() : this[Sg] = o
            }
            get[(gg = Dg,
            mg = Og,
            bg)]() {
                return this[TA].values().next().value
            }
            [Cg]() {
                const t = this[BA]
                  , e = this[TA];
                this[vg] = new Ag(t,e);
                const {normalMap: n, aoMap: i, emissiveMap: r} = e.values().next().value;
                this[yg] = new ug(t,cg.Normal,n,e),
                this[_g] = new ug(t,cg.Occlusion,i,e),
                this[Eg] = new ug(t,cg.Emissive,r,e);
                const s = n=>{
                    this[Og].set(n, new ug(t,n,null,e))
                }
                ;
                s(cg.Clearcoat),
                s(cg.ClearcoatRoughness),
                s(cg.ClearcoatNormal),
                s(cg.SheenColor),
                s(cg.SheenRoughness),
                s(cg.Transmission),
                s(cg.Thickness),
                s(cg.Specular),
                s(cg.SpecularColor),
                s(cg.Iridescence),
                s(cg.IridescenceThickness),
                s(cg.Anisotropy)
            }
            async[Mg]() {
                if (null != this[Sg]) {
                    const {set: t, material: e} = await this[Sg].doLazyLoad();
                    return this[TA] = t,
                    this[Cg](),
                    this[Sg] = void 0,
                    this.ensureLoaded = async()=>{}
                    ,
                    e
                }
                return this[TA].values().next().value
            }
            colorFromRgb(t) {
                const e = new Ln;
                return t instanceof Array ? e.fromArray(t) : e.set(t),
                e
            }
            [Ig]() {
                if (null != this[Sg])
                    throw new Error(`Material "${this.name}" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`)
            }
            async ensureLoaded() {
                await this[Mg]()
            }
            get isLoaded() {
                return null == this[Sg]
            }
            get isActive() {
                return this[Lg]
            }
            [Bg](t) {
                this[Lg] = t
            }
            get name() {
                return this[Ug] || ""
            }
            set name(t) {
                if (this[Ug] = t,
                null != this[TA])
                    for (const e of this[TA])
                        e.name = t
            }
            get pbrMetallicRoughness() {
                return this[Ig](),
                this[vg]
            }
            get normalTexture() {
                return this[Ig](),
                this[yg]
            }
            get occlusionTexture() {
                return this[Ig](),
                this[_g]
            }
            get emissiveTexture() {
                return this[Ig](),
                this[Eg]
            }
            get emissiveFactor() {
                return this[Ig](),
                this[bg].emissive.toArray()
            }
            get index() {
                return this[Tg]
            }
            [Rg]() {
                return this[Dg]
            }
            hasVariant(t) {
                const e = this[Pg].get(t);
                return null != e && this[Dg].has(e.index)
            }
            setEmissiveFactor(t) {
                this[Ig]();
                const e = this.colorFromRgb(t);
                for (const t of this[TA])
                    t.emissive.set(e);
                this[BA]()
            }
            [wg]() {
                return this[bg].transparent ? "BLEND" : this[bg].alphaTest > 0 ? "MASK" : "OPAQUE"
            }
            [xg]() {
                this[Ig]();
                for (const t of this[TA])
                    "MASK" === this[wg]() ? null == t.alphaTest && (t.alphaTest = .5) : t.alphaTest = void 0,
                    t.needsUpdate = !0
            }
            setAlphaCutoff(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.alphaTest = t,
                    e.needsUpdate = !0;
                this[xg](),
                this[BA]()
            }
            getAlphaCutoff() {
                return this[Ig](),
                this[bg].alphaTest
            }
            setDoubleSided(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.side = t ? 2 : 0,
                    e.needsUpdate = !0;
                this[BA]()
            }
            getDoubleSided() {
                return this[Ig](),
                2 == this[bg].side
            }
            setAlphaMode(t) {
                this[Ig]();
                const e = (t,e)=>{
                    t.transparent = e,
                    t.depthWrite = !e
                }
                ;
                for (const n of this[TA])
                    e(n, "BLEND" === t),
                    n.alphaTest = "MASK" === t ? .5 : void 0,
                    n.needsUpdate = !0;
                this[BA]()
            }
            getAlphaMode() {
                return this[Ig](),
                this[wg]()
            }
            get emissiveStrength() {
                return this[Ig](),
                this[bg].emissiveIntensity
            }
            setEmissiveStrength(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.emissiveIntensity = t;
                this[BA]()
            }
            get clearcoatFactor() {
                return this[Ig](),
                this[bg].clearcoat
            }
            get clearcoatRoughnessFactor() {
                return this[Ig](),
                this[bg].clearcoatRoughness
            }
            get clearcoatTexture() {
                return this[Ig](),
                this[Og].get(cg.Clearcoat)
            }
            get clearcoatRoughnessTexture() {
                return this[Ig](),
                this[Og].get(cg.ClearcoatRoughness)
            }
            get clearcoatNormalTexture() {
                return this[Ig](),
                this[Og].get(cg.ClearcoatNormal)
            }
            get clearcoatNormalScale() {
                return this[Ig](),
                this[bg].clearcoatNormalScale.x
            }
            setClearcoatFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.clearcoat = t;
                this[BA]()
            }
            setClearcoatRoughnessFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.clearcoatRoughness = t;
                this[BA]()
            }
            setClearcoatNormalScale(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.clearcoatNormalScale = new Nt(t,t);
                this[BA]()
            }
            get ior() {
                return this[Ig](),
                this[bg].ior
            }
            setIor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.ior = t;
                this[BA]()
            }
            get sheenColorFactor() {
                return this[Ig](),
                this[bg].sheenColor.toArray()
            }
            get sheenColorTexture() {
                return this[Ig](),
                this[Og].get(cg.SheenColor)
            }
            get sheenRoughnessFactor() {
                return this[Ig](),
                this[bg].sheenRoughness
            }
            get sheenRoughnessTexture() {
                return this[Ig](),
                this[Og].get(cg.SheenRoughness)
            }
            setSheenColorFactor(t) {
                this[Ig]();
                const e = this.colorFromRgb(t);
                for (const t of this[TA])
                    t.sheenColor.set(e),
                    t.sheen = 1;
                this[BA]()
            }
            setSheenRoughnessFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.sheenRoughness = t,
                    e.sheen = 1;
                this[BA]()
            }
            get transmissionFactor() {
                return this[Ig](),
                this[bg].transmission
            }
            get transmissionTexture() {
                return this[Ig](),
                this[Og].get(cg.Transmission)
            }
            setTransmissionFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.transmission = t;
                this[BA]()
            }
            get thicknessFactor() {
                return this[Ig](),
                this[bg].thickness
            }
            get thicknessTexture() {
                return this[Ig](),
                this[Og].get(cg.Thickness)
            }
            get attenuationDistance() {
                return this[Ig](),
                this[bg].attenuationDistance
            }
            get attenuationColor() {
                return this[Ig](),
                this[bg].attenuationColor.toArray()
            }
            setThicknessFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.thickness = t;
                this[BA]()
            }
            setAttenuationDistance(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.attenuationDistance = t;
                this[BA]()
            }
            setAttenuationColor(t) {
                this[Ig]();
                const e = this.colorFromRgb(t);
                for (const t of this[TA])
                    t.attenuationColor.set(e);
                this[BA]()
            }
            get specularFactor() {
                return this[Ig](),
                this[bg].specularIntensity
            }
            get specularTexture() {
                return this[Ig](),
                this[Og].get(cg.Specular)
            }
            get specularColorFactor() {
                return this[Ig](),
                this[bg].specularColor.toArray()
            }
            get specularColorTexture() {
                return this[Ig](),
                this[Og].get(cg.SheenColor)
            }
            setSpecularFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.specularIntensity = t;
                this[BA]()
            }
            setSpecularColorFactor(t) {
                this[Ig]();
                const e = this.colorFromRgb(t);
                for (const t of this[TA])
                    t.specularColor.set(e);
                this[BA]()
            }
            get iridescenceFactor() {
                return this[Ig](),
                this[bg].iridescence
            }
            get iridescenceTexture() {
                return this[Ig](),
                this[Og].get(cg.Iridescence)
            }
            get iridescenceIor() {
                return this[Ig](),
                this[bg].iridescenceIOR
            }
            get iridescenceThicknessMinimum() {
                return this[Ig](),
                this[bg].iridescenceThicknessRange[0]
            }
            get iridescenceThicknessMaximum() {
                return this[Ig](),
                this[bg].iridescenceThicknessRange[1]
            }
            get iridescenceThicknessTexture() {
                return this[Ig](),
                this[Og].get(cg.IridescenceThickness)
            }
            setIridescenceFactor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.iridescence = t;
                this[BA]()
            }
            setIridescenceIor(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.iridescenceIOR = t;
                this[BA]()
            }
            setIridescenceThicknessMinimum(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.iridescenceThicknessRange[0] = t;
                this[BA]()
            }
            setIridescenceThicknessMaximum(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.iridescenceThicknessRange[1] = t;
                this[BA]()
            }
            get anisotropyStrength() {
                return this[Ig](),
                this[bg].anisotropy
            }
            get anisotropyRotation() {
                return this[Ig](),
                this[bg].anisotropyRotation
            }
            get anisotropyTexture() {
                return this[Ig](),
                this[Og].get(cg.Anisotropy)
            }
            setAnisotropyStrength(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.anisotropy = t;
                this[BA]()
            }
            setAnisotropyRotation(t) {
                this[Ig]();
                for (const e of this[TA])
                    e.anisotropyRotation = t;
                this[BA]()
            }
        }
        class Fg {
            constructor(t) {
                this.name = "",
                this.children = new Array,
                this.name = t
            }
        }
        class Qg extends Fg {
            constructor(t, e, n, i) {
                super(t.name),
                this.materials = new Map,
                this.variantToMaterialMap = new Map,
                this.initialMaterialIdx = 0,
                this.activeMaterialIdx = 0,
                this.mesh = t;
                const {gltf: r, threeGLTF: s, threeObjectMap: o} = i;
                this.parser = s.parser,
                this.modelVariants = n,
                this.mesh.userData.variantData = n;
                const a = o.get(t.material);
                null != a.materials ? this.initialMaterialIdx = this.activeMaterialIdx = a.materials : console.error(`Primitive (${t.name}) missing initial material reference.`);
                const l = t.userData.associations || {};
                if (null == l.meshes)
                    return void console.error("Mesh is missing primitive index association");
                const c = ((r.meshes || [])[l.meshes].primitives || [])[l.primitives];
                if (null != c) {
                    if (null != c.material)
                        this.materials.set(c.material, e[c.material]);
                    else {
                        const t = e.findIndex((t=>"Default" === t.name));
                        t >= 0 ? this.materials.set(t, e[t]) : console.warn("gltfPrimitive has no material!")
                    }
                    if (c.extensions && c.extensions.KHR_materials_variants) {
                        const t = c.extensions.KHR_materials_variants
                          , i = s.parser.json.extensions.KHR_materials_variants.variants;
                        for (const r of t.mappings) {
                            const t = e[r.material];
                            this.materials.set(r.material, t);
                            for (const e of r.variants) {
                                const {name: r} = i[e];
                                this.variantToMaterialMap.set(e, t),
                                t[Rg]().add(e),
                                n.has(r) || n.set(r, {
                                    name: r,
                                    index: e
                                })
                            }
                        }
                    }
                } else
                    console.error("Mesh primitive definition is missing.")
            }
            async setActiveMaterial(t) {
                const e = this.materials.get(t);
                if (null != e && t !== this.activeMaterialIdx) {
                    this.mesh.material = await e[Mg]();
                    const {normalScale: n} = this.mesh.material;
                    null != n && n.y * n.x < 0 != (null == this.mesh.geometry.attributes.tangent) && this.parser.assignFinalMaterial(this.mesh),
                    this.activeMaterialIdx = t
                }
                return this.mesh.material
            }
            getActiveMaterial() {
                return this.materials.get(this.activeMaterialIdx)
            }
            getMaterial(t) {
                return this.materials.get(t)
            }
            async enableVariant(t) {
                if (null == t)
                    return this.setActiveMaterial(this.initialMaterialIdx);
                if (null != this.variantToMaterialMap && this.modelVariants.has(t)) {
                    const e = this.modelVariants.get(t);
                    return this.enableVariantHelper(e.index)
                }
                return null
            }
            async enableVariantHelper(t) {
                if (null != this.variantToMaterialMap && null != t) {
                    const e = this.variantToMaterialMap.get(t);
                    if (null != e)
                        return this.setActiveMaterial(e.index)
                }
                return null
            }
            async instantiateVariants() {
                if (null != this.variantToMaterialMap)
                    for (const t of this.variantToMaterialMap.keys()) {
                        const e = this.mesh.userData.variantMaterials.get(t);
                        if (null != e.material)
                            continue;
                        const n = await this.enableVariantHelper(t);
                        null != n && (e.material = n)
                    }
            }
            get variantInfo() {
                return this.variantToMaterialMap
            }
            addVariant(t, e) {
                if (!this.ensureVariantIsUnused(e))
                    return !1;
                this.modelVariants.has(e) || this.modelVariants.set(e, {
                    name: e,
                    index: this.modelVariants.size
                });
                const n = this.modelVariants.get(e).index;
                return t[Rg]().add(n),
                this.variantToMaterialMap.set(n, t),
                this.materials.set(t.index, t),
                this.updateVariantUserData(n, t),
                !0
            }
            deleteVariant(t) {
                if (this.variantInfo.has(t)) {
                    this.variantInfo.delete(t);
                    const e = this.mesh.userData.variantMaterials;
                    null != e && e.delete(t)
                }
            }
            updateVariantUserData(t, e) {
                e[Rg]().add(t),
                this.mesh.userData.variantData = this.modelVariants,
                this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map,
                this.mesh.userData.variantMaterials.set(t, {
                    material: e[TA].values().next().value,
                    gltfMaterialIndex: e.index
                })
            }
            ensureVariantIsUnused(t) {
                const e = this.modelVariants.get(t);
                return null == e || !this.variantInfo.has(e.index) || (console.warn(`Primitive cannot add variant '${t}' for this material, it already exists.`),
                !1)
            }
        }
        var kg, Gg, Hg, zg, Vg, Wg;
        const qg = Symbol("materials")
          , jg = Symbol("hierarchy")
          , Xg = Symbol("roots")
          , Yg = Symbol("primitives")
          , Kg = Symbol("prepareVariantsForExport")
          , Jg = Symbol("switchVariant")
          , $g = Symbol("materialFromPoint")
          , Zg = Symbol("nodeFromPoint")
          , tm = Symbol("nodeFromIndex")
          , em = Symbol("variantData")
          , nm = Symbol("availableVariants")
          , im = Symbol("modelOnUpdate")
          , rm = Symbol("cloneMaterial");
        class sm {
            constructor(t, e, n, i) {
                this.gltf = t,
                this.gltfElementMap = e,
                this.mapKey = n,
                this.doLazyLoad = i
            }
        }
        class om {
            constructor(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ()=>{}
                ;
                this[kg] = new Array,
                this[Gg] = new Array,
                this[Hg] = new Array,
                this[zg] = new Array,
                this[Vg] = ()=>{}
                ,
                this[Wg] = new Map,
                this[im] = e;
                const {gltf: n, threeGLTF: i, gltfElementMap: r} = t;
                for (const [t,s] of n.materials.entries()) {
                    const o = r.get(s);
                    if (null != o)
                        this[qg].push(new Ng(e,t,!0,this[em],o,s.name));
                    else {
                        const a = (n.materials || [])[t]
                          , l = t
                          , c = async()=>{
                            const t = await i.parser.getDependency("material", l)
                              , e = new Set;
                            return r.set(a, e),
                            e.add(t),
                            {
                                set: e,
                                material: t
                            }
                        }
                        ;
                        this[qg].push(new Ng(e,t,!1,this[em],o,s.name,new sm(n,r,a,c)))
                    }
                }
                const s = new Map
                  , o = new Array;
                for (const t of i.scene.children)
                    o.push(t);
                for (; o.length > 0; ) {
                    const e = o.pop();
                    let n = null;
                    e instanceof fi ? (n = new Qg(e,this.materials,this[em],t),
                    this[Yg].push(n)) : n = new Fg(e.name);
                    const i = s.get(e);
                    null != i ? i.children.push(n) : this[Xg].push(n),
                    this[jg].push(n);
                    for (const t of e.children)
                        o.push(t),
                        s.set(e, n)
                }
            }
            get materials() {
                return this[qg]
            }
            [(kg = qg,
            Gg = jg,
            Hg = Xg,
            zg = Yg,
            Vg = im,
            Wg = em,
            nm)]() {
                const t = Array.from(this[em].values());
                return t.sort(((t,e)=>t.index - e.index)),
                t.map((t=>t.name))
            }
            getMaterialByName(t) {
                const e = this[qg].filter((e=>e.name === t));
                return e.length > 0 ? e[0] : null
            }
            [tm](t, e) {
                const n = this[jg].find((n=>{
                    if (n instanceof Qg) {
                        const {meshes: i, primitives: r} = n.mesh.userData.associations;
                        if (i == t && r == e)
                            return !0
                    }
                    return !1
                }
                ));
                return null == n ? null : n
            }
            [Zg](t) {
                return this[jg].find((e=>e instanceof Qg && e.mesh === t.object))
            }
            [$g](t) {
                return this[Zg](t).getActiveMaterial()
            }
            async[Jg](t) {
                for (const e of this[Yg])
                    await e.enableVariant(t);
                for (const t of this.materials)
                    t[Bg](!1);
                for (const t of this[Yg])
                    this.materials[t.getActiveMaterial().index][Bg](!0)
            }
            async[Kg]() {
                const t = new Array;
                for (const e of this[Yg])
                    t.push(e.instantiateVariants());
                await Promise.all(t)
            }
            [rm](t, e) {
                const n = this.materials[t];
                n.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
                const i = n[TA]
                  , r = new Set;
                for (const [t,n] of i.entries()) {
                    const s = n.clone();
                    s.name = e + (i.size > 1 ? "_inst" + t : ""),
                    r.add(s)
                }
                const s = new Ng(this[im],this[qg].length,!1,this[em],r,e);
                return this[qg].push(s),
                s
            }
            createMaterialInstanceForVariant(t, e, n) {
                let i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = null;
                for (const i of this[Yg]) {
                    const s = this[em].get(n);
                    null != s && i.variantInfo.has(s.index) || null != i.getMaterial(t) && (this.hasVariant(n) || this.createVariant(n),
                    null == r && (r = this[rm](t, e)),
                    i.addVariant(r, n))
                }
                if (i && null != r) {
                    r[Bg](!0),
                    this.materials[t][Bg](!1);
                    for (const t of this[Yg])
                        t.enableVariant(n)
                }
                return r
            }
            createVariant(t) {
                this[em].has(t) ? console.warn(`Variant '${t}'' already exists`) : this[em].set(t, {
                    name: t,
                    index: this[em].size
                })
            }
            hasVariant(t) {
                return this[em].has(t)
            }
            setMaterialToVariant(t, e) {
                if (null != this[nm]().find((t=>t === e)))
                    if (t < 0 || t >= this.materials.length)
                        console.error("setMaterialToVariant(): materialIndex is out of bounds.");
                    else
                        for (const n of this[Yg]) {
                            const i = n.getMaterial(t);
                            null != i && n.addVariant(i, e)
                        }
                else
                    console.warn(`Can't add material to '${e}', the variant does not exist.'`)
            }
            updateVariantName(t, e) {
                const n = this[em].get(t);
                null != n && (n.name = e,
                this[em].set(e, n),
                this[em].delete(t))
            }
            deleteVariant(t) {
                const e = this[em].get(t);
                if (null != e) {
                    for (const n of this.materials)
                        n.hasVariant(t) && n[Dg].delete(e.index);
                    for (const t of this[Yg])
                        t.deleteVariant(e.index);
                    this[em].delete(t)
                }
            }
        }
        var am = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const lm = Symbol("currentGLTF")
          , cm = Symbol("originalGltfJson")
          , um = Symbol("model")
          , hm = Symbol("getOnUpdateMethod")
          , dm = Symbol("buildTexture")
          , pm = new he
          , fm = new he
          , Am = new he
          , gm = new Ft
          , mm = new Sn
          , vm = new ue;
        class ym extends Kh {
            constructor(t) {
                super(document.createElement("div")),
                this.normal = new he(0,1,0),
                this.initialized = !1,
                this.referenceCount = 1,
                this.pivot = document.createElement("div"),
                this.slot = document.createElement("slot"),
                this.element.classList.add("annotation-wrapper"),
                this.slot.name = t.name,
                this.element.appendChild(this.pivot),
                this.pivot.appendChild(this.slot),
                this.updatePosition(t.position),
                this.updateNormal(t.normal),
                this.surface = t.surface
            }
            get facingCamera() {
                return !this.element.classList.contains("hide")
            }
            show() {
                this.facingCamera && this.initialized || this.updateVisibility(!0)
            }
            hide() {
                !this.facingCamera && this.initialized || this.updateVisibility(!1)
            }
            increment() {
                this.referenceCount++
            }
            decrement() {
                return this.referenceCount > 0 && --this.referenceCount,
                0 === this.referenceCount
            }
            updatePosition(t) {
                if (null == t)
                    return;
                const e = Xd(t)[0].terms;
                for (let t = 0; t < 3; ++t)
                    this.position.setComponent(t, sp(e[t]).number);
                this.updateMatrixWorld()
            }
            updateNormal(t) {
                if (null == t)
                    return;
                const e = Xd(t)[0].terms;
                for (let t = 0; t < 3; ++t)
                    this.normal.setComponent(t, e[t].number)
            }
            updateSurface(t) {
                if (!t && this.initialized)
                    return;
                const {mesh: e, tri: n, bary: i} = this;
                if (null == e || null == n || null == i)
                    return;
                e.getVertexPosition(n.x, pm),
                e.getVertexPosition(n.y, fm),
                e.getVertexPosition(n.z, Am),
                pm.toArray(gm.elements, 0),
                fm.toArray(gm.elements, 3),
                Am.toArray(gm.elements, 6),
                this.position.copy(i).applyMatrix3(gm);
                const r = this.parent;
                r.worldToLocal(e.localToWorld(this.position)),
                mm.set(pm, fm, Am),
                mm.getNormal(this.normal).transformDirection(e.matrixWorld);
                const s = r.parent;
                vm.setFromAxisAngle(pm.set(0, 1, 0), -s.yaw),
                this.normal.applyQuaternion(vm)
            }
            orient(t) {
                this.pivot.style.transform = `rotate(${t}rad)`
            }
            updateVisibility(t) {
                t ? this.element.classList.remove("hide") : this.element.classList.add("hide"),
                this.slot.assignedNodes().forEach((e=>{
                    if (e.nodeType !== Node.ELEMENT_NODE)
                        return;
                    const n = e
                      , i = n.dataset.visibilityAttribute;
                    if (null != i) {
                        const e = `data-${i}`;
                        t ? n.setAttribute(e, "") : n.removeAttribute(e)
                    }
                    n.dispatchEvent(new CustomEvent("hotspot-visibility",{
                        detail: {
                            visible: t
                        }
                    }))
                }
                )),
                this.initialized = !0
            }
        }
        const _m = {
            name: "HorizontalBlurShader",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                h: {
                    value: 1 / 512
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
        }
          , Em = {
            name: "VerticalBlurShader",
            uniforms: {
                tDiffuse: {
                    value: null
                },
                v: {
                    value: 1 / 512
                }
            },
            vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
        };
        function bm(t, e, n) {
            return (1 - n) * t + n * e
        }
        class xm extends pn {
            constructor(t, e, n) {
                super(),
                this.camera = new Xi,
                this.renderTarget = null,
                this.renderTargetBlur = null,
                this.depthMaterial = new $s,
                this.horizontalBlurMaterial = new Ei(_m),
                this.verticalBlurMaterial = new Ei(Em),
                this.intensity = 0,
                this.softness = 1,
                this.boundingBox = new fe,
                this.size = new he,
                this.maxDimension = 0,
                this.isAnimated = !1,
                this.needsUpdate = !1;
                const {camera: i} = this;
                i.rotation.x = Math.PI / 2,
                i.left = -.5,
                i.right = .5,
                i.bottom = -.5,
                i.top = .5,
                this.add(i);
                const r = new Ni
                  , s = new Pn({
                    opacity: 1,
                    transparent: !0,
                    side: 1
                });
                this.floor = new fi(r,s),
                this.floor.userData.shadow = !0,
                i.add(this.floor),
                this.blurPlane = new fi(r),
                this.blurPlane.visible = !1,
                i.add(this.blurPlane),
                t.target.add(this),
                this.depthMaterial.onBeforeCompile = function(t) {
                    t.fragmentShader = t.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );")
                }
                ,
                this.horizontalBlurMaterial.depthTest = !1,
                this.verticalBlurMaterial.depthTest = !1,
                this.setScene(t, e, n)
            }
            setScene(t, e, n) {
                const {boundingBox: i, size: r, rotation: s, position: o} = this;
                if (this.isAnimated = t.animationNames.length > 0,
                this.boundingBox.copy(t.boundingBox),
                this.size.copy(t.size),
                this.maxDimension = Math.max(r.x, r.y, r.z) * (this.isAnimated ? 2 : 1),
                this.boundingBox.getCenter(o),
                "back" === n) {
                    const {min: t, max: e} = i;
                    [t.y,t.z] = [t.z, t.y],
                    [e.y,e.z] = [e.z, e.y],
                    [r.y,r.z] = [r.z, r.y],
                    s.x = Math.PI / 2,
                    s.y = Math.PI
                } else
                    s.x = 0,
                    s.y = 0;
                if (this.isAnimated) {
                    const t = i.min.y
                      , e = i.max.y;
                    r.y = this.maxDimension,
                    i.expandByVector(r.subScalar(this.maxDimension).multiplyScalar(-.5)),
                    i.min.y = t,
                    i.max.y = e,
                    r.set(this.maxDimension, e - t, this.maxDimension)
                }
                "bottom" === n ? o.y = i.min.y : o.z = i.min.y,
                this.setSoftness(e)
            }
            setSoftness(t) {
                this.softness = t;
                const {size: e, camera: n} = this
                  , i = this.isAnimated ? 2 : 1
                  , r = i * Math.pow(2, 9 - 3 * t);
                this.setMapSize(r);
                const s = e.y / 2
                  , o = e.y * i;
                n.near = 0,
                n.far = bm(o, s, t),
                this.depthMaterial.opacity = 1 / t,
                n.updateProjectionMatrix(),
                this.setIntensity(this.intensity),
                this.setOffset(0)
            }
            setMapSize(t) {
                const {size: e} = this;
                this.isAnimated && (t *= 2);
                const n = Math.floor(e.x > e.z ? t : t * e.x / e.z)
                  , i = Math.floor(e.x > e.z ? t * e.z / e.x : t)
                  , r = 10 + n
                  , s = 10 + i;
                if (null == this.renderTarget || this.renderTarget.width === r && this.renderTarget.height === s || (this.renderTarget.dispose(),
                this.renderTarget = null,
                this.renderTargetBlur.dispose(),
                this.renderTargetBlur = null),
                null == this.renderTarget) {
                    const t = {
                        format: N
                    };
                    this.renderTarget = new ae(r,s,t),
                    this.renderTargetBlur = new ae(r,s,t),
                    this.floor.material.map = this.renderTarget.texture
                }
                this.camera.scale.set(e.x * (1 + 10 / n), e.z * (1 + 10 / i), 1),
                this.needsUpdate = !0
            }
            setIntensity(t) {
                this.intensity = t,
                t > 0 ? (this.visible = !0,
                this.floor.visible = !0,
                this.floor.material.opacity = t * bm(.3, 1, this.softness * this.softness)) : (this.visible = !1,
                this.floor.visible = !1)
            }
            getIntensity() {
                return this.intensity
            }
            setOffset(t) {
                this.floor.position.z = -t + .001 * this.maxDimension
            }
            render(t, e) {
                e.overrideMaterial = this.depthMaterial;
                const n = t.getClearAlpha();
                t.setClearAlpha(0),
                this.floor.visible = !1;
                const i = t.xr.enabled;
                t.xr.enabled = !1;
                const r = t.getRenderTarget();
                t.setRenderTarget(this.renderTarget),
                t.render(e, this.camera),
                e.overrideMaterial = null,
                this.floor.visible = !0,
                this.blurShadow(t),
                t.xr.enabled = i,
                t.setRenderTarget(r),
                t.setClearAlpha(n)
            }
            blurShadow(t) {
                const {camera: e, horizontalBlurMaterial: n, verticalBlurMaterial: i, renderTarget: r, renderTargetBlur: s, blurPlane: o} = this;
                o.visible = !0,
                o.material = n,
                n.uniforms.h.value = 1 / this.renderTarget.width,
                n.uniforms.tDiffuse.value = this.renderTarget.texture,
                t.setRenderTarget(s),
                t.render(o, e),
                o.material = i,
                i.uniforms.v.value = 1 / this.renderTarget.height,
                i.uniforms.tDiffuse.value = this.renderTargetBlur.texture,
                t.setRenderTarget(r),
                t.render(o, e),
                o.visible = !1
            }
            dispose() {
                null != this.renderTarget && this.renderTarget.dispose(),
                null != this.renderTargetBlur && this.renderTargetBlur.dispose(),
                this.depthMaterial.dispose(),
                this.horizontalBlurMaterial.dispose(),
                this.verticalBlurMaterial.dispose(),
                this.floor.material.dispose(),
                this.floor.geometry.dispose(),
                this.blurPlane.geometry.dispose(),
                this.removeFromParent()
            }
        }
        const wm = new he
          , Sm = new he
          , Cm = new he
          , Mm = new class {
            constructor(t, e) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                this.ray = new ke(t,e),
                this.near = n,
                this.far = i,
                this.camera = null,
                this.layers = new $e,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(t, e) {
                this.ray.set(t, e)
            }
            setFromCamera(t, e) {
                e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
                this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
                this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
            }
            intersectObject(t) {
                let e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                return ml(t, this, e, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]),
                e.sort(gl),
                e
            }
            intersectObjects(t) {
                let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                for (let i = 0, r = t.length; i < r; i++)
                    ml(t[i], this, n, e);
                return n.sort(gl),
                n
            }
        }
          , Im = new he
          , Tm = new Nt;
        class Bm extends fo {
            constructor(t) {
                let {canvas: e, element: n, width: i, height: r} = t;
                super(),
                this.annotationRenderer = new nd,
                this.effectRenderer = null,
                this.schemaElement = document.createElement("script"),
                this.width = 1,
                this.height = 1,
                this.aspect = 1,
                this.scaleStep = 0,
                this.renderCount = 0,
                this.externalRenderer = null,
                this.camera = new xi(45,1,.1,100),
                this.xrCamera = null,
                this.url = null,
                this.target = new pn,
                this.animationNames = [],
                this.boundingBox = new fe,
                this.boundingSphere = new Le,
                this.size = new he,
                this.idealAspect = 0,
                this.framedFoVDeg = 0,
                this.shadow = null,
                this.shadowIntensity = 0,
                this.shadowSoftness = 1,
                this.bakedShadows = new Set,
                this.exposure = 1,
                this.toneMapping = "auto",
                this.canScale = !0,
                this.isDirty = !1,
                this.goalTarget = new he,
                this.targetDamperX = new Gd,
                this.targetDamperY = new Gd,
                this.targetDamperZ = new Gd,
                this._currentGLTF = null,
                this._model = null,
                this.cancelPendingSourceChange = null,
                this.animationsByName = new Map,
                this.currentAnimationAction = null,
                this.name = "ModelScene",
                this.element = n,
                this.canvas = e,
                this.camera = new xi(45,1,.1,100),
                this.camera.name = "MainCamera",
                this.add(this.target),
                this.setSize(i, r),
                this.target.name = "Target",
                this.mixer = new fl(this.target);
                const {domElement: s} = this.annotationRenderer
                  , {style: o} = s;
                o.display = "none",
                o.pointerEvents = "none",
                o.position = "absolute",
                o.top = "0",
                this.element.shadowRoot.querySelector(".default").appendChild(s),
                this.schemaElement.setAttribute("type", "application/ld+json")
            }
            get context() {
                return this.canvas.getContext("2d")
            }
            getCamera() {
                return null != this.xrCamera ? this.xrCamera : this.camera
            }
            queueRender() {
                this.isDirty = !0
            }
            shouldRender() {
                return this.isDirty
            }
            hasRendered() {
                this.isDirty = !1
            }
            forceRescale() {
                this.scaleStep = -1,
                this.queueRender()
            }
            async setObject(t) {
                this.reset(),
                this._model = t,
                this.target.add(t),
                await this.setupScene()
            }
            async setSource(t) {
                let e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ()=>{}
                ;
                if (!t || t === this.url)
                    return void n(1);
                if (this.reset(),
                this.url = t,
                null != this.externalRenderer) {
                    const t = await this.externalRenderer.load(n);
                    return this.boundingSphere.radius = t.framedRadius,
                    void (this.idealAspect = t.fieldOfViewAspect)
                }
                null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(),
                this.cancelPendingSourceChange = null);
                try {
                    e = await new Promise((async(e,i)=>{
                        this.cancelPendingSourceChange = ()=>i();
                        try {
                            e(await this.element[Ev].loader.load(t, this.element, n))
                        } catch (t) {
                            i(t)
                        }
                    }
                    ))
                } catch (t) {
                    if (null == t)
                        return;
                    throw t
                }
                this.cancelPendingSourceChange = null,
                this.reset(),
                this.url = t,
                this._currentGLTF = e,
                null != e && (this._model = e.scene,
                this.target.add(e.scene));
                const {animations: i} = e
                  , r = new Map
                  , s = [];
                for (const t of i)
                    r.set(t.name, t),
                    s.push(t.name);
                this.animations = i,
                this.animationsByName = r,
                this.animationNames = s,
                await this.setupScene()
            }
            async setupScene() {
                this.applyTransform(),
                this.updateBoundingBox(),
                await this.updateFraming(),
                this.updateShadow(),
                this.setShadowIntensity(this.shadowIntensity)
            }
            reset() {
                this.url = null,
                this.renderCount = 0,
                this.queueRender(),
                null != this.shadow && this.shadow.setIntensity(0),
                this.bakedShadows.clear();
                const {_model: t} = this;
                null != t && (t.removeFromParent(),
                this._model = null);
                const e = this._currentGLTF;
                null != e && (e.dispose(),
                this._currentGLTF = null),
                null != this.currentAnimationAction && (this.currentAnimationAction.stop(),
                this.currentAnimationAction = null),
                this.mixer.stopAllAction(),
                this.mixer.uncacheRoot(this)
            }
            dispose() {
                this.reset(),
                null != this.shadow && (this.shadow.dispose(),
                this.shadow = null),
                this.element[lm] = null,
                this.element[cm] = null,
                this.element[um] = null
            }
            get currentGLTF() {
                return this._currentGLTF
            }
            setSize(t, e) {
                if (this.width !== t || this.height !== e) {
                    if (this.width = Math.max(t, 1),
                    this.height = Math.max(e, 1),
                    this.annotationRenderer.setSize(t, e),
                    this.aspect = this.width / this.height,
                    null != this.externalRenderer) {
                        const n = ru();
                        this.externalRenderer.resize(t * n, e * n)
                    }
                    this.queueRender()
                }
            }
            markBakedShadow(t) {
                t.userData.shadow = !0,
                this.bakedShadows.add(t)
            }
            unmarkBakedShadow(t) {
                t.userData.shadow = !1,
                t.visible = !0,
                this.bakedShadows.delete(t),
                this.boundingBox.expandByObject(t)
            }
            findBakedShadows(t) {
                const e = new fe;
                t.traverse((t=>{
                    const n = t;
                    if (!n.material)
                        return;
                    if (!n.material.transparent)
                        return;
                    e.setFromObject(n);
                    const i = e.getSize(Im)
                      , r = Math.min(i.x, i.y, i.z);
                    Math.max(i.x, i.y, i.z) < 100 * r || this.markBakedShadow(n)
                }
                ))
            }
            checkBakedShadows() {
                const {min: t, max: e} = this.boundingBox
                  , n = new fe;
                this.boundingBox.getSize(this.size);
                for (const i of this.bakedShadows)
                    n.setFromObject(i),
                    n.min.y < t.y + this.size.y / 100 && n.min.x <= t.x && n.max.x >= e.x && n.min.z <= t.z && n.max.z >= e.z || n.min.z < t.z + this.size.z / 100 && n.min.x <= t.x && n.max.x >= e.x && n.min.y <= t.y && n.max.y >= e.y || this.unmarkBakedShadow(i)
            }
            applyTransform() {
                const {model: t} = this;
                if (null == t)
                    return;
                const e = Xd(this.element.orientation)[0].terms
                  , n = sp(e[0]).number
                  , i = sp(e[1]).number
                  , r = sp(e[2]).number;
                t.quaternion.setFromEuler(new Je(i,r,n,"YXZ"));
                const s = Xd(this.element.scale)[0].terms;
                t.scale.set(s[0].number, s[1].number, s[2].number)
            }
            updateBoundingBox() {
                const {model: t} = this;
                if (null == t)
                    return;
                this.target.remove(t),
                this.findBakedShadows(t);
                const e = (t,e)=>t.expandByPoint(e);
                this.setBakedShadowVisibility(!1),
                this.boundingBox = id(t, e, new fe),
                this.boundingBox.isEmpty() && (this.setBakedShadowVisibility(!0),
                this.bakedShadows.forEach((t=>this.unmarkBakedShadow(t))),
                this.boundingBox = id(t, e, new fe)),
                this.checkBakedShadows(),
                this.setBakedShadowVisibility(),
                this.boundingBox.getSize(this.size),
                this.target.add(t)
            }
            async updateFraming() {
                const {model: t} = this;
                if (null == t)
                    return;
                this.target.remove(t),
                this.setBakedShadowVisibility(!1);
                const {center: e} = this.boundingSphere;
                this.element.requestUpdate("cameraTarget"),
                await this.element.updateComplete,
                e.copy(this.getTarget()),
                this.boundingSphere.radius = Math.sqrt(id(t, ((t,n)=>Math.max(t, e.distanceToSquared(n))), 0)),
                this.idealAspect = id(t, ((t,n)=>{
                    n.sub(e);
                    const i = Math.sqrt(n.x * n.x + n.z * n.z);
                    return Math.max(t, i / (this.idealCameraDistance() - Math.abs(n.y)))
                }
                ), 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180),
                this.setBakedShadowVisibility(),
                this.target.add(t)
            }
            setBakedShadowVisibility() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.shadowIntensity <= 0;
                for (const e of this.bakedShadows)
                    e.visible = t
            }
            idealCameraDistance() {
                const t = this.framedFoVDeg / 2 * Math.PI / 180;
                return this.boundingSphere.radius / Math.sin(t)
            }
            adjustedFoV(t) {
                const e = Math.tan(t / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
                return 2 * Math.atan(e) * 180 / Math.PI
            }
            getNDC(t, e) {
                if (null != this.xrCamera)
                    Tm.set(t / window.screen.width, e / window.screen.height);
                else {
                    const n = this.element.getBoundingClientRect();
                    Tm.set((t - n.x) / this.width, (e - n.y) / this.height)
                }
                return Tm.multiplyScalar(2).subScalar(1),
                Tm.y *= -1,
                Tm
            }
            getSize() {
                return {
                    width: this.width,
                    height: this.height
                }
            }
            setEnvironmentAndSkybox(t, e) {
                this.element[Ev].arRenderer.presentedScene !== this && (this.environment = t,
                this.background = e,
                this.queueRender())
            }
            setTarget(t, e, n) {
                this.goalTarget.set(-t, -e, -n)
            }
            setTargetDamperDecayTime(t) {
                this.targetDamperX.setDecayTime(t),
                this.targetDamperY.setDecayTime(t),
                this.targetDamperZ.setDecayTime(t)
            }
            getTarget() {
                return this.goalTarget.clone().multiplyScalar(-1)
            }
            jumpToGoal() {
                this.updateTarget(1e4)
            }
            updateTarget(t) {
                const e = this.goalTarget
                  , n = this.target.position;
                if (e.equals(n))
                    return !1;
                {
                    const i = this.boundingSphere.radius / 10;
                    let {x: r, y: s, z: o} = n;
                    return r = this.targetDamperX.update(r, e.x, t, i),
                    s = this.targetDamperY.update(s, e.y, t, i),
                    o = this.targetDamperZ.update(o, e.z, t, i),
                    this.target.position.set(r, s, o),
                    this.target.updateMatrixWorld(),
                    this.queueRender(),
                    !0
                }
            }
            pointTowards(t, e) {
                const {x: n, z: i} = this.position;
                this.yaw = Math.atan2(t - n, e - i)
            }
            get model() {
                return this._model
            }
            set yaw(t) {
                this.rotation.y = t,
                this.queueRender()
            }
            get yaw() {
                return this.rotation.y
            }
            set animationTime(t) {
                this.mixer.setTime(t),
                this.queueShadowRender()
            }
            get animationTime() {
                if (null != this.currentAnimationAction) {
                    const t = Math.max(this.currentAnimationAction._loopCount, 0);
                    return this.currentAnimationAction.loop === Z && 1 == (1 & t) ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time
                }
                return 0
            }
            set animationTimeScale(t) {
                this.mixer.timeScale = t
            }
            get animationTimeScale() {
                return this.mixer.timeScale
            }
            get duration() {
                return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0
            }
            get hasActiveAnimation() {
                return null != this.currentAnimationAction
            }
            playAnimation() {
                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2201
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                if (null == this._currentGLTF)
                    return;
                const {animations: r} = this;
                if (null == r || 0 === r.length)
                    return;
                let s = null;
                if (null != t && (s = this.animationsByName.get(t),
                null == s)) {
                    const e = parseInt(t);
                    !isNaN(e) && e >= 0 && e < r.length && (s = r[e])
                }
                null == s && (s = r[0]);
                try {
                    const {currentAnimationAction: t} = this
                      , r = this.mixer.clipAction(s, this);
                    this.currentAnimationAction = r,
                    this.element.paused ? this.mixer.stopAllAction() : (r.paused = !1,
                    null != t && r !== t ? r.crossFadeFrom(t, e, !1) : this.animationTimeScale > 0 && this.animationTime == this.duration && (this.animationTime = 0)),
                    r.setLoop(n, i),
                    r.enabled = !0,
                    r.clampWhenFinished = !0,
                    r.play()
                } catch (t) {
                    console.error(t)
                }
            }
            stopAnimation() {
                this.currentAnimationAction = null,
                this.mixer.stopAllAction()
            }
            updateAnimation(t) {
                this.mixer.update(t),
                this.queueShadowRender()
            }
            subscribeMixerEvent(t, e) {
                this.mixer.addEventListener(t, e)
            }
            updateShadow() {
                const t = this.shadow;
                if (null != t) {
                    const e = "wall" === this.element.arPlacement ? "back" : "bottom";
                    t.setScene(this, this.shadowSoftness, e),
                    t.needsUpdate = !0
                }
            }
            renderShadow(t) {
                const e = this.shadow;
                null != e && 1 == e.needsUpdate && (e.render(t, this),
                e.needsUpdate = !1)
            }
            queueShadowRender() {
                null != this.shadow && (this.shadow.needsUpdate = !0)
            }
            setShadowIntensity(t) {
                if (this.shadowIntensity = t,
                null != this._currentGLTF && (this.setBakedShadowVisibility(),
                !(t <= 0 && null == this.shadow))) {
                    if (null == this.shadow) {
                        const t = "wall" === this.element.arPlacement ? "back" : "bottom";
                        this.shadow = new xm(this,this.shadowSoftness,t)
                    }
                    this.shadow.setIntensity(t)
                }
            }
            setShadowSoftness(t) {
                this.shadowSoftness = t;
                const e = this.shadow;
                null != e && e.setSoftness(t)
            }
            setShadowOffset(t) {
                const e = this.shadow;
                null != e && e.setOffset(t)
            }
            hitFromPoint(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
                return Mm.setFromCamera(t, this.getCamera()),
                Mm.intersectObject(e, !0).find((t=>t.object.visible && !t.object.userData.shadow))
            }
            positionAndNormalFromPoint(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
                var n;
                const i = this.hitFromPoint(t, e);
                return null == i ? null : {
                    position: i.point,
                    normal: null != i.face ? i.face.normal.clone().applyNormalMatrix((new Ft).getNormalMatrix(i.object.matrixWorld)) : Mm.ray.direction.clone().multiplyScalar(-1),
                    uv: null !== (n = i.uv) && void 0 !== n ? n : null
                }
            }
            surfaceFromPoint(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this;
                const n = this.element.model;
                if (null == n)
                    return null;
                const i = this.hitFromPoint(t, e);
                if (null == i || null == i.face)
                    return null;
                const r = n[Zg](i)
                  , {meshes: s, primitives: o} = r.mesh.userData.associations
                  , a = new he
                  , l = new he
                  , c = new he
                  , {a: u, b: h, c: d} = i.face
                  , p = i.object;
                p.getVertexPosition(u, a),
                p.getVertexPosition(h, l),
                p.getVertexPosition(d, c);
                const f = new Sn(a,l,c)
                  , A = new he;
                return f.getBarycoord(p.worldToLocal(i.point), A),
                `${s} ${o} ${u} ${h} ${d} ${A.x.toFixed(3)} ${A.y.toFixed(3)} ${A.z.toFixed(3)}`
            }
            addHotspot(t) {
                this.target.add(t),
                this.annotationRenderer.domElement.appendChild(t.element)
            }
            removeHotspot(t) {
                this.target.remove(t)
            }
            forHotspots(t) {
                const {children: e} = this.target;
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    i instanceof ym && t(i)
                }
            }
            initializeSurface(t) {
                if (null != t.surface && null == t.mesh) {
                    const e = Xd(t.surface)[0].terms;
                    if (8 != e.length)
                        return void console.warn(t.surface + " does not have exactly 8 numbers.");
                    const n = this.element.model[tm](e[0].number, e[1].number)
                      , i = new he(e[2].number,e[3].number,e[4].number);
                    if (null == n)
                        return void console.warn(t.surface + " does not match a node/primitive in this glTF! Skipping this hotspot.");
                    const r = n.mesh.geometry.attributes.position.count;
                    if (i.x >= r || i.y >= r || i.z >= r)
                        return void console.warn(t.surface + " vertex indices out of range in this glTF! Skipping this hotspot.");
                    const s = new he(e[5].number,e[6].number,e[7].number);
                    t.mesh = n.mesh,
                    t.tri = i,
                    t.bary = s
                }
            }
            updateSurfaceHotspots() {
                const t = !this.element.paused;
                this.forHotspots((e=>{
                    this.initializeSurface(e),
                    e.updateSurface(t)
                }
                ))
            }
            updateHotspotsVisibility(t) {
                this.forHotspots((e=>{
                    wm.copy(t),
                    Sm.setFromMatrixPosition(e.matrixWorld),
                    wm.sub(Sm),
                    Cm.copy(e.normal).transformDirection(this.target.matrixWorld),
                    wm.dot(Cm) < 0 ? e.hide() : e.show()
                }
                ))
            }
            orientHotspots(t) {
                this.forHotspots((e=>{
                    e.orient(t)
                }
                ))
            }
            setHotspotsVisibility(t) {
                this.forHotspots((e=>{
                    e.visible = t
                }
                ))
            }
            updateSchema(t) {
                var e;
                const {schemaElement: n, element: i} = this
                  , {alt: r, poster: s, iosSrc: o} = i;
                if (null != t) {
                    const i = [{
                        "@type": "MediaObject",
                        contentUrl: t,
                        encodingFormat: "gltf" === (null === (e = t.split(".").pop()) || void 0 === e ? void 0 : e.toLowerCase()) ? "model/gltf+json" : "model/gltf-binary"
                    }];
                    o && i.push({
                        "@type": "MediaObject",
                        contentUrl: o,
                        encodingFormat: "model/vnd.usdz+zip"
                    });
                    const a = {
                        "@context": "http://schema.org/",
                        "@type": "3DModel",
                        image: null != s ? s : void 0,
                        name: null != r ? r : void 0,
                        encoding: i
                    };
                    n.textContent = JSON.stringify(a),
                    document.head.appendChild(n)
                } else
                    null != n.parentElement && n.parentElement.removeChild(n)
            }
        }
        class Rm extends EventTarget {
            constructor() {
                super(...arguments),
                this.ongoingActivities = new Set,
                this.totalProgress = 0
            }
            get ongoingActivityCount() {
                return this.ongoingActivities.size
            }
            beginActivity() {
                const t = {
                    progress: 0,
                    completed: !1
                };
                return this.ongoingActivities.add(t),
                1 === this.ongoingActivityCount && this.announceTotalProgress(t, 0),
                e=>{
                    let n;
                    return n = Math.max(iu(e, 0, 1), t.progress),
                    n !== t.progress && this.announceTotalProgress(t, n),
                    t.progress
                }
            }
            announceTotalProgress(t, e) {
                let n = 0
                  , i = 0;
                1 == e && (t.completed = !0);
                for (const t of this.ongoingActivities) {
                    const {progress: e} = t;
                    n += 1 - e,
                    !0 === t.completed && i++
                }
                const r = t.progress;
                t.progress = e,
                this.totalProgress += (e - r) * (1 - this.totalProgress) / n;
                const s = i === this.ongoingActivityCount ? 1 : this.totalProgress;
                this.dispatchEvent(new CustomEvent("progress",{
                    detail: {
                        totalProgress: s
                    }
                })),
                i === this.ongoingActivityCount && (this.totalProgress = 0,
                this.ongoingActivities.clear())
            }
        }
        var Lm, Dm, Pm, Um, Om, Nm, Fm, Qm, km, Gm, Hm, zm, Vm, Wm = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const qm = document.createElement("canvas")
          , jm = Symbol("fallbackResizeHandler")
          , Xm = Symbol("defaultAriaLabel")
          , Ym = Symbol("resizeObserver")
          , Km = Symbol("clearModelTimeout")
          , Jm = Symbol("onContextLost")
          , $m = Symbol("loaded")
          , Zm = Symbol("status")
          , tv = Symbol("onFocus")
          , ev = Symbol("onBlur")
          , nv = Symbol("updateSize")
          , iv = Symbol("intersectionObserver")
          , rv = Symbol("isElementInViewport")
          , sv = Symbol("announceModelVisibility")
          , ov = Symbol("ariaLabel")
          , av = Symbol("altDefaulted")
          , lv = Symbol("statusElement")
          , cv = Symbol("updateStatus")
          , uv = Symbol("loadedTime")
          , hv = Symbol("updateSource")
          , dv = Symbol("markLoaded")
          , pv = Symbol("container")
          , fv = Symbol("input")
          , Av = Symbol("canvas")
          , gv = Symbol("scene")
          , mv = Symbol("needsRender")
          , vv = Symbol("tick")
          , yv = Symbol("onModelLoad")
          , _v = Symbol("onResize")
          , Ev = Symbol("renderer")
          , bv = Symbol("progressTracker")
          , xv = Symbol("getLoaded")
          , wv = Symbol("getModelIsVisible")
          , Sv = Symbol("shouldAttemptPreload")
          , Cv = t=>({
            x: t.x,
            y: t.y,
            z: t.z,
            toString() {
                return `${this.x}m ${this.y}m ${this.z}m`
            }
        })
          , Mv = t=>({
            u: t.x,
            v: t.y,
            toString() {
                return `${this.u} ${this.v}`
            }
        });
        class Iv extends Pc {
            constructor() {
                super(),
                this.alt = null,
                this._zarboAndroidSrc = null,
                this._zOriginalSource = null,
                this.src = null,
                this.withCredentials = !1,
                this.generateSchema = !1,
                this[Lm] = !1,
                this[Dm] = !1,
                this[Pm] = 0,
                this[Um] = "",
                this[Om] = null,
                this[Nm] = nu((()=>{
                    const t = this.getBoundingClientRect();
                    this[nv](t)
                }
                ), 50),
                this[Fm] = nu((t=>{
                    const e = this.modelIsVisible;
                    e !== t && this.dispatchEvent(new CustomEvent("model-visibility",{
                        detail: {
                            visible: e
                        }
                    }))
                }
                ), 0),
                this[Qm] = null,
                this[km] = null,
                this[Gm] = new Rm,
                this[Hm] = ()=>{
                    this[lv].textContent = this[Zm]
                }
                ,
                this[zm] = ()=>{
                    this[lv].textContent = ""
                }
                ,
                this[Vm] = t=>{
                    this.dispatchEvent(new CustomEvent("error",{
                        detail: {
                            type: "webglcontextlost",
                            sourceError: t.sourceEvent
                        }
                    }))
                }
                ,
                this.attachShadow({
                    mode: "open"
                });
                const t = this.shadowRoot;
                let e, n;
                if ((t=>{
                    vc(du, t)
                }
                )(t),
                this[pv] = t.querySelector(".container"),
                this[fv] = t.querySelector(".userInput"),
                this[Av] = t.querySelector("canvas"),
                this[lv] = t.querySelector("#status"),
                this[Xm] = this[fv].getAttribute("aria-label"),
                this.isConnected) {
                    const t = this.getBoundingClientRect();
                    e = t.width,
                    n = t.height
                } else
                    e = 300,
                    n = 150;
                this[gv] = new Bm({
                    canvas: this[Av],
                    element: this,
                    width: e,
                    height: n
                }),
                Promise.resolve().then((()=>{
                    this[nv](this.getBoundingClientRect())
                }
                )),
                Gc && (this[Ym] = new ResizeObserver((t=>{
                    if (!this[Ev].isPresenting)
                        for (let e of t)
                            e.target === this && this[nv](e.contentRect)
                }
                ))),
                Hc ? this[iv] = new IntersectionObserver((t=>{
                    for (let e of t)
                        if (e.target === this) {
                            const t = this.modelIsVisible;
                            this[rv] = e.isIntersecting,
                            this[sv](t),
                            this[rv] && !this.loaded && this[hv]()
                        }
                }
                ),{
                    root: null,
                    rootMargin: "0px",
                    threshold: 1e-5
                }) : this[rv] = !0
            }
            static get is() {
                return "zarbo-widget"
            }
            static set modelCacheSize(t) {
                Yh[jh].evictionThreshold = t
            }
            static get modelCacheSize() {
                return Yh[jh].evictionThreshold
            }
            static set minimumRenderScale(t) {
                t > 1 && console.warn("<zarbo-widget> minimumRenderScale has been clamped to a maximum value of 1."),
                t <= 0 && console.warn("<zarbo-widget> minimumRenderScale has been clamped to a minimum value of 0.25."),
                IA.singleton.minScale = t
            }
            static get minimumRenderScale() {
                return IA.singleton.minScale
            }
            get loaded() {
                return this[xv]()
            }
            get[(Lm = rv,
            Dm = $m,
            Pm = uv,
            Um = Zm,
            Om = Km,
            Nm = jm,
            Fm = sv,
            Qm = Ym,
            km = iv,
            Gm = bv,
            Ev)]() {
                return IA.singleton
            }
            get modelIsVisible() {
                return this[wv]()
            }
            connectedCallback() {
                super.connectedCallback && super.connectedCallback(),
                Gc ? this[Ym].observe(this) : self.addEventListener("resize", this[jm]),
                Hc && this[iv].observe(this),
                this.addEventListener("focus", this[tv]),
                this.addEventListener("blur", this[ev]);
                const t = this[Ev];
                t.addEventListener("contextlost", this[Jm]),
                t.registerScene(this[gv]),
                null != this[Km] && (self.clearTimeout(this[Km]),
                this[Km] = null,
                this.requestUpdate("src", null))
            }
            disconnectedCallback() {
                super.disconnectedCallback && super.disconnectedCallback(),
                Gc ? this[Ym].unobserve(this) : self.removeEventListener("resize", this[jm]),
                Hc && this[iv].unobserve(this),
                this.removeEventListener("focus", this[tv]),
                this.removeEventListener("blur", this[ev]);
                const t = this[Ev];
                t.removeEventListener("contextlost", this[Jm]),
                t.unregisterScene(this[gv]),
                this[Km] = self.setTimeout((()=>{
                    this[gv].dispose(),
                    this[Km] = null
                }
                ), 10)
            }
            updated(t) {
                super.updated(t),
                t.has("src") && (null == this.src ? (this[$m] = !1,
                this[uv] = 0,
                this[gv].reset()) : this.src !== this[gv].url && (this[$m] = !1,
                this[uv] = 0,
                this[hv]())),
                t.has("alt") && this[fv].setAttribute("aria-label", this[ov]),
                t.has("withCredentials") && (Yh.withCredentials = this.withCredentials,
                this[Ev].textureUtils.withCredentials = this.withCredentials),
                t.has("generateSchema") && (this.generateSchema ? this[gv].updateSchema(this.src) : this[gv].updateSchema(null))
            }
            toDataURL(t, e) {
                return this[Ev].displayCanvas(this[gv]).toDataURL(t, e)
            }
            async toBlob(t) {
                const e = t ? t.mimeType : void 0
                  , n = t ? t.qualityArgument : void 0
                  , i = t ? t.idealAspect : void 0
                  , {width: r, height: s, idealAspect: o, aspect: a} = this[gv]
                  , {dpr: l, scaleFactor: c} = this[Ev];
                let u = r * c * l
                  , h = s * c * l
                  , d = 0
                  , p = 0;
                if (!0 === i)
                    if (o > a) {
                        const t = h;
                        h = Math.round(u / o),
                        p = (t - h) / 2
                    } else {
                        const t = u;
                        u = Math.round(h * o),
                        d = (t - u) / 2
                    }
                qm.width = u,
                qm.height = h;
                try {
                    return new Promise((async(t,i)=>{
                        qm.getContext("2d").drawImage(this[Ev].displayCanvas(this[gv]), d, p, u, h, 0, 0, u, h),
                        qm.toBlob((e=>{
                            if (!e)
                                return i(new Error("Unable to retrieve canvas blob"));
                            t(e)
                        }
                        ), e, n)
                    }
                    ))
                } finally {
                    this[nv]({
                        width: r,
                        height: s
                    })
                }
            }
            registerEffectComposer(t) {
                t.setRenderer(this[Ev].threeRenderer),
                t.setMainCamera(this[gv].getCamera()),
                t.setMainScene(this[gv]),
                this[gv].effectRenderer = t
            }
            unregisterEffectComposer() {
                this[gv].effectRenderer = null
            }
            registerRenderer(t) {
                this[gv].externalRenderer = t
            }
            unregisterRenderer() {
                this[gv].externalRenderer = null
            }
            get[ov]() {
                return this[av]
            }
            get[av]() {
                return null == this.alt || "null" === this.alt ? this[Xm] : this.alt
            }
            [xv]() {
                return this[$m]
            }
            [wv]() {
                return this.loaded && this[rv]
            }
            [Sv]() {
                return !!this.src && this[rv]
            }
            [nv](t) {
                let {width: e, height: n} = t;
                0 !== e && 0 !== n && (this[pv].style.width = `${e}px`,
                this[pv].style.height = `${n}px`,
                this[_v]({
                    width: e,
                    height: n
                }))
            }
            [vv](t, e) {
                var n;
                null === (n = this[gv].effectRenderer) || void 0 === n || n.beforeRender(t, e)
            }
            [dv]() {
                this[$m] || (this[$m] = !0,
                this[uv] = performance.now())
            }
            [mv]() {
                this[gv].queueRender()
            }
            [yv]() {}
            [cv](t) {
                this[Zm] = t;
                const e = this.getRootNode();
                null != e && e.activeElement === this && this[lv].textContent != t && (this[lv].textContent = t)
            }
            [(Hm = tv,
            zm = ev,
            _v)](t) {
                this[gv].setSize(t.width, t.height)
            }
            async[(Vm = Jm,
            hv)]() {
                const t = this[gv];
                if (this.loaded || !this[Sv]() || this.src === t.url)
                    return;
                this.generateSchema && t.updateSchema(this.src),
                this[cv]("Loading"),
                t.stopAnimation();
                const e = this[bv].beginActivity()
                  , n = this.src;
                try {
                    const i = t.setSource(n, (t=>e(.95 * iu(t, 0, 1))))
                      , r = this[uu]();
                    await Promise.all([i, r]),
                    this[dv](),
                    this[yv](),
                    this.updateComplete.then((()=>{
                        this.dispatchEvent(new CustomEvent("before-render"))
                    }
                    )),
                    await new Promise((t=>{
                        requestAnimationFrame((()=>{
                            requestAnimationFrame((()=>{
                                this.dispatchEvent(new CustomEvent("load",{
                                    detail: {
                                        url: n
                                    }
                                })),
                                t()
                            }
                            ))
                        }
                        ))
                    }
                    ))
                } catch (t) {
                    this.dispatchEvent(new CustomEvent("error",{
                        detail: {
                            type: "loadfailure",
                            sourceError: t
                        }
                    }))
                } finally {
                    e(1)
                }
            }
        }
        Wm([e({
            type: String
        })], Iv.prototype, "alt", void 0),
        Wm([e({
            type: String
        })], Iv.prototype, "_zarboAndroidSrc", void 0),
        Wm([e({
            type: String
        })], Iv.prototype, "_zOriginalSource", void 0),
        Wm([e({
            type: String
        })], Iv.prototype, "src", void 0),
        Wm([e({
            type: Boolean,
            attribute: "with-credentials"
        })], Iv.prototype, "withCredentials", void 0),
        Wm([e({
            type: Boolean,
            attribute: "generate-schema"
        })], Iv.prototype, "generateSchema", void 0);
        var Tv = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const Bv = Symbol("changeAnimation")
          , Rv = Symbol("paused")
          , Lv = {
            repetitions: 1 / 0,
            pingpong: !1
        }
          , Dv = Symbol("hotspotMap")
          , Pv = Symbol("mutationCallback")
          , Uv = Symbol("observer")
          , Ov = Symbol("addHotspot")
          , Nv = Symbol("removeHotspot")
          , Fv = new Ge;
        var Qv = function(t) {
            return URL.createObjectURL(new Blob([t],{
                type: "text/javascript"
            }))
        };
        try {
            URL.revokeObjectURL(Qv(""))
        } catch (Cc) {
            Qv = function(t) {
                return "data:application/javascript;charset=UTF-8," + encodeURI(t)
            }
        }
        var kv = Uint8Array
          , Gv = Uint16Array
          , Hv = Uint32Array
          , zv = new kv([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
          , Vv = new kv([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
          , Wv = new kv([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , qv = function(t, e) {
            for (var n = new Gv(31), i = 0; i < 31; ++i)
                n[i] = e += 1 << t[i - 1];
            var r = new Hv(n[30]);
            for (i = 1; i < 30; ++i)
                for (var s = n[i]; s < n[i + 1]; ++s)
                    r[s] = s - n[i] << 5 | i;
            return [n, r]
        }
          , jv = qv(zv, 2)
          , Xv = jv[0]
          , Yv = jv[1];
        Xv[28] = 258,
        Yv[258] = 28;
        for (var Kv = qv(Vv, 0)[1], Jv = new Gv(32768), $v = 0; $v < 32768; ++$v) {
            var Zv = (43690 & $v) >>> 1 | (21845 & $v) << 1;
            Zv = (61680 & (Zv = (52428 & Zv) >>> 2 | (13107 & Zv) << 2)) >>> 4 | (3855 & Zv) << 4,
            Jv[$v] = ((65280 & Zv) >>> 8 | (255 & Zv) << 8) >>> 1
        }
        var ty = function(t, e, n) {
            for (var i = t.length, r = 0, s = new Gv(e); r < i; ++r)
                ++s[t[r] - 1];
            var o, a = new Gv(e);
            for (r = 0; r < e; ++r)
                a[r] = a[r - 1] + s[r - 1] << 1;
            if (n) {
                o = new Gv(1 << e);
                var l = 15 - e;
                for (r = 0; r < i; ++r)
                    if (t[r])
                        for (var c = r << 4 | t[r], u = e - t[r], h = a[t[r] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
                            o[Jv[h] >>> l] = c
            } else
                for (o = new Gv(i),
                r = 0; r < i; ++r)
                    t[r] && (o[r] = Jv[a[t[r] - 1]++] >>> 15 - t[r]);
            return o
        }
          , ey = new kv(288);
        for ($v = 0; $v < 144; ++$v)
            ey[$v] = 8;
        for ($v = 144; $v < 256; ++$v)
            ey[$v] = 9;
        for ($v = 256; $v < 280; ++$v)
            ey[$v] = 7;
        for ($v = 280; $v < 288; ++$v)
            ey[$v] = 8;
        var ny = new kv(32);
        for ($v = 0; $v < 32; ++$v)
            ny[$v] = 5;
        var iy = ty(ey, 9, 0)
          , ry = ty(ny, 5, 0)
          , sy = function(t) {
            return (t / 8 | 0) + (7 & t && 1)
        }
          , oy = function(t, e, n) {
            (null == e || e < 0) && (e = 0),
            (null == n || n > t.length) && (n = t.length);
            var i = new (t instanceof Gv ? Gv : t instanceof Hv ? Hv : kv)(n - e);
            return i.set(t.subarray(e, n)),
            i
        }
          , ay = function(t, e, n) {
            n <<= 7 & e;
            var i = e / 8 | 0;
            t[i] |= n,
            t[i + 1] |= n >>> 8
        }
          , ly = function(t, e, n) {
            n <<= 7 & e;
            var i = e / 8 | 0;
            t[i] |= n,
            t[i + 1] |= n >>> 8,
            t[i + 2] |= n >>> 16
        }
          , cy = function(t, e) {
            for (var n = [], i = 0; i < t.length; ++i)
                t[i] && n.push({
                    s: i,
                    f: t[i]
                });
            var r = n.length
              , s = n.slice();
            if (!r)
                return [gy, 0];
            if (1 == r) {
                var o = new kv(n[0].s + 1);
                return o[n[0].s] = 1,
                [o, 1]
            }
            n.sort((function(t, e) {
                return t.f - e.f
            }
            )),
            n.push({
                s: -1,
                f: 25001
            });
            var a = n[0]
              , l = n[1]
              , c = 0
              , u = 1
              , h = 2;
            for (n[0] = {
                s: -1,
                f: a.f + l.f,
                l: a,
                r: l
            }; u != r - 1; )
                a = n[n[c].f < n[h].f ? c++ : h++],
                l = n[c != u && n[c].f < n[h].f ? c++ : h++],
                n[u++] = {
                    s: -1,
                    f: a.f + l.f,
                    l: a,
                    r: l
                };
            var d = s[0].s;
            for (i = 1; i < r; ++i)
                s[i].s > d && (d = s[i].s);
            var p = new Gv(d + 1)
              , f = uy(n[u - 1], p, 0);
            if (f > e) {
                i = 0;
                var A = 0
                  , g = f - e
                  , m = 1 << g;
                for (s.sort((function(t, e) {
                    return p[e.s] - p[t.s] || t.f - e.f
                }
                )); i < r; ++i) {
                    var v = s[i].s;
                    if (!(p[v] > e))
                        break;
                    A += m - (1 << f - p[v]),
                    p[v] = e
                }
                for (A >>>= g; A > 0; ) {
                    var y = s[i].s;
                    p[y] < e ? A -= 1 << e - p[y]++ - 1 : ++i
                }
                for (; i >= 0 && A; --i) {
                    var _ = s[i].s;
                    p[_] == e && (--p[_],
                    ++A)
                }
                f = e
            }
            return [new kv(p), f]
        }
          , uy = function(t, e, n) {
            return -1 == t.s ? Math.max(uy(t.l, e, n + 1), uy(t.r, e, n + 1)) : e[t.s] = n
        }
          , hy = function(t) {
            for (var e = t.length; e && !t[--e]; )
                ;
            for (var n = new Gv(++e), i = 0, r = t[0], s = 1, o = function(t) {
                n[i++] = t
            }, a = 1; a <= e; ++a)
                if (t[a] == r && a != e)
                    ++s;
                else {
                    if (!r && s > 2) {
                        for (; s > 138; s -= 138)
                            o(32754);
                        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305),
                        s = 0)
                    } else if (s > 3) {
                        for (o(r),
                        --s; s > 6; s -= 6)
                            o(8304);
                        s > 2 && (o(s - 3 << 5 | 8208),
                        s = 0)
                    }
                    for (; s--; )
                        o(r);
                    s = 1,
                    r = t[a]
                }
            return [n.subarray(0, i), e]
        }
          , dy = function(t, e) {
            for (var n = 0, i = 0; i < e.length; ++i)
                n += t[i] * e[i];
            return n
        }
          , py = function(t, e, n) {
            var i = n.length
              , r = sy(e + 2);
            t[r] = 255 & i,
            t[r + 1] = i >>> 8,
            t[r + 2] = 255 ^ t[r],
            t[r + 3] = 255 ^ t[r + 1];
            for (var s = 0; s < i; ++s)
                t[r + s + 4] = n[s];
            return 8 * (r + 4 + i)
        }
          , fy = function(t, e, n, i, r, s, o, a, l, c, u) {
            ay(e, u++, n),
            ++r[256];
            for (var h = cy(r, 15), d = h[0], p = h[1], f = cy(s, 15), A = f[0], g = f[1], m = hy(d), v = m[0], y = m[1], _ = hy(A), E = _[0], b = _[1], x = new Gv(19), w = 0; w < v.length; ++w)
                x[31 & v[w]]++;
            for (w = 0; w < E.length; ++w)
                x[31 & E[w]]++;
            for (var S = cy(x, 7), C = S[0], M = S[1], I = 19; I > 4 && !C[Wv[I - 1]]; --I)
                ;
            var T, B, R, L, D = c + 5 << 3, P = dy(r, ey) + dy(s, ny) + o, U = dy(r, d) + dy(s, A) + o + 14 + 3 * I + dy(x, C) + (2 * x[16] + 3 * x[17] + 7 * x[18]);
            if (D <= P && D <= U)
                return py(e, u, t.subarray(l, l + c));
            if (ay(e, u, 1 + (U < P)),
            u += 2,
            U < P) {
                T = ty(d, p, 0),
                B = d,
                R = ty(A, g, 0),
                L = A;
                var O = ty(C, M, 0);
                for (ay(e, u, y - 257),
                ay(e, u + 5, b - 1),
                ay(e, u + 10, I - 4),
                u += 14,
                w = 0; w < I; ++w)
                    ay(e, u + 3 * w, C[Wv[w]]);
                u += 3 * I;
                for (var N = [v, E], F = 0; F < 2; ++F) {
                    var Q = N[F];
                    for (w = 0; w < Q.length; ++w) {
                        var k = 31 & Q[w];
                        ay(e, u, O[k]),
                        u += C[k],
                        k > 15 && (ay(e, u, Q[w] >>> 5 & 127),
                        u += Q[w] >>> 12)
                    }
                }
            } else
                T = iy,
                B = ey,
                R = ry,
                L = ny;
            for (w = 0; w < a; ++w)
                if (i[w] > 255) {
                    k = i[w] >>> 18 & 31,
                    ly(e, u, T[k + 257]),
                    u += B[k + 257],
                    k > 7 && (ay(e, u, i[w] >>> 23 & 31),
                    u += zv[k]);
                    var G = 31 & i[w];
                    ly(e, u, R[G]),
                    u += L[G],
                    G > 3 && (ly(e, u, i[w] >>> 5 & 8191),
                    u += Vv[G])
                } else
                    ly(e, u, T[i[w]]),
                    u += B[i[w]];
            return ly(e, u, T[256]),
            u + B[256]
        }
          , Ay = new Hv([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
          , gy = new kv(0)
          , my = function() {
            for (var t = new Hv(256), e = 0; e < 256; ++e) {
                for (var n = e, i = 9; --i; )
                    n = (1 & n && 3988292384) ^ n >>> 1;
                t[e] = n
            }
            return t
        }()
          , vy = function() {
            var t = -1;
            return {
                p: function(e) {
                    for (var n = t, i = 0; i < e.length; ++i)
                        n = my[255 & n ^ e[i]] ^ n >>> 8;
                    t = n
                },
                d: function() {
                    return ~t
                }
            }
        }
          , yy = function(t, e, n, i, r) {
            return function(t, e, n, i, r, s) {
                var o = t.length
                  , a = new kv(i + o + 5 * (1 + Math.ceil(o / 7e3)) + r)
                  , l = a.subarray(i, a.length - r)
                  , c = 0;
                if (!e || o < 8)
                    for (var u = 0; u <= o; u += 65535) {
                        var h = u + 65535;
                        h < o ? c = py(l, c, t.subarray(u, h)) : (l[u] = s,
                        c = py(l, c, t.subarray(u, o)))
                    }
                else {
                    for (var d = Ay[e - 1], p = d >>> 13, f = 8191 & d, A = (1 << n) - 1, g = new Gv(32768), m = new Gv(A + 1), v = Math.ceil(n / 3), y = 2 * v, _ = function(e) {
                        return (t[e] ^ t[e + 1] << v ^ t[e + 2] << y) & A
                    }, E = new Hv(25e3), b = new Gv(288), x = new Gv(32), w = 0, S = 0, C = (u = 0,
                    0), M = 0, I = 0; u < o; ++u) {
                        var T = _(u)
                          , B = 32767 & u
                          , R = m[T];
                        if (g[B] = R,
                        m[T] = B,
                        M <= u) {
                            var L = o - u;
                            if ((w > 7e3 || C > 24576) && L > 423) {
                                c = fy(t, l, 0, E, b, x, S, C, I, u - I, c),
                                C = w = S = 0,
                                I = u;
                                for (var D = 0; D < 286; ++D)
                                    b[D] = 0;
                                for (D = 0; D < 30; ++D)
                                    x[D] = 0
                            }
                            var P = 2
                              , U = 0
                              , O = f
                              , N = B - R & 32767;
                            if (L > 2 && T == _(u - N))
                                for (var F = Math.min(p, L) - 1, Q = Math.min(32767, u), k = Math.min(258, L); N <= Q && --O && B != R; ) {
                                    if (t[u + P] == t[u + P - N]) {
                                        for (var G = 0; G < k && t[u + G] == t[u + G - N]; ++G)
                                            ;
                                        if (G > P) {
                                            if (P = G,
                                            U = N,
                                            G > F)
                                                break;
                                            var H = Math.min(N, G - 2)
                                              , z = 0;
                                            for (D = 0; D < H; ++D) {
                                                var V = u - N + D + 32768 & 32767
                                                  , W = V - g[V] + 32768 & 32767;
                                                W > z && (z = W,
                                                R = V)
                                            }
                                        }
                                    }
                                    N += (B = R) - (R = g[B]) + 32768 & 32767
                                }
                            if (U) {
                                E[C++] = 268435456 | Yv[P] << 18 | Kv[U];
                                var q = 31 & Yv[P]
                                  , j = 31 & Kv[U];
                                S += zv[q] + Vv[j],
                                ++b[257 + q],
                                ++x[j],
                                M = u + P,
                                ++w
                            } else
                                E[C++] = t[u],
                                ++b[t[u]]
                        }
                    }
                    c = fy(t, l, s, E, b, x, S, C, I, u - I, c),
                    !s && 7 & c && (c = py(l, c + 1, gy))
                }
                return oy(a, 0, i + sy(c) + r)
            }(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, i, !r)
        }
          , _y = function(t, e) {
            var n = {};
            for (var i in t)
                n[i] = t[i];
            for (var i in e)
                n[i] = e[i];
            return n
        }
          , Ey = function(t, e, n) {
            for (; n; ++e)
                t[e] = n,
                n >>>= 8
        };
        function by(t, e) {
            return yy(t, e || {}, 0, 0)
        }
        var xy = function(t, e, n, i) {
            for (var r in t) {
                var s = t[r]
                  , o = e + r;
                s instanceof kv ? n[o] = [s, i] : Array.isArray(s) ? n[o] = [s[0], _y(i, s[1])] : xy(s, o + "/", n, i)
            }
        }
          , wy = "undefined" != typeof TextEncoder && new TextEncoder
          , Sy = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            Sy.decode(gy, {
                stream: !0
            })
        } catch (Cc) {}
        function Cy(t, e) {
            if (e) {
                for (var n = new kv(t.length), i = 0; i < t.length; ++i)
                    n[i] = t.charCodeAt(i);
                return n
            }
            if (wy)
                return wy.encode(t);
            var r = t.length
              , s = new kv(t.length + (t.length >> 1))
              , o = 0
              , a = function(t) {
                s[o++] = t
            };
            for (i = 0; i < r; ++i) {
                if (o + 5 > s.length) {
                    var l = new kv(o + 8 + (r - i << 1));
                    l.set(s),
                    s = l
                }
                var c = t.charCodeAt(i);
                c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6),
                a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++i)) >> 18),
                a(128 | c >> 12 & 63),
                a(128 | c >> 6 & 63),
                a(128 | 63 & c)) : (a(224 | c >> 12),
                a(128 | c >> 6 & 63),
                a(128 | 63 & c))
            }
            return oy(s, 0, o)
        }
        var My = function(t) {
            var e = 0;
            if (t)
                for (var n in t) {
                    var i = t[n].length;
                    if (i > 65535)
                        throw "extra field too long";
                    e += i + 4
                }
            return e
        }
          , Iy = function(t, e, n, i, r, s, o, a) {
            var l = i.length
              , c = n.extra
              , u = a && a.length
              , h = My(c);
            Ey(t, e, null != o ? 33639248 : 67324752),
            e += 4,
            null != o && (t[e++] = 20,
            t[e++] = n.os),
            t[e] = 20,
            e += 2,
            t[e++] = n.flag << 1 | (null == s && 8),
            t[e++] = r && 8,
            t[e++] = 255 & n.compression,
            t[e++] = n.compression >> 8;
            var d = new Date(null == n.mtime ? Date.now() : n.mtime)
              , p = d.getFullYear() - 1980;
            if (p < 0 || p > 119)
                throw "date not in range 1980-2099";
            if (Ey(t, e, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1),
            e += 4,
            null != s && (Ey(t, e, n.crc),
            Ey(t, e + 4, s),
            Ey(t, e + 8, n.size)),
            Ey(t, e + 12, l),
            Ey(t, e + 14, h),
            e += 16,
            null != o && (Ey(t, e, u),
            Ey(t, e + 6, n.attrs),
            Ey(t, e + 10, o),
            e += 14),
            t.set(i, e),
            e += l,
            h)
                for (var f in c) {
                    var A = c[f]
                      , g = A.length;
                    Ey(t, e, +f),
                    Ey(t, e + 2, g),
                    t.set(A, e + 4),
                    e += 4 + g
                }
            return u && (t.set(a, e),
            e += u),
            e
        };
        class Ty {
            async parse(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                e = Object.assign({
                    ar: {
                        anchoring: {
                            type: "plane"
                        },
                        planeAnchoring: {
                            alignment: "horizontal"
                        }
                    },
                    quickLookCompatible: !1
                }, e);
                const n = {}
                  , i = "model.usda";
                n[i] = null;
                let r = '#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';
                r += function(t) {
                    return `def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{\n\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`
                }(e);
                const s = {}
                  , o = {};
                t.traverseVisible((t=>{
                    if (t.isMesh) {
                        const e = t.geometry
                          , i = t.material;
                        if (i.isMeshStandardMaterial) {
                            const o = "geometries/Geometry_" + e.id + ".usda";
                            if (!(o in n)) {
                                const t = function(t) {
                                    const e = function(t) {
                                        const e = t.attributes
                                          , n = e.position.count;
                                        return `\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t) {
                                            const e = null !== t.index ? t.index.count : t.attributes.position.count;
                                            return Array(e / 3).fill(3).join(", ")
                                        }(t)}]\n\t\tint[] faceVertexIndices = [${function(t) {
                                            const e = t.index
                                              , n = [];
                                            if (null !== e)
                                                for (lett = 0; t < e.count; t++)
                                                    n.push(e.getX(t));
                                            else {
                                                const e = t.attributes.position.count;
                                                for (lett = 0; t < e; t++)
                                                    n.push(t)
                                            }
                                            return n.join(", ")
                                        }(t)}]\n\t\tnormal3f[] normals = [${Py(e.normal, n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Py(e.position, n)}]\n${function(t, e) {
                                            letn = "";
                                            for (leti = 0; i < 4; i++) {
                                                const r = i > 0 ? i : ""
                                                  , s = t["uv" + r];
                                                void 0 !== s && (n += `\n\t\ttexCoord2f[] primvars:st${r} = [${Uy(s, e)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)
                                            }
                                            return n
                                        }(e, n)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`
                                    }(t);
                                    return `\ndef "Geometry"\n{\n${e}\n}\n`
                                }(e);
                                n[o] = function(t) {
                                    let e = '#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tdefaultPrim = "Root"\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';
                                    return e += t,
                                    Cy(e)
                                }(t)
                            }
                            i.uuid in s || (s[i.uuid] = i),
                            r += function(t, e, n) {
                                const i = "Object_" + t.id
                                  , r = Ly(t.matrixWorld);
                                return t.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t),
                                `def Xform "${i}" (\n\tprepend references = @./geometries/Geometry_${e.id}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${r}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\trel material:binding = </Materials/Material_${n.id}>\n}\n\n`
                            }(t, e, i)
                        } else
                            console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", t)
                    } else
                        t.isCamera && (r += function(t) {
                            const e = t.name ? t.name : "Camera_" + t.id
                              , n = Ly(t.matrixWorld);
                            return t.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t),
                            t.isOrthographicCamera ? `def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(Ry)}, ${t.far.toPrecision(Ry)})\n\t\t\tfloat horizontalAperture = ${(10 * (Math.abs(t.left) + Math.abs(t.right))).toPrecision(Ry)}\n\t\t\tfloat verticalAperture = ${(10 * (Math.abs(t.top) + Math.abs(t.bottom))).toPrecision(Ry)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t` : `def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${n}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(Ry)}, ${t.far.toPrecision(Ry)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(Ry)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(Ry)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(Ry)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(Ry)}\n\t\t}\n\t\n\t`
                        }(t))
                }
                )),
                r += "\n\t\t}\n\t}\n}\n\n",
                r += function(t, e) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    const i = [];
                    for (const r in t) {
                        const s = t[r];
                        i.push(Oy(s, e, n))
                    }
                    return `def "Materials"\n{\n${i.join("")}\n}\n\n`
                }(s, o, e.quickLookCompatible),
                n[i] = Cy(r),
                r = null;
                for (const t in o) {
                    const e = o[t]
                      , i = By(e.image, e.flipY)
                      , r = await new Promise((t=>i.toBlob(t, "image/png", 1)));
                    n[`textures/Texture_${t}.png`] = new Uint8Array(await r.arrayBuffer())
                }
                let a = 0;
                for (const t in n) {
                    const e = n[t];
                    a += 34 + t.length;
                    const i = 63 & a;
                    if (4 !== i) {
                        const r = new Uint8Array(64 - i);
                        n[t] = [e, {
                            extra: {
                                12345: r
                            }
                        }]
                    }
                    a = e.length
                }
                return function(t, e) {
                    e || (e = {});
                    var n = {}
                      , i = [];
                    xy(t, "", n, e);
                    var r = 0
                      , s = 0;
                    for (var o in n) {
                        var a = n[o]
                          , l = a[0]
                          , c = a[1]
                          , u = 0 == c.level ? 0 : 8
                          , h = (x = Cy(o)).length
                          , d = c.comment
                          , p = d && Cy(d)
                          , f = p && p.length
                          , A = My(c.extra);
                        if (h > 65535)
                            throw "filename too long";
                        var g = u ? by(l, c) : l
                          , m = g.length
                          , v = vy();
                        v.p(l),
                        i.push(_y(c, {
                            size: l.length,
                            crc: v.d(),
                            c: g,
                            f: x,
                            m: p,
                            u: h != o.length || p && d.length != f,
                            o: r,
                            compression: u
                        })),
                        r += 30 + h + A + m,
                        s += 76 + 2 * (h + A) + (f || 0) + m
                    }
                    for (var y = new kv(s + 22), _ = r, E = s - r, b = 0; b < i.length; ++b) {
                        var x = i[b];
                        Iy(y, x.o, x, x.f, x.u, x.c.length);
                        var w = 30 + x.f.length + My(x.extra);
                        y.set(x.c, x.o + w),
                        Iy(y, r, x, x.f, x.u, x.c.length, x.o, x.m),
                        r += 16 + w + (x.m ? x.m.length : 0)
                    }
                    return function(t, e, n, i, r) {
                        Ey(t, e, 101010256),
                        Ey(t, e + 8, n),
                        Ey(t, e + 10, n),
                        Ey(t, e + 12, i),
                        Ey(t, e + 16, r)
                    }(y, r, i.length, E, _),
                    y
                }(n, {
                    level: 0
                })
            }
        }
        function By(t, e) {
            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                const n = 1024 / Math.max(t.width, t.height)
                  , i = document.createElement("canvas");
                i.width = t.width * Math.min(1, n),
                i.height = t.height * Math.min(1, n);
                const r = i.getContext("2d");
                return !0 === e && (r.translate(0, i.height),
                r.scale(1, -1)),
                r.drawImage(t, 0, 0, i.width, i.height),
                i
            }
            throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")
        }
        const Ry = 7;
        function Ly(t) {
            const e = t.elements;
            return `( ${Dy(e, 0)}, ${Dy(e, 4)}, ${Dy(e, 8)}, ${Dy(e, 12)} )`
        }
        function Dy(t, e) {
            return `(${t[e + 0]}, ${t[e + 1]}, ${t[e + 2]}, ${t[e + 3]})`
        }
        function Py(t, e) {
            if (void 0 === t)
                return console.warn("USDZExporter: Normals missing."),
                Array(e).fill("(0, 0, 0)").join(", ");
            const n = [];
            for (let e = 0; e < t.count; e++) {
                const i = t.getX(e)
                  , r = t.getY(e)
                  , s = t.getZ(e);
                n.push(`(${i.toPrecision(Ry)}, ${r.toPrecision(Ry)}, ${s.toPrecision(Ry)})`)
            }
            return n.join(", ")
        }
        function Uy(t, e) {
            if (void 0 === t)
                return console.warn("USDZExporter: UVs missing."),
                Array(e).fill("(0, 0)").join(", ");
            const n = [];
            for (let e = 0; e < t.count; e++) {
                const i = t.getX(e)
                  , r = t.getY(e);
                n.push(`(${i.toPrecision(Ry)}, ${1 - r.toPrecision(Ry)})`)
            }
            return n.join(", ")
        }
        function Oy(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const i = "\t\t\t"
              , r = []
              , s = [];
            function o(i, r, s) {
                const o = i.source.id + "_" + i.flipY;
                e[o] = i;
                const a = i.channel > 0 ? "st" + i.channel : "st"
                  , l = {
                    1e3: "repeat",
                    1001: "clamp",
                    1002: "mirror"
                }
                  , c = i.repeat.clone()
                  , u = i.offset.clone()
                  , h = i.rotation
                  , d = Math.sin(h)
                  , p = Math.cos(h);
                return u.y = 1 - u.y - c.y,
                n ? (u.x = u.x / c.x,
                u.y = u.y / c.y,
                u.x += d / c.x,
                u.y += p - 1) : (u.x += d * c.x,
                u.y += (1 - p) * c.y),
                `\n\t\tdef Shader "PrimvarReader_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${a}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${r}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(h * (180 / Math.PI)).toFixed(Ry)}\n\t\t\tfloat2 inputs:scale = ${Fy(c)}\n\t\t\tfloat2 inputs:translation = ${Fy(u)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${i.id}_${r}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${o}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n\t\t\t${void 0 !== s ? "float4 inputs:scale = " + function(t) {
                    return `(${t.r}, ${t.g}, ${t.b}, 1.0)`
                }(s) : ""}\n\t\t\ttoken inputs:sourceColorSpace = "${i.colorSpace === at ? "raw" : "sRGB"}"\n\t\t\ttoken inputs:wrapS = "${l[i.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${l[i.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t ${t.transparent || t.alphaTest > 0 ? "float outputs:a" : ""}\n\t\t}`
            }
            return 2 === t.side && console.warn("THREE.USDZExporter: USDZ does not support double sided materials", t),
            null !== t.map ? (r.push(`${i}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),
            t.transparent ? r.push(`${i}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`) : t.alphaTest > 0 && (r.push(`${i}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),
            r.push(`${i}float inputs:opacityThreshold = ${t.alphaTest}`)),
            s.push(o(t.map, "diffuse", t.color))) : r.push(`${i}color3f inputs:diffuseColor = ${Ny(t.color)}`),
            null !== t.emissiveMap ? (r.push(`${i}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),
            s.push(o(t.emissiveMap, "emissive"))) : t.emissive.getHex() > 0 && r.push(`${i}color3f inputs:emissiveColor = ${Ny(t.emissive)}`),
            null !== t.normalMap && (r.push(`${i}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),
            s.push(o(t.normalMap, "normal"))),
            null !== t.aoMap && (r.push(`${i}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),
            s.push(o(t.aoMap, "occlusion"))),
            null !== t.roughnessMap && 1 === t.roughness ? (r.push(`${i}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),
            s.push(o(t.roughnessMap, "roughness"))) : r.push(`${i}float inputs:roughness = ${t.roughness}`),
            null !== t.metalnessMap && 1 === t.metalness ? (r.push(`${i}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),
            s.push(o(t.metalnessMap, "metallic"))) : r.push(`${i}float inputs:metallic = ${t.metalness}`),
            null !== t.alphaMap ? (r.push(`${i}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),
            r.push(`${i}float inputs:opacityThreshold = 0.0001`),
            s.push(o(t.alphaMap, "opacity"))) : r.push(`${i}float inputs:opacity = ${t.opacity}`),
            t.isMeshPhysicalMaterial && (r.push(`${i}float inputs:clearcoat = ${t.clearcoat}`),
            r.push(`${i}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),
            r.push(`${i}float inputs:ior = ${t.ior}`)),
            `\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n${s.join("\n")}\n\n\t}\n`
        }
        function Ny(t) {
            return `(${t.r}, ${t.g}, ${t.b})`
        }
        function Fy(t) {
            return `(${t.x}, ${t.y})`
        }
        var Qy = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        let ky = !1
          , Gy = !1;
        const Hy = "#zarbo-widget-no-ar-fallback"
          , zy = (Vy = ["quick-look", "scene-viewer", "webxr", "none"],
        t=>{
            try {
                const e = Xd(t)
                  , n = (e.length ? e[0].terms : []).filter((t=>t && "ident" === t.type)).map((t=>t.value)).filter((t=>Vy.indexOf(t) > -1))
                  , i = new Set;
                for (const t of n)
                    i.add(t);
                return i
            } catch (t) {}
            return new Set
        }
        );
        var Vy;
        const Wy = "quick-look"
          , qy = "scene-viewer"
          , jy = "webxr"
          , Xy = "none"
          , Yy = Symbol("arButtonContainer")
          , Ky = Symbol("enterARWithWebXR")
          , Jy = Symbol("openSceneViewer")
          , $y = Symbol("openIOSARQuickLook")
          , Zy = Symbol("canActivateAR")
          , t_ = Symbol("arMode")
          , e_ = Symbol("arModes")
          , n_ = Symbol("arAnchor")
          , i_ = Symbol("preload")
          , r_ = Symbol("onARButtonContainerClick")
          , s_ = Symbol("onARStatus")
          , o_ = Symbol("onARTracking")
          , a_ = Symbol("onARTap")
          , l_ = Symbol("selectARMode")
          , c_ = Symbol("triggerLoad");
        var u_ = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const h_ = "auto"
          , d_ = Symbol("defaultProgressBarElement")
          , p_ = Symbol("posterContainerElement")
          , f_ = Symbol("defaultPosterElement")
          , A_ = Symbol("shouldDismissPoster")
          , g_ = Symbol("hidePoster")
          , m_ = Symbol("modelIsRevealed")
          , v_ = Symbol("updateProgressBar")
          , y_ = Symbol("ariaLabelCallToAction")
          , __ = Symbol("onProgress");
        var E_ = function(t, e, n, i) {
            for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)
                (r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
            return s > 3 && o && Object.defineProperty(e, n, o),
            o
        };
        const b_ = Math.PI / 32
          , x_ = {
            basis: [ip(jd(b_, "rad"))],
            keywords: {
                auto: [null]
            }
        }
          , w_ = Symbol("autoRotateStartTime")
          , S_ = Symbol("radiansPerSecond")
          , C_ = Symbol("syncRotationRate")
          , M_ = Symbol("onCameraChange")
          , I_ = (t=>{
            var e, n, i;
            class r extends t {
                constructor() {
                    super(...arguments),
                    this[e] = new Map,
                    this[n] = t=>{
                        t.forEach((t=>{
                            t instanceof MutationRecord && "childList" !== t.type || (t.addedNodes.forEach((t=>{
                                this[Ov](t)
                            }
                            )),
                            t.removedNodes.forEach((t=>{
                                this[Nv](t)
                            }
                            )),
                            this[mv]())
                        }
                        ))
                    }
                    ,
                    this[i] = new MutationObserver(this[Pv])
                }
                connectedCallback() {
                    super.connectedCallback();
                    for (let t = 0; t < this.children.length; ++t)
                        this[Ov](this.children[t]);
                    const {ShadyDOM: t} = self;
                    null == t ? this[Uv].observe(this, {
                        childList: !0
                    }) : this[Uv] = t.observeChildren(this, this[Pv])
                }
                disconnectedCallback() {
                    super.disconnectedCallback();
                    const {ShadyDOM: t} = self;
                    null == t ? this[Uv].disconnect() : t.unobserveChildren(this[Uv])
                }
                [(e = Dv,
                n = Pv,
                i = Uv,
                vv)](t, e) {
                    super[vv](t, e);
                    const n = this[gv]
                      , {annotationRenderer: i} = n
                      , r = n.getCamera();
                    n.shouldRender() && (n.updateSurfaceHotspots(),
                    n.updateHotspotsVisibility(r.position),
                    i.domElement.style.display = "",
                    i.render(n, r))
                }
                updateHotspot(t) {
                    const e = this[Dv].get(t.name);
                    null != e && (e.updatePosition(t.position),
                    e.updateNormal(t.normal),
                    e.surface = t.surface,
                    this[mv]())
                }
                queryHotspot(t) {
                    const e = this[Dv].get(t);
                    if (null == e)
                        return null;
                    const n = Cv(e.position)
                      , i = Cv(e.normal)
                      , r = e.facingCamera
                      , s = this[gv]
                      , o = s.getCamera()
                      , a = new he;
                    a.setFromMatrixPosition(e.matrixWorld),
                    a.project(o);
                    const l = s.width / 2
                      , c = s.height / 2;
                    a.x = a.x * l + l,
                    a.y = -a.y * c + c;
                    const u = Cv(new he(a.x,a.y,a.z));
                    return Number.isFinite(u.x) && Number.isFinite(u.y) ? {
                        position: n,
                        normal: i,
                        canvasPosition: u,
                        facingCamera: r
                    } : null
                }
                positionAndNormalFromPoint(t, e) {
                    const n = this[gv]
                      , i = n.getNDC(t, e)
                      , r = n.positionAndNormalFromPoint(i);
                    if (null == r)
                        return null;
                    Fv.copy(n.target.matrixWorld).invert();
                    const s = Cv(r.position.applyMatrix4(Fv))
                      , o = Cv(r.normal.transformDirection(Fv));
                    let a = null;
                    return null != r.uv && (a = Mv(r.uv)),
                    {
                        position: s,
                        normal: o,
                        uv: a
                    }
                }
                surfaceFromPoint(t, e) {
                    const n = this[gv]
                      , i = n.getNDC(t, e);
                    return n.surfaceFromPoint(i)
                }
                [Ov](t) {
                    if (!(t instanceof HTMLElement && 0 === t.slot.indexOf("hotspot")))
                        return;
                    let e = this[Dv].get(t.slot);
                    null != e ? e.increment() : (e = new ym({
                        name: t.slot,
                        position: t.dataset.position,
                        normal: t.dataset.normal,
                        surface: t.dataset.surface
                    }),
                    this[Dv].set(t.slot, e),
                    this[gv].addHotspot(e)),
                    this[gv].queueRender()
                }
                [Nv](t) {
                    if (!(t instanceof HTMLElement))
                        return;
                    const e = this[Dv].get(t.slot);
                    e && (e.decrement() && (this[gv].removeHotspot(e),
                    this[Dv].delete(t.slot)),
                    this[gv].queueRender())
                }
            }
            return r
        }
        )((t=>{
            var n, i, r;
            class s extends t {
                constructor() {
                    super(...arguments),
                    this[n] = void 0,
                    this[i] = null,
                    this[r] = null,
                    this.variantName = null,
                    this.orientation = "0 0 0",
                    this.scale = "1 1 1"
                }
                get model() {
                    return this[um]
                }
                get availableVariants() {
                    return this.model ? this.model[nm]() : []
                }
                get originalGltfJson() {
                    return this[cm]
                }
                [(n = um,
                i = lm,
                r = cm,
                hm)]() {
                    return ()=>{
                        this[mv]()
                    }
                }
                [dm](t) {
                    return t.colorSpace = lt,
                    t.wrapS = b,
                    t.wrapT = b,
                    new ZA(this[hm](),t)
                }
                async createTexture(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "image/png";
                    const {textureUtils: n} = this[Ev]
                      , i = await n.loadImage(t);
                    return i.userData.mimeType = e,
                    this[dm](i)
                }
                async createLottieTexture(t) {
                    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    const {textureUtils: n} = this[Ev]
                      , i = await n.loadLottie(t, e);
                    return this[dm](i)
                }
                createVideoTexture(t) {
                    const e = document.createElement("video");
                    e.src = t,
                    e.muted = !0,
                    e.playsInline = !0,
                    e.loop = !0,
                    e.play();
                    const n = new oa(e);
                    return this[dm](n)
                }
                createCanvasTexture() {
                    const t = document.createElement("canvas")
                      , e = new ua(t);
                    return this[dm](e)
                }
                async updated(t) {
                    if (super.updated(t),
                    t.has("variantName")) {
                        const t = this[bv].beginActivity();
                        t(.1);
                        const e = this[um]
                          , {variantName: n} = this;
                        null != e && (await e[Jg](n),
                        this[mv](),
                        this.dispatchEvent(new CustomEvent("variant-applied"))),
                        t(1)
                    }
                    if (t.has("orientation") || t.has("scale")) {
                        if (!this.loaded)
                            return;
                        const t = this[gv];
                        t.applyTransform(),
                        t.updateBoundingBox(),
                        t.updateShadow(),
                        this[Ev].arRenderer.onUpdateScene(),
                        this[mv]()
                    }
                }
                [yv]() {
                    super[yv]();
                    const {currentGLTF: t} = this[gv];
                    if (null != t) {
                        const {correlatedSceneGraph: e} = t;
                        null != e && t !== this[lm] && (this[um] = new om(e,this[hm]()),
                        this[cm] = JSON.parse(JSON.stringify(e.gltf))),
                        "variants"in t.userData && this.requestUpdate("variantName")
                    }
                    this[lm] = t
                }
                async exportScene(t) {
                    const e = this[gv];
                    return new Promise((async(n,i)=>{
                        const r = {
                            binary: !0,
                            onlyVisible: !0,
                            maxTextureSize: 1 / 0,
                            includeCustomExtensions: !1,
                            forceIndices: !1
                        };
                        Object.assign(r, t),
                        r.animations = e.animations,
                        r.truncateDrawRange = !0;
                        const s = e.shadow;
                        let o = !1;
                        null != s && (o = s.visible,
                        s.visible = !1),
                        await this[um][Kg](),
                        (new ud).register((t=>new Fd(t))).parse(e.model, (t=>n(new Blob([r.binary ? t : JSON.stringify(t)],{
                            type: r.binary ? "application/octet-stream" : "application/json"
                        }))), (()=>i("glTF export failed")), r),
                        null != s && (s.visible = o)
                    }
                    ))
                }
                materialFromPoint(t, e) {
                    const n = this[um];
                    if (null == n)
                        return null;
                    const i = this[gv]
                      , r = i.getNDC(t, e)
                      , s = i.hitFromPoint(r);
                    return null == s || null == s.face ? null : n[$g](s)
                }
            }
            return am([e({
                type: String,
                attribute: "variant-name"
            })], s.prototype, "variantName", void 0),
            am([e({
                type: String,
                attribute: "orientation"
            })], s.prototype, "orientation", void 0),
            am([e({
                type: String,
                attribute: "scale"
            })], s.prototype, "scale", void 0),
            s
        }
        )((t=>{
            var n, i, r;
            class s extends t {
                constructor() {
                    super(...arguments),
                    this.autoRotate = !1,
                    this.autoRotateDelay = 3e3,
                    this.rotationPerSecond = "auto",
                    this[n] = performance.now(),
                    this[i] = 0,
                    this[r] = t=>{
                        this.autoRotate && "user-interaction" === t.detail.source && (this[w_] = performance.now())
                    }
                }
                connectedCallback() {
                    super.connectedCallback(),
                    this.addEventListener("camera-change", this[M_]),
                    this[w_] = performance.now()
                }
                disconnectedCallback() {
                    super.disconnectedCallback(),
                    this.removeEventListener("camera-change", this[M_]),
                    this[w_] = performance.now()
                }
                updated(t) {
                    super.updated(t),
                    t.has("autoRotate") && (this[w_] = performance.now())
                }
                [(n = w_,
                i = S_,
                C_)](t) {
                    this[S_] = t[0]
                }
                [vv](t, e) {
                    if (super[vv](t, e),
                    !this.autoRotate || !this[wv]() || this[Ev].isPresenting)
                        return;
                    const n = Math.min(e, t - this[w_] - this.autoRotateDelay);
                    n > 0 && (this[gv].yaw = this.turntableRotation + this[S_] * n * .001)
                }
                get turntableRotation() {
                    return this[gv].yaw
                }
                resetTurntableRotation() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this[gv].yaw = t
                }
            }
            return r = M_,
            E_([e({
                type: Boolean,
                attribute: "auto-rotate"
            })], s.prototype, "autoRotate", void 0),
            E_([e({
                type: Number,
                attribute: "auto-rotate-delay"
            })], s.prototype, "autoRotateDelay", void 0),
            E_([zp({
                intrinsics: x_,
                updateHandler: C_
            }), e({
                type: String,
                attribute: "rotation-per-second"
            })], s.prototype, "rotationPerSecond", void 0),
            s
        }
        )((t=>{
            var n, i, r;
            class s extends t {
                constructor() {
                    super(...arguments),
                    this.environmentImage = null,
                    this.skyboxImage = null,
                    this.shadowIntensity = 0,
                    this.shadowSoftness = 1,
                    this.exposure = 1,
                    this.toneMapping = "auto",
                    this[n] = null,
                    this[i] = null,
                    this[r] = null
                }
                updated(t) {
                    super.updated(t),
                    t.has("shadowIntensity") && (this[gv].setShadowIntensity(.5 * this.shadowIntensity),
                    this[mv]()),
                    t.has("shadowSoftness") && (this[gv].setShadowSoftness(this.shadowSoftness),
                    this[mv]()),
                    t.has("exposure") && (this[gv].exposure = this.exposure,
                    this[mv]()),
                    t.has("toneMapping") && (this[gv].toneMapping = this.toneMapping,
                    this[mv]()),
                    (t.has("environmentImage") || t.has("skyboxImage")) && this[Sv]() && this[uu]()
                }
                hasBakedShadow() {
                    return this[gv].bakedShadows.size > 0
                }
                async[(n = lu,
                i = cu,
                r = hu,
                uu)]() {
                    const {skyboxImage: t, environmentImage: e} = this;
                    null != this[hu] && (this[hu](),
                    this[hu] = null);
                    const {textureUtils: n} = this[Ev];
                    if (null == n)
                        return;
                    const i = this[bv].beginActivity();
                    try {
                        const {environmentMap: r, skybox: s} = await n.generateEnvironmentMapAndSkybox(Zc(t), e, (t=>i(iu(t, 0, 1))));
                        this[lu] !== r && (this[lu] = r,
                        this.dispatchEvent(new CustomEvent("environment-change"))),
                        this[cu] = null != s ? s.name === r.name ? r : s : null,
                        this[gv].setEnvironmentAndSkybox(this[lu], this[cu])
                    } catch (t) {
                        if (t instanceof Error)
                            throw this[gv].setEnvironmentAndSkybox(null, null),
                            t
                    } finally {
                        i(1)
                    }
                }
            }
            return au([e({
                type: String,
                attribute: "environment-image"
            })], s.prototype, "environmentImage", void 0),
            au([e({
                type: String,
                attribute: "skybox-image"
            })], s.prototype, "skyboxImage", void 0),
            au([e({
                type: Number,
                attribute: "shadow-intensity"
            })], s.prototype, "shadowIntensity", void 0),
            au([e({
                type: Number,
                attribute: "shadow-softness"
            })], s.prototype, "shadowSoftness", void 0),
            au([e({
                type: Number
            })], s.prototype, "exposure", void 0),
            au([e({
                type: String,
                attribute: "tone-mapping"
            })], s.prototype, "toneMapping", void 0),
            s
        }
        )((t=>{
            var n, i, r, s, o, a, l, c, u, h, d, p, f, A, g, m, v;
            class y extends t {
                constructor() {
                    super(...arguments),
                    this.cameraControls = !1,
                    this.cameraOrbit = Kp,
                    this.cameraTarget = "auto auto auto",
                    this.fieldOfView = "auto",
                    this.minCameraOrbit = "auto",
                    this.maxCameraOrbit = "auto",
                    this.minFieldOfView = "auto",
                    this.maxFieldOfView = "auto",
                    this.interactionPromptThreshold = 3e3,
                    this.interactionPrompt = Zp,
                    this.interactionPromptStyle = tf,
                    this.orbitSensitivity = 1,
                    this.zoomSensitivity = 1,
                    this.panSensitivity = 1,
                    this.touchAction = "none",
                    this.disableZoom = !1,
                    this.disablePan = !1,
                    this.disableTap = !1,
                    this.interpolationDecay = 50,
                    this[n] = this.shadowRoot.querySelector(".interaction-prompt"),
                    this[i] = this.shadowRoot.querySelector("#prompt"),
                    this[r] = [this.shadowRoot.querySelector("#finger0"), this.shadowRoot.querySelector("#finger1")],
                    this[s] = this.shadowRoot.querySelector(".pan-target"),
                    this[o] = 0,
                    this[a] = 1 / 0,
                    this[l] = !1,
                    this[c] = !1,
                    this[u] = qf,
                    this[h] = new jf(this[gv].camera,this[fv],this[gv]),
                    this[d] = new vl,
                    this[p] = !1,
                    this[f] = !1,
                    this[A] = !1,
                    this[g] = ()=>{
                        const t = this[df].changeSource;
                        this[Mf] = t,
                        t === Vf && (this[wf] = !0,
                        this[mf]())
                    }
                    ,
                    this[m] = ()=>{
                        this[vf](),
                        this[mv]();
                        const t = this[df].changeSource;
                        this.dispatchEvent(new CustomEvent("camera-change",{
                            detail: {
                                source: t
                            }
                        }))
                    }
                    ,
                    this[v] = t=>{
                        "pointer-change-start" === t.type ? this[pv].classList.add("pointer-tumbling") : this[pv].classList.remove("pointer-tumbling")
                    }
                }
                get inputSensitivity() {
                    return this[df].inputSensitivity
                }
                set inputSensitivity(t) {
                    this[df].inputSensitivity = t
                }
                getCameraOrbit() {
                    const {theta: t, phi: e, radius: n} = this[If];
                    return {
                        theta: t,
                        phi: e,
                        radius: n,
                        toString() {
                            return `${this.theta}rad ${this.phi}rad ${this.radius}m`
                        }
                    }
                }
                getCameraTarget() {
                    return Cv(this[Ev].isPresenting ? this[Ev].arRenderer.target : this[gv].getTarget())
                }
                getFieldOfView() {
                    return this[df].getFieldOfView()
                }
                getMinimumFieldOfView() {
                    return this[df].options.minimumFieldOfView
                }
                getMaximumFieldOfView() {
                    return this[df].options.maximumFieldOfView
                }
                getIdealAspect() {
                    return this[gv].idealAspect
                }
                jumpCameraToGoal() {
                    this[Tf] = !0,
                    this.requestUpdate(Tf, !1)
                }
                resetInteractionPrompt() {
                    this[Cf] = 0,
                    this[Sf] = 1 / 0,
                    this[wf] = !1,
                    this[xf] = this.interactionPrompt === Zp && this.cameraControls
                }
                zoom(t) {
                    const e = new WheelEvent("wheel",{
                        deltaY: -30 * t
                    });
                    this[fv].dispatchEvent(e)
                }
                connectedCallback() {
                    super.connectedCallback(),
                    this[df].addEventListener("user-interaction", this[_f]),
                    this[df].addEventListener("pointer-change-start", this[bf]),
                    this[df].addEventListener("pointer-change-end", this[bf])
                }
                disconnectedCallback() {
                    super.disconnectedCallback(),
                    this[df].removeEventListener("user-interaction", this[_f]),
                    this[df].removeEventListener("pointer-change-start", this[bf]),
                    this[df].removeEventListener("pointer-change-end", this[bf])
                }
                updated(t) {
                    super.updated(t);
                    const e = this[df]
                      , n = this[gv];
                    if (t.has("cameraControls") && (this.cameraControls ? (e.enableInteraction(),
                    this.interactionPrompt === Zp && (this[xf] = !0)) : (e.disableInteraction(),
                    this[mf]()),
                    this[fv].setAttribute("aria-label", this[ov])),
                    t.has("disableZoom") && (e.disableZoom = this.disableZoom),
                    t.has("disablePan") && (e.enablePan = !this.disablePan),
                    t.has("disableTap") && (e.enableTap = !this.disableTap),
                    (t.has("interactionPrompt") || t.has("cameraControls") || t.has("src")) && (this.interactionPrompt === Zp && this.cameraControls && !this[wf] ? this[xf] = !0 : this[mf]()),
                    t.has("interactionPromptStyle") && (this[Af].style.opacity = "basic" == this.interactionPromptStyle ? "1" : "0"),
                    t.has("touchAction")) {
                        const t = this.touchAction;
                        e.applyOptions({
                            touchAction: t
                        }),
                        e.updateTouchActionStyle()
                    }
                    t.has("orbitSensitivity") && (e.orbitSensitivity = this.orbitSensitivity),
                    t.has("zoomSensitivity") && (e.zoomSensitivity = this.zoomSensitivity),
                    t.has("panSensitivity") && (e.panSensitivity = this.panSensitivity),
                    t.has("interpolationDecay") && (e.setDamperDecayTime(this.interpolationDecay),
                    n.setTargetDamperDecayTime(this.interpolationDecay)),
                    !0 === this[Tf] && Promise.resolve().then((()=>{
                        e.jumpToGoal(),
                        n.jumpToGoal(),
                        this[Ef](),
                        this[Tf] = !1
                    }
                    ))
                }
                async updateFraming() {
                    const t = this[gv]
                      , e = t.adjustedFoV(t.framedFoVDeg);
                    await t.updateFraming();
                    const n = t.adjustedFoV(t.framedFoVDeg)
                      , i = this[df].getFieldOfView() / e;
                    this[df].setFieldOfView(n * i),
                    this[Rf] = !0,
                    this.requestUpdate("maxFieldOfView"),
                    this.requestUpdate("fieldOfView"),
                    this.requestUpdate("minCameraOrbit"),
                    this.requestUpdate("maxCameraOrbit"),
                    this.requestUpdate("cameraOrbit"),
                    await this.updateComplete
                }
                interact(t, e, n) {
                    const i = this[fv]
                      , r = this[gf];
                    if ("1" === r[0].style.opacity)
                        return void console.warn("interact() failed because an existing interaction is running.");
                    const s = new Array;
                    s.push({
                        x: qp(e.x),
                        y: qp(e.y)
                    });
                    const o = [{
                        x: s[0].x(0),
                        y: s[0].y(0)
                    }];
                    null != n && (s.push({
                        x: qp(n.x),
                        y: qp(n.y)
                    }),
                    o.push({
                        x: s[1].x(0),
                        y: s[1].y(0)
                    }));
                    let a = performance.now();
                    const {width: l, height: c} = this[gv]
                      , u = this.getBoundingClientRect()
                      , h = t=>{
                        for (const [e,n] of o.entries()) {
                            const {style: s} = r[e];
                            s.transform = `translateX(${l * n.x}px) translateY(${c * n.y}px)`,
                            "pointerdown" === t ? s.opacity = "1" : "pointerup" === t && (s.opacity = "0");
                            const o = {
                                pointerId: e - 5678,
                                pointerType: "touch",
                                target: i,
                                clientX: l * n.x + u.x,
                                clientY: c * n.y + u.y,
                                altKey: !0
                            };
                            i.dispatchEvent(new PointerEvent(t,o))
                        }
                    }
                      , d = ()=>{
                        const e = this[Mf];
                        if (e !== qf || !i.isConnected) {
                            for (const t of this[gf])
                                t.style.opacity = "0";
                            return h("pointercancel"),
                            this.dispatchEvent(new CustomEvent("interact-stopped",{
                                detail: {
                                    source: e
                                }
                            })),
                            void document.removeEventListener("visibilitychange", p)
                        }
                        const n = Math.min(1, (performance.now() - a) / t);
                        for (const [t,e] of o.entries())
                            e.x = s[t].x(n),
                            e.y = s[t].y(n);
                        h("pointermove"),
                        n < 1 ? requestAnimationFrame(d) : (h("pointerup"),
                        this.dispatchEvent(new CustomEvent("interact-stopped",{
                            detail: {
                                source: qf
                            }
                        })),
                        document.removeEventListener("visibilitychange", p))
                    }
                      , p = ()=>{
                        let t = 0;
                        "hidden" === document.visibilityState ? t = performance.now() - a : a = performance.now() - t
                    }
                    ;
                    document.addEventListener("visibilitychange", p),
                    h("pointerdown"),
                    this[Mf] = qf,
                    requestAnimationFrame(d)
                }
                [(n = ff,
                i = Af,
                r = gf,
                s = pf,
                o = Cf,
                a = Sf,
                l = wf,
                c = xf,
                u = Mf,
                h = df,
                d = If,
                p = Tf,
                f = Bf,
                A = Rf,
                Df)](t) {
                    const e = this[df]
                      , n = this[gv];
                    n.framedFoVDeg = 180 * t[0] / Math.PI,
                    e.changeSource = Wf,
                    e.setFieldOfView(n.adjustedFoV(n.framedFoVDeg)),
                    this[_f]()
                }
                [Lf](t) {
                    const e = this[df];
                    if (this[Rf]) {
                        const {theta: e, phi: n} = this.getCameraOrbit();
                        t[0] = e,
                        t[1] = n,
                        this[Rf] = !1
                    }
                    e.changeSource = Wf,
                    e.setOrbit(t[0], t[1], t[2]),
                    this[_f]()
                }
                [Uf](t) {
                    this[df].applyOptions({
                        minimumAzimuthalAngle: t[0],
                        minimumPolarAngle: t[1],
                        minimumRadius: t[2]
                    }),
                    this.jumpCameraToGoal()
                }
                [Of](t) {
                    this[df].applyOptions({
                        maximumAzimuthalAngle: t[0],
                        maximumPolarAngle: t[1],
                        maximumRadius: t[2]
                    }),
                    this[yf](t[2]),
                    this.jumpCameraToGoal()
                }
                [Nf](t) {
                    this[df].applyOptions({
                        minimumFieldOfView: 180 * t[0] / Math.PI
                    }),
                    this.jumpCameraToGoal()
                }
                [Ff](t) {
                    const e = this[gv].adjustedFoV(180 * t[0] / Math.PI);
                    this[df].applyOptions({
                        maximumFieldOfView: e
                    }),
                    this.jumpCameraToGoal()
                }
                [Pf](t) {
                    const [e,n,i] = t;
                    this[Ev].arRenderer.isPresenting || this[gv].setTarget(e, n, i),
                    this[df].changeSource = Wf,
                    this[Ev].arRenderer.updateTarget(),
                    this[_f]()
                }
                [vv](t, e) {
                    if (super[vv](t, e),
                    this[Ev].isPresenting || !this[wv]())
                        return;
                    const n = this[df]
                      , i = this[gv]
                      , r = performance.now();
                    if (this[xf] && this.loaded && r > this[uv] + this.interactionPromptThreshold && (this[xf] = !1,
                    this[Sf] = r,
                    this[ff].classList.add("visible")),
                    isFinite(this[Sf]) && this.interactionPromptStyle === tf) {
                        const t = (r - this[Sf]) / 5e3 % 1
                          , e = Xp(t)
                          , s = Yp(t);
                        if (this[Af].style.opacity = `${s}`,
                        e !== this[Cf]) {
                            const t = e * i.width * .05
                              , r = (e - this[Cf]) * Math.PI / 16;
                            this[Af].style.transform = `translateX(${t}px)`,
                            n.changeSource = qf,
                            n.adjustOrbit(r, 0, 0),
                            this[Cf] = e
                        }
                    }
                    const s = n.update(t, e)
                      , o = i.updateTarget(e);
                    (s || o) && this[Ef]()
                }
                [mf]() {
                    this[xf] = !1,
                    this[ff].classList.remove("visible"),
                    this[Sf] = 1 / 0
                }
                [yf](t) {
                    const e = Math.max(this[gv].boundingSphere.radius, t)
                      , n = Math.abs(2 * e);
                    this[df].updateNearFar(0, n)
                }
                [vf]() {
                    const {theta: t, phi: e} = this[df].getCameraSpherical(this[If])
                      , n = (4 + Math.floor((t % hf + uf) / lf)) % 4
                      , i = Math.floor(e / cf)
                      , r = Jp[n]
                      , s = $p[i];
                    this[cv](`View from stage ${s}${r}`)
                }
                get[ov]() {
                    return super[ov].replace(/\.$/, "") + (this.cameraControls ? ". Use mouse, touch or arrow keys to move." : "")
                }
                async[_v](t) {
                    const e = this[df]
                      , n = this[gv]
                      , i = n.adjustedFoV(n.framedFoVDeg);
                    super[_v](t);
                    const r = n.adjustedFoV(n.framedFoVDeg) / i
                      , s = e.getFieldOfView() * (isFinite(r) ? r : 1);
                    e.updateAspect(this[gv].aspect),
                    this.requestUpdate("maxFieldOfView", this.maxFieldOfView),
                    await this.updateComplete,
                    this[df].setFieldOfView(s),
                    this.jumpCameraToGoal()
                }
                [yv]() {
                    super[yv](),
                    this[Bf] ? this[Rf] = !0 : this[Bf] = !0,
                    this.requestUpdate("maxFieldOfView", this.maxFieldOfView),
                    this.requestUpdate("fieldOfView", this.fieldOfView),
                    this.requestUpdate("minCameraOrbit", this.minCameraOrbit),
                    this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit),
                    this.requestUpdate("cameraOrbit", this.cameraOrbit),
                    this.requestUpdate("cameraTarget", this.cameraTarget),
                    this.jumpCameraToGoal()
                }
            }
            return g = _f,
            m = Ef,
            v = bf,
            jp([e({
                type: Boolean,
                attribute: "camera-controls"
            })], y.prototype, "cameraControls", void 0),
            jp([zp({
                intrinsics: rf,
                observeEffects: !0,
                updateHandler: Lf
            }), e({
                type: String,
                attribute: "camera-orbit",
                hasChanged: ()=>!0
            })], y.prototype, "cameraOrbit", void 0),
            jp([zp({
                intrinsics: af,
                observeEffects: !0,
                updateHandler: Pf
            }), e({
                type: String,
                attribute: "camera-target",
                hasChanged: ()=>!0
            })], y.prototype, "cameraTarget", void 0),
            jp([zp({
                intrinsics: ef,
                observeEffects: !0,
                updateHandler: Df
            }), e({
                type: String,
                attribute: "field-of-view",
                hasChanged: ()=>!0
            })], y.prototype, "fieldOfView", void 0),
            jp([zp({
                intrinsics: sf,
                updateHandler: Uf
            }), e({
                type: String,
                attribute: "min-camera-orbit",
                hasChanged: ()=>!0
            })], y.prototype, "minCameraOrbit", void 0),
            jp([zp({
                intrinsics: of,
                updateHandler: Of
            }), e({
                type: String,
                attribute: "max-camera-orbit",
                hasChanged: ()=>!0
            })], y.prototype, "maxCameraOrbit", void 0),
            jp([zp({
                intrinsics: nf,
                updateHandler: Nf
            }), e({
                type: String,
                attribute: "min-field-of-view",
                hasChanged: ()=>!0
            })], y.prototype, "minFieldOfView", void 0),
            jp([zp({
                intrinsics: ef,
                updateHandler: Ff
            }), e({
                type: String,
                attribute: "max-field-of-view",
                hasChanged: ()=>!0
            })], y.prototype, "maxFieldOfView", void 0),
            jp([e({
                type: Number,
                attribute: "interaction-prompt-threshold"
            })], y.prototype, "interactionPromptThreshold", void 0),
            jp([e({
                type: String,
                attribute: "interaction-prompt"
            })], y.prototype, "interactionPrompt", void 0),
            jp([e({
                type: String,
                attribute: "interaction-prompt-style"
            })], y.prototype, "interactionPromptStyle", void 0),
            jp([e({
                type: Number,
                attribute: "orbit-sensitivity"
            })], y.prototype, "orbitSensitivity", void 0),
            jp([e({
                type: Number,
                attribute: "zoom-sensitivity"
            })], y.prototype, "zoomSensitivity", void 0),
            jp([e({
                type: Number,
                attribute: "pan-sensitivity"
            })], y.prototype, "panSensitivity", void 0),
            jp([e({
                type: String,
                attribute: "touch-action"
            })], y.prototype, "touchAction", void 0),
            jp([e({
                type: Boolean,
                attribute: "disable-zoom"
            })], y.prototype, "disableZoom", void 0),
            jp([e({
                type: Boolean,
                attribute: "disable-pan"
            })], y.prototype, "disablePan", void 0),
            jp([e({
                type: Boolean,
                attribute: "disable-tap"
            })], y.prototype, "disableTap", void 0),
            jp([e({
                type: Number,
                attribute: "interpolation-decay"
            })], y.prototype, "interpolationDecay", void 0),
            y
        }
        )((t=>{
            var n, i, r, s, o, a, l, c, u, h;
            class d extends t {
                constructor() {
                    super(...arguments),
                    this.ar = !1,
                    this.arScale = "auto",
                    this.arPlacement = "floor",
                    this.arModes = "webxr scene-viewer quick-look",
                    this.iosSrc = null,
                    this._zarboAndroidSrc = "",
                    this._zarbo3dSrc = "",
                    this._temp_src = null,
                    this._zarboIosSrc = "",
                    this.xrEnvironment = !1,
                    this[n] = !1,
                    this[i] = this.shadowRoot.querySelector(".ar-button"),
                    this[r] = document.createElement("a"),
                    this[s] = new Set,
                    this[o] = Xy,
                    this[a] = !1,
                    this[l] = t=>{
                        t.preventDefault(),
                        this.activateAR()
                    }
                    ,
                    this[c] = t=>{
                        let {status: e} = t;
                        e !== Xf && this[Ev].arRenderer.presentedScene !== this[gv] || (this.setAttribute("ar-status", e),
                        this.dispatchEvent(new CustomEvent("ar-status",{
                            detail: {
                                status: e
                            }
                        })),
                        e === Xf ? this.removeAttribute("ar-tracking") : e === Yf && this.setAttribute("ar-tracking", Kf))
                    }
                    ,
                    this[u] = t=>{
                        let {status: e} = t;
                        this.setAttribute("ar-tracking", e),
                        this.dispatchEvent(new CustomEvent("ar-tracking",{
                            detail: {
                                status: e
                            }
                        }))
                    }
                    ,
                    this[h] = t=>{
                        "_apple_ar_quicklook_button_tapped" == t.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"))
                    }
                }
                get canActivateAR() {
                    return this[t_] !== Xy
                }
                connectedCallback() {
                    super.connectedCallback(),
                    this[Ev].arRenderer.addEventListener("status", this[s_]),
                    this.setAttribute("ar-status", Xf),
                    this[Ev].arRenderer.addEventListener("tracking", this[o_]),
                    this[n_].addEventListener("message", this[a_])
                }
                disconnectedCallback() {
                    super.disconnectedCallback(),
                    this[Ev].arRenderer.removeEventListener("status", this[s_]),
                    this[Ev].arRenderer.removeEventListener("tracking", this[o_]),
                    this[n_].removeEventListener("message", this[a_])
                }
                update(t) {
                    super.update(t),
                    t.has("arScale") && (this[gv].canScale = "fixed" !== this.arScale),
                    t.has("arPlacement") && (this[gv].updateShadow(),
                    this[mv]()),
                    t.has("arModes") && (this[e_] = zy(this.arModes)),
                    (t.has("ar") || t.has("arModes") || t.has("src") || t.has("iosSrc")) && this[l_]()
                }
                async activateAR() {
                    switch (this[t_]) {
                    case Wy:
                        let t = this._zarboIosSrc.split(".").splice(-1, 1)[0];
                        !this._zarboIosSrc || "glb" !== t && "gltf" !== t ? this[$y]() : this._zarboIosSrc !== this.src ? (this.src = this._zarboIosSrc,
                        await this[hv](),
                        await ou(this, "load"),
                        this[$y](),
                        setTimeout((()=>{
                            this.src = this._zarbo3dSrc,
                            this[hv]()
                        }
                        ), 100)) : this[$y]();
                        break;
                    case jy:
                        this._temp_src = this.src,
                        this._zarboAndroidSrc && this.src !== this._zarboAndroidSrc && (this.src = this._zarboAndroidSrc,
                        await this[hv](),
                        await ou(this, "load")),
                        await this[Ky]();
                        break;
                    case qy:
                        this[Jy]();
                        break;
                    default:
                        console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities")
                    }
                }
                getFileExtension(t) {
                    return t.split(".").pop()
                }
                async[(n = Zy,
                i = Yy,
                r = n_,
                s = e_,
                o = t_,
                a = i_,
                l = r_,
                c = s_,
                u = o_,
                h = a_,
                l_)]() {
                    let t = Xy;
                    if (this.ar) {
                        if (null != this.src)
                            for (const e of this[e_]) {
                                if ("webxr" === e && zc && !ky && await this[Ev].arRenderer.supportsPresentation()) {
                                    t = jy;
                                    break
                                }
                                if ("scene-viewer" === e && Kc && !Gy) {
                                    t = qy;
                                    break
                                }
                                if ("quick-look" === e && $c) {
                                    t = Wy;
                                    break
                                }
                            }
                        t === Xy && null != this._zarboIosSrc && $c && (t = Wy)
                    }
                    if (t !== Xy)
                        this[Yy].classList.add("enabled"),
                        this[Yy].addEventListener("click", this[r_]);
                    else if (this[Yy].classList.contains("enabled")) {
                        this[Yy].removeEventListener("click", this[r_]),
                        this[Yy].classList.remove("enabled");
                        const t = "failed";
                        this.setAttribute("ar-status", t),
                        this.dispatchEvent(new CustomEvent("ar-status",{
                            detail: {
                                status: t
                            }
                        }))
                    }
                    this[t_] = t
                }
                async[Ky]() {
                    console.log("Attempting to present in AR with WebXR..."),
                    await this[c_]();
                    try {
                        this[Yy].removeEventListener("click", this[r_]);
                        const {arRenderer: t} = this[Ev];
                        t.placeOnWall = "wall" === this.arPlacement,
                        await t.present(this[gv], this.xrEnvironment),
                        this[Ev].arRenderer.addEventListener("status", (async t=>{
                            "session-end" === t.status && (this.src = this._temp_src,
                            await this[hv]())
                        }
                        ))
                    } catch (t) {
                        console.warn("Error while trying to present in AR with WebXR"),
                        console.error(t),
                        await this[Ev].arRenderer.stopPresenting(),
                        ky = !0,
                        console.warn("Falling back to next ar-mode"),
                        await this[l_](),
                        this.activateAR()
                    } finally {
                        this[l_]()
                    }
                }
                async[c_]() {
                    this.loaded || (this[i_] = !0,
                    this[hv](),
                    await ou(this, "load"),
                    this[i_] = !1)
                }
                [Sv]() {
                    return super[Sv]() || this[i_]
                }
                [Jy]() {
                    const t = self.location.toString()
                      , e = new URL(t);
                    let n = "";
                    n = this._zarboAndroidSrc ? this._zarboAndroidSrc : this.src;
                    const i = new URL(n,t);
                    i.hash && (i.hash = "");
                    const r = new URLSearchParams(i.search);
                    if (e.hash = Hy,
                    r.set("mode", "ar_preferred"),
                    r.has("disable_occlusion") || r.set("disable_occlusion", "true"),
                    "fixed" === this.arScale && r.set("resizable", "false"),
                    "wall" === this.arPlacement && r.set("enable_vertical_placement", "true"),
                    r.has("sound")) {
                        const e = new URL(r.get("sound"),t);
                        r.set("sound", e.toString())
                    }
                    if (r.has("link")) {
                        const e = new URL(r.get("link"),t);
                        r.set("link", e.toString())
                    }
                    const s = `intent://arvr.google.com/scene-viewer/1.0?${r.toString() + "&file=" + encodeURIComponent(i.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e.toString())};end;`;
                    self.addEventListener("hashchange", (()=>{
                        self.location.hash === Hy && (Gy = !0,
                        self.history.back(),
                        console.warn("Error while trying to present in AR with Scene Viewer"),
                        console.warn("Falling back to next ar-mode"),
                        this[l_]())
                    }
                    ), {
                        once: !0
                    }),
                    this[n_].setAttribute("href", s),
                    console.log("Attempting to present in AR with Scene Viewer..."),
                    this[n_].click()
                }
                async[$y]() {
                    const t = !this.iosSrc;
                    this[Yy].classList.remove("enabled");
                    const e = t ? await this.prepareUSDZ() : this.iosSrc
                      , n = new URL(e,self.location.toString());
                    if (t) {
                        const t = self.location.toString()
                          , e = new URL(t)
                          , i = new URL(this._zarboIosSrc,e);
                        i.hash && (n.hash = i.hash)
                    }
                    "fixed" === this.arScale && (n.hash && (n.hash += "&"),
                    n.hash += "allowsContentScaling=0");
                    const i = this[n_];
                    i.setAttribute("rel", "ar");
                    const r = document.createElement("img");
                    i.appendChild(r),
                    i.setAttribute("href", n.toString()),
                    t && i.setAttribute("download", "model.usdz"),
                    i.style.display = "none",
                    i.isConnected || this.shadowRoot.appendChild(i),
                    console.log("Attempting to present in AR with Quick Look..."),
                    i.click(),
                    i.removeChild(r),
                    t && URL.revokeObjectURL(e),
                    this[Yy].classList.add("enabled")
                }
                async prepareUSDZ() {
                    const t = this[bv].beginActivity();
                    await this[c_]();
                    const {model: e, shadow: n} = this[gv];
                    if (null == e)
                        return "";
                    let i = !1;
                    null != n && (i = n.visible,
                    n.visible = !1),
                    t(.2);
                    const r = new Ty
                      , s = await r.parse(e)
                      , o = new Blob([s],{
                        type: "model/vnd.usdz+zip"
                    })
                      , a = URL.createObjectURL(o);
                    return t(1),
                    null != n && (n.visible = i),
                    a
                }
            }
            return Qy([e({
                type: Boolean,
                attribute: "ar"
            })], d.prototype, "ar", void 0),
            Qy([e({
                type: String,
                attribute: "ar-scale"
            })], d.prototype, "arScale", void 0),
            Qy([e({
                type: String,
                attribute: "ar-placement"
            })], d.prototype, "arPlacement", void 0),
            Qy([e({
                type: String,
                attribute: "ar-modes"
            })], d.prototype, "arModes", void 0),
            Qy([e({
                type: String,
                attribute: "ios-src"
            })], d.prototype, "iosSrc", void 0),
            Qy([e({
                type: String
            })], d.prototype, "_zarboAndroidSrc", void 0),
            Qy([e({
                type: String
            })], d.prototype, "_zarbo3dSrc", void 0),
            Qy([e({
                type: String
            })], d.prototype, "_temp_src", void 0),
            Qy([e({
                type: String
            })], d.prototype, "_zarboIosSrc", void 0),
            Qy([e({
                type: Boolean,
                attribute: "xr-environment"
            })], d.prototype, "xrEnvironment", void 0),
            d
        }
        )((t=>{
            var n, i, r, s, o, a, l, c;
            class u extends t {
                constructor() {
                    super(...arguments),
                    this.poster = null,
                    this.reveal = h_,
                    this.loading = "auto",
                    this[n] = !1,
                    this[i] = !1,
                    this[r] = this.shadowRoot.querySelector(".slot.poster"),
                    this[s] = this.shadowRoot.querySelector("#default-poster"),
                    this[o] = this.shadowRoot.querySelector("#default-progress-bar > .bar"),
                    this[a] = this[f_].getAttribute("aria-label"),
                    this[l] = ((t,e)=>{
                        let n = null;
                        const i = function() {
                            null == n && (t(...arguments),
                            n = self.setTimeout((()=>n = null), 100))
                        };
                        return i.flush = ()=>{
                            null != n && (self.clearTimeout(n),
                            n = null)
                        }
                        ,
                        i
                    }
                    )((t=>{
                        const e = this[d_].parentNode;
                        requestAnimationFrame((()=>{
                            this[d_].style.transform = `scaleX(${t})`,
                            0 === t && (e.removeChild(this[d_]),
                            e.appendChild(this[d_])),
                            1 === t ? this[d_].classList.add("hide") : this[d_].classList.remove("hide")
                        }
                        ))
                    }
                    )),
                    this[c] = t=>{
                        const e = t.detail.totalProgress;
                        1 === e && (this[v_].flush(),
                        this.loaded && (this[A_] || this.reveal === h_) && this[g_]()),
                        this[v_](e),
                        this.dispatchEvent(new CustomEvent("progress",{
                            detail: {
                                totalProgress: e
                            }
                        }))
                    }
                    ;
                    const t = self.ModelViewerElement || {}
                      , e = t.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.5.6/";
                    Yh.setDRACODecoderLocation(e);
                    const u = t.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
                    Yh.setKTX2TranscoderLocation(u),
                    t.meshoptDecoderLocation && Yh.setMeshoptDecoderLocation(t.meshoptDecoderLocation);
                    const h = t.lottieLoaderLocation || "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/LottieLoader.js";
                    IA.singleton.textureUtils.lottieLoaderUrl = h
                }
                static set dracoDecoderLocation(t) {
                    Yh.setDRACODecoderLocation(t)
                }
                static get dracoDecoderLocation() {
                    return Yh.getDRACODecoderLocation()
                }
                static set ktx2TranscoderLocation(t) {
                    Yh.setKTX2TranscoderLocation(t)
                }
                static get ktx2TranscoderLocation() {
                    return Yh.getKTX2TranscoderLocation()
                }
                static set meshoptDecoderLocation(t) {
                    Yh.setMeshoptDecoderLocation(t)
                }
                static get meshoptDecoderLocation() {
                    return Yh.getMeshoptDecoderLocation()
                }
                static set lottieLoaderLocation(t) {
                    IA.singleton.textureUtils.lottieLoaderUrl = t
                }
                static get lottieLoaderLocation() {
                    return IA.singleton.textureUtils.lottieLoaderUrl
                }
                static mapURLs(t) {
                    IA.singleton.loader[qh].manager.setURLModifier(t)
                }
                dismissPoster() {
                    this.loaded ? this[g_]() : (this[A_] = !0,
                    this[hv]())
                }
                showPoster() {
                    const t = this[p_];
                    if (t.classList.contains("show"))
                        return;
                    t.classList.add("show"),
                    this[fv].classList.remove("show");
                    const e = this[f_];
                    e.removeAttribute("tabindex"),
                    e.removeAttribute("aria-hidden");
                    const n = this.modelIsVisible;
                    this[m_] = !1,
                    this[sv](n)
                }
                getDimensions() {
                    return Cv(this[gv].size)
                }
                getBoundingBoxCenter() {
                    return Cv(this[gv].boundingBox.getCenter(new he))
                }
                connectedCallback() {
                    super.connectedCallback(),
                    this.loaded || this.showPoster(),
                    this[bv].addEventListener("progress", this[__])
                }
                disconnectedCallback() {
                    super.disconnectedCallback(),
                    this[bv].removeEventListener("progress", this[__])
                }
                async updated(t) {
                    super.updated(t),
                    t.has("poster") && null != this.poster && (this[f_].style.backgroundImage = `url(${this.poster})`),
                    t.has("alt") && this[f_].setAttribute("aria-label", this[av]),
                    (t.has("reveal") || t.has("loading")) && this[hv]()
                }
                [(n = m_,
                i = A_,
                r = p_,
                s = f_,
                o = d_,
                a = y_,
                l = v_,
                c = __,
                Sv)]() {
                    return !!this.src && (this[A_] || "eager" === this.loading || this.reveal === h_ && this[rv])
                }
                [g_]() {
                    this[A_] = !1;
                    const t = this[p_];
                    if (!t.classList.contains("show"))
                        return;
                    t.classList.remove("show"),
                    this[fv].classList.add("show");
                    const e = this.modelIsVisible;
                    this[m_] = !0,
                    this[sv](e);
                    const n = this.getRootNode();
                    n && n.activeElement === this && this[fv].focus();
                    const i = this[f_];
                    i.setAttribute("aria-hidden", "true"),
                    i.tabIndex = -1,
                    this.dispatchEvent(new CustomEvent("poster-dismissed"))
                }
                [wv]() {
                    return super[wv]() && this[m_]
                }
            }
            return u_([e({
                type: String
            })], u.prototype, "poster", void 0),
            u_([e({
                type: String
            })], u.prototype, "reveal", void 0),
            u_([e({
                type: String
            })], u.prototype, "loading", void 0),
            u
        }
        )((t=>{
            var n;
            class i extends t {
                constructor() {
                    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                        e[i] = arguments[i];
                    super(e),
                    this.autoplay = !1,
                    this.animationName = void 0,
                    this.animationCrossfadeDuration = 300,
                    this[n] = !0,
                    this[gv].subscribeMixerEvent("loop", (t=>{
                        const e = t.action._loopCount;
                        this.dispatchEvent(new CustomEvent("loop",{
                            detail: {
                                count: e
                            }
                        }))
                    }
                    )),
                    this[gv].subscribeMixerEvent("finished", (()=>{
                        this[Rv] = !0,
                        this.dispatchEvent(new CustomEvent("finished"))
                    }
                    ))
                }
                get availableAnimations() {
                    return this.loaded ? this[gv].animationNames : []
                }
                get duration() {
                    return this[gv].duration
                }
                get paused() {
                    return this[Rv]
                }
                get currentTime() {
                    return this[gv].animationTime
                }
                set currentTime(t) {
                    this[gv].animationTime = t,
                    this[mv]()
                }
                get timeScale() {
                    return this[gv].animationTimeScale
                }
                set timeScale(t) {
                    this[gv].animationTimeScale = t
                }
                pause() {
                    this[Rv] || (this[Rv] = !0,
                    this.dispatchEvent(new CustomEvent("pause")))
                }
                play(t) {
                    this.availableAnimations.length > 0 && (this[Rv] = !1,
                    this[Bv](t),
                    this.dispatchEvent(new CustomEvent("play")))
                }
                [(n = Rv,
                yv)]() {
                    super[yv](),
                    this[Rv] = !0,
                    null != this.animationName && this[Bv](),
                    this.autoplay && this.play()
                }
                [vv](t, e) {
                    super[vv](t, e),
                    this[Rv] || !this[wv]() && !this[Ev].isPresenting || (this[gv].updateAnimation(e / 1e3),
                    this[mv]())
                }
                updated(t) {
                    super.updated(t),
                    t.has("autoplay") && this.autoplay && this.play(),
                    t.has("animationName") && this[Bv]()
                }
                [Bv]() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Lv;
                    var e;
                    const n = null !== (e = t.repetitions) && void 0 !== e ? e : 1 / 0
                      , i = t.pingpong ? Z : 1 === n ? 2200 : 2201;
                    this[gv].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, i, n),
                    this[Rv] && (this[gv].updateAnimation(0),
                    this[mv]())
                }
            }
            return Tv([e({
                type: Boolean
            })], i.prototype, "autoplay", void 0),
            Tv([e({
                type: String,
                attribute: "animation-name"
            })], i.prototype, "animationName", void 0),
            Tv([e({
                type: Number,
                attribute: "animation-crossfade-duration"
            })], i.prototype, "animationCrossfadeDuration", void 0),
            i
        }
        )(Iv))))))));
        customElements.define("zarbo-widget", I_)
    }()
}();
